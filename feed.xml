<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2025-01-26T10:23:40+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">golang 问题记录</title><link href="https://gbcpp.github.io/notes/golang-issues.html" rel="alternate" type="text/html" title="golang 问题记录" /><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/golang-issues</id><content type="html" xml:base="https://gbcpp.github.io/notes/golang-issues.html"><![CDATA[<p>  </p>
<blockquote>
  <p>记录 Golang 学习、开发过程中的一些疑难杂症。</p>
</blockquote>

<h1 id="环境问题">环境问题</h1>

<h2 id="missing-gosum-entry-for-module">missing go.sum entry for module</h2>

<p>曾经编译过的代码出现类似如下的错误 <code class="language-plaintext highlighter-rouge">missing go.sum entry for module</code>，各种依赖缺失的 mod，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base/file.go:10:2: missing go.sum entry for module providing package github.com/astaxie/beego/logs; to add:
	go mod download github.com/astaxie/beego
base/name_generate.go:6:2: missing go.sum entry for module providing package github.com/google/uuid (imported by ben/base); to add:
	go get ben/base
helpers/data_analysis/base/bar_base.go:6:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/charts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/metrics.go:9:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/components (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/bar_base.go:7:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/opts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
</code></pre></div></div>

<p><strong>解决办法</strong></p>

<p>使用 <code class="language-plaintext highlighter-rouge">go mod tidy</code> 来整理依赖，该命令有如下作用：</p>

<ul>
  <li>删除不需要的依赖包</li>
  <li>下载新的依赖包</li>
  <li>更新 <code class="language-plaintext highlighter-rouge">go.sum</code></li>
</ul>

<p>重新执行 <code class="language-plaintext highlighter-rouge">go run</code> <code class="language-plaintext highlighter-rouge">go build</code> 问题解决。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[   记录 Golang 学习、开发过程中的一些疑难杂症。]]></summary></entry><entry><title type="html">直播回源优化</title><link href="https://gbcpp.github.io/notes/optimize-back-to-source.html" rel="alternate" type="text/html" title="直播回源优化" /><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/optimize-back-to-source</id><content type="html" xml:base="https://gbcpp.github.io/notes/optimize-back-to-source.html"><![CDATA[<blockquote>
  <p>该文档主要考虑的是针对需要回源时秒开的优化。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>  当前 streamd server 在收到拉流请求时，若需要回源，在回源后 streamd 下发给 Player 数据时使用的是帧级别的下发，特别是在接收首个关键帧时，只有接收到完整的视频帧以后，方才开始下发给 Player，这样无形中增加了一定的数据接收+组帧的耗时，通过当前 superset 的数据分析，在需要回源的 case 中， streamd 等待接收首个视频关键帧的时长几乎全部超过 100ms 以上，这便为该次播放请求增加了固定时间的延迟，优化空间明显。</p>

<h1 id="优化内容">优化内容</h1>

<p>  针对当前数据转发的模式，将帧级别的转发模式优化为 Slice 级别的转发模式。</p>

<h2 id="流程图">流程图</h2>

<p><img src="/assets/img/blog/streamd-optimize.png" alt="数据转发流程图" /></p>

<h2 id="优点">优点</h2>

<ul>
  <li>加快秒开速度，减少回源阶段 Block 等待时间，初步估计对回源 case 的秒开优化在百毫秒以上。</li>
  <li>Streamd 下发数据时基于 Slice 进行下发，数据发送更加平滑，减少 Frame 级别的下发带来的网络拥塞，有益于卡顿率的降低。</li>
</ul>

<h2 id="缺点">缺点</h2>

<p>  Streamd 服务在各协议的封装性上需要结构性的调整，数据流程改动较大，需要考虑不同 Protocol/Muxer/Demuxer 之间的兼容性，可能难以实现所有 Protocol/Muxer/Demuxer 之间的分片转发，但依然有很大的优化场景需求。
最理想的情况为：源站提供 FLV 的数据拉流协议，而 Streamd 也是用 FLV 的回源拉流协议，Streamd 在接收端最多需要处理 FLV Header Tag 的部分信息，不阻塞 Slice 的下发。</p>

<h2 id="flv-格式">FLV 格式</h2>

<p><a href="https://blog.ibaoger.com/2017/06/04/flv-file-format/">Reference URL</a></p>

<p><img src="/assets/img/blog/flv-format.png" alt="FLV format" /></p>

<h1 id="srs-现状">SRS 现状</h1>

<p>  那么问题来了， srs 是否已经考虑到这一点的优化空间呢？</p>

<p>  对比查看 srs 是否使用的这种透明转发模式，还是帧转发模式？
这里记录的为使用 HTTP-FLV 回源协议的代码流程。</p>

<p>srs 需要回源时建议优先使用 Edge 模式，回源时，内部首先创建一个 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream</code> 实例，用于向源站发起连接，并用于实时的接收、处理数据，代码文件：<code class="language-plaintext highlighter-rouge">srs_app_edge.cpp</code>。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">connect</code> ==&gt; <code class="language-plaintext highlighter-rouge">do_connect</code> 发起向源站的连接请求，判定 http response status code 非 404、非 302 后，开始接收、处理媒体数据。</p>

<p>事件轮询在 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::ingest()</code> 中，同步模式不断循环执行 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream::recv_message()</code> 接收完整的数据，而后通过 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::process_publish_message</code> 将数据流转到后序处理的模块，比如 Source、Consumer 等，但在这之前重点是确认在 recv_message 中是否会 block 等待完整的一个 tag data。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsEdgeFlvUpstream</span><span class="o">::</span><span class="n">recv_message</span><span class="p">(</span><span class="n">SrsCommonMessage</span><span class="o">**</span> <span class="n">pmsg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">time</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag header"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">srs_freepa</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag data"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">pps</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_previous_tag_size</span><span class="p">(</span><span class="n">pps</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read pts"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">stream_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SrsCommonMessage</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">srs_rtmp_create_msg</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"create message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">pmsg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到首先读取 tag_header，然后从header 中获取 tag size 开始读取指定size 的tag data，<code class="language-plaintext highlighter-rouge">SrsFlvDecoder::read_tag_data()</code> ==» <code class="language-plaintext highlighter-rouge">SrsHttpFileReader:read()</code></p>

<p>可以看到在 <code class="language-plaintext highlighter-rouge">SrsHttpFileReader::read(void* buf, size_t count, ssize_t* pnread)</code> 中其会持续的尝试去接收指定 size 大小的数据，直到接收完整，或者 io 报错，源码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsHttpFileReader</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="o">*</span> <span class="n">pnread</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">http</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">total_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total_read</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">ssize_t</span> <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">http</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">total_read</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">count</span> <span class="o">-</span> <span class="n">total_read</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nread</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">srs_assert</span><span class="p">(</span><span class="n">nread</span><span class="p">);</span>
        <span class="n">total_read</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pnread</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pnread</span> <span class="o">=</span> <span class="n">total_read</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>结论：</strong> 当前 srs 使用的是帧级别的转发模式，没有实现分片的透明转发。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[该文档主要考虑的是针对需要回源时秒开的优化。]]></summary></entry><entry><title type="html">直播场景TCP秒开优化</title><link href="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html" rel="alternate" type="text/html" title="直播场景TCP秒开优化" /><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/tcp-optimize-livestream-scene</id><content type="html" xml:base="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html"><![CDATA[<blockquote>
  <p>当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>公司使用静态节点和动态节点作为边缘以节省成本，且多种业务集中进行混布，其中动态节点质量较差，但成本较低，也是导致问题的关键所在，在对Linux 内核的升级和参数调整操作上一定要慎重。</p>

<p><strong>当前动态节点版本及相关配置：</strong></p>

<ul>
  <li>内核版本：5.4.119-19-0006</li>
  <li>见下面章节</li>
</ul>

<h1 id="优化验证">优化验证</h1>

<h2 id="环境准备">环境准备</h2>

<h3 id="tc-配置">TC 配置</h3>

<p>首先安装 tc 工具，系统默认不安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> iproute2

tc <span class="nt">--version</span>
</code></pre></div></div>

<p><strong>启动配置网损:</strong></p>

<p>比如配置 <code class="language-plaintext highlighter-rouge">lo</code> 网卡 50～150ms 左右的延迟，且包含 0～15% 的一个随机丢包，配置如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>su
<span class="nv">$ </span>tc qdisc add dev lo root netem delay 50ms 25ms distribution normal loss random 0% 15%

<span class="c"># 查看配置是否生效</span>
<span class="nv">$ </span>tc qdisc show dev lo
  qdisc netem 8002: root refcnt 2 limit 1000 delay 50ms  25ms
</code></pre></div></div>

<p><strong>验证：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ping 127.0.0.1 <span class="nt">-i</span> 0.2
PING 127.0.0.1 <span class="o">(</span>127.0.0.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>102 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>115 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>175 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>80.4 ms
<span class="nt">---</span> 127.0.0.1 ping statistics <span class="nt">---</span>
21 packets transmitted, 20 received, 4.7619% packet loss, <span class="nb">time </span>4016ms
rtt min/avg/max/mdev <span class="o">=</span> 48.201/113.013/207.390/42.338 ms, pipe 2
</code></pre></div></div>

<p><strong>恢复：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 删除配置</span>
<span class="nv">$ </span>tc qdisc del dev lo root
</code></pre></div></div>

<p><strong>注意：</strong> 不要无脑 copy 别人的 tc 配置命令，使用了 <code class="language-plaintext highlighter-rouge">channge</code> 而非 <code class="language-plaintext highlighter-rouge">add</code>，导致 <code class="language-plaintext highlighter-rouge">Error: Qdisc not found. To create specify NLM_F_CREATE flag.</code> 报错，还以为内核缺少 sch_netem 模块，差点重新安装完整内核。
可以通过命令：<code class="language-plaintext highlighter-rouge">modinfo sch_netem</code> 查看系统是否已经安装有 <code class="language-plaintext highlighter-rouge">sche_netem</code> 模块，如果没有就会报错，有的话会有模块信息输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename:       /lib/modules/6.8.0-51-generic/kernel/net/sched/sch_netem.ko.zst
description:    Network characteristics emulator qdisc
license:        GPL
srcversion:     7631AD62974660130A36DCA
depends:
retpoline:      Y
intree:         Y
name:           sch_netem
vermagic:       6.8.0-51-generic SMP preempt mod_unload modversions
sig_id:         PKCS#7
signer:         Build <span class="nb">time </span>autogenerated kernel key
sig_key:        29:0D:80:5A:E0:B3:D6:D4:D4:D3:D0:EF:AB:48:F3:DB:73:58:2F:63
sig_hashalgo:   sha512
signature:      03:A4:1E:0E:CA:01:0F:58:3E:93:93:A7:25:97:FC:82:3E:4F:60:CA:
                00:84:75:DF:A3:20:F7:1B:92:9D:B1:58:6D:E2:47:92:84:83:00:FD:
                ...
</code></pre></div></div>

<h3 id="netperf">NetPerf</h3>

<ul>
  <li>启动 netserver</li>
</ul>

<p>启动 <code class="language-plaintext highlighter-rouge">netserver</code>, <code class="language-plaintext highlighter-rouge">netserver</code> 与 <code class="language-plaintext highlighter-rouge">netperf</code> 是同一套 Tools，只是 server 测启动命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netserver <span class="nt">-h</span>

Usage: netserver <span class="o">[</span>options]

Options:
    <span class="nt">-h</span>                Display this text
    <span class="nt">-D</span>                Do not daemonize
    <span class="nt">-d</span>                Increase debugging output
    <span class="nt">-f</span>                Do not spawn chilren <span class="k">for </span>each <span class="nb">test</span>, run serially
    <span class="nt">-L</span> name,family    Use name to pick listen address and family <span class="k">for </span>family
    <span class="nt">-N</span>                No debugging output, even <span class="k">if </span>netperf asks
    <span class="nt">-p</span> portnum        Listen <span class="k">for </span>connect requests on portnum.
    <span class="nt">-4</span>                Do IPv4
    <span class="nt">-6</span>                Do IPv6
    <span class="nt">-v</span> verbosity      Specify the verbosity level
    <span class="nt">-V</span>                Display version information and <span class="nb">exit</span>
    <span class="nt">-Z</span> passphrase     Expect passphrase as the first thing received


<span class="c"># 启动命令</span>
<span class="nv">$ </span>~<span class="nv">$ </span><span class="nb">sudo </span>netserver <span class="nt">-p</span> 1234 <span class="nt">-D</span> <span class="nt">-4</span>
check_if_inetd: enter
setup_listens: enter
create_listens: called with host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span> family AF_INET<span class="o">(</span>2<span class="o">)</span>
getaddrinfo returned the following <span class="k">for </span>host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span>  family AF_INET
        cannonical name: <span class="s1">'(nil)'</span>
        flags: 1 family: AF_INET: socktype: SOCK_STREAM protocol IPPROTO_TCP addrlen 16
        sa_family: AF_INET sadata: 4 210 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Starting netserver with host <span class="s1">'IN(6)ADDR_ANY'</span> port <span class="s1">'1234'</span> and family AF_INET
accept_connections: enter
set_fdset: enter list 0x5f3130ac4740 fd_set 0x7fff92fb9450
setting 3 <span class="k">in </span>fdset

</code></pre></div></div>

<p>使 <code class="language-plaintext highlighter-rouge">netserver</code> 监听在 1234 端口上，并指定 IPv4 协议，-D 表示不在后台运行。</p>

<ul>
  <li>启动 Client</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 10  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 100,3000000
</code></pre></div></div>

<p>参数说明：
-H： 指定 server 的 IP 地址
-p： 指定 server 的 port
-l： 指定测试运行多长时间，单位：秒
-t： 运行模式，我们使用 <code class="language-plaintext highlighter-rouge">TCP_CRR</code> 来模拟 client 请求与 server 建连以后，由server 下发一定的数据量以后，关闭连接的这种 request/response 模式
-r： 分别指定 request 和 response 的字节数大小</p>

<h2 id="默认配置benchmark">默认配置Benchmark</h2>

<p>记录下当前内核参数中与 tcp 相关的配置，并获取当前配置的 Benchmark 数据，用以在后续的优化中进行对比。
首先直接用 <code class="language-plaintext highlighter-rouge">netperf</code> 执行 20分钟的测试数据获取：</p>

<p>首先获取下当前测试流的关键帧的大小用以模拟尽量贴近实际业务场景的模拟：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 首先 dump 到本地</span>
ffmpeg <span class="nt">-i</span> http://xxxx/yyyyy/zzzzzzz.flv <span class="nt">-c</span> copy  1.flv

<span class="c"># 然后获取该片段的的首个关键帧的大小</span>
ffmpeg <span class="nt">-i</span> 1.flv <span class="nt">-frames</span>:v 1 <span class="nt">-f</span> image2pipe <span class="nt">-vcodec</span> mjpeg - | <span class="nb">wc</span> <span class="nt">-c</span>

<span class="c"># 可以看到最后输出的为：117118，即 114KB 左右。</span>
</code></pre></div></div>

<p>netperf 模拟 Player 请求下发直播数据，这里设置让 server 一次性下发 300KB 的数据，同时假设 Client 的 request 默认为 1KB,
测试 20分钟，命令如下：</p>

<p><strong>测试数据：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 1200  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

16384  131072 100      3000000  100.01      0.79
16384  131072
</code></pre></div></div>

<blockquote>
  <p>上述测试数据输出的 <code class="language-plaintext highlighter-rouge">Local /Remote</code> 可以看到在下面多出一行，分别表示的是 local 和 remote 的 socket send and recv buffer’s bytes。
最后一列 <code class="language-plaintext highlighter-rouge">Trans</code> 表示的便是在测试的这段时间内平均每秒钟可以执行了多少次请求，即 0.79 次，相当于 Qps，越大说明效率越高。</p>
</blockquote>

<h1 id="tcp-内核参数优化">TCP 内核参数优化：</h1>

<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数说明</a></p>

<h2 id="内核参数配置">内核参数配置</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@XXXLink64 ~]# sysctl <span class="nt">-a</span> | <span class="nb">grep</span> <span class="s2">"net</span><span class="se">\.</span><span class="s2">ipv4</span><span class="se">\.</span><span class="s2">tcp"</span>

<span class="c"># 下面 4 个参数不区分协议</span>
<span class="c"># 默认的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_max <span class="o">=</span> 327680
<span class="c"># 默认的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_max <span class="o">=</span> 3276800

<span class="c"># 在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，默认值是 1000</span>
net.core.netdev_max_backlog <span class="o">=</span> 3000

<span class="c"># 定义了系统中每一个端口最大的监听队列的长度，是个全局的参数</span>
net.core.somaxconn <span class="o">=</span> 2048

<span class="c"># 表示每个套接字所允许的最大缓冲区的大小</span>
net.core.optmem_max <span class="o">=</span> 81920

<span class="c"># 自动调整 tcp recv buffer</span>
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0

<span class="c"># 用于控制当服务器的监听队列（listen 队列）溢出时，是否向客户端发送 TCP 重置（RST）信号以终止连接</span>
net.ipv4.tcp_abort_on_overflow <span class="o">=</span> 0

<span class="c"># 内核中与 TCP 窗口大小相关的一个参数，它影响接收窗口的大小调整行为</span>
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1

net.ipv4.tcp_allowed_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_app_win <span class="o">=</span> 31

<span class="c"># 尽量合并包一起发送，减少发包数量。enable 了会增加延迟，建议关闭</span>
net.ipv4.kcp_autocorking <span class="o">=</span> 1

net.ipv4.tcp_available_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_available_ulp <span class="o">=</span> 
net.ipv4.tcp_base_mss <span class="o">=</span> 1024
net.ipv4.tcp_challenge_ack_limit <span class="o">=</span> 1000
net.ipv4.tcp_comp_sack_delay_ns <span class="o">=</span> 1000000
net.ipv4.tcp_comp_sack_nr <span class="o">=</span> 44
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr
net.ipv4.tcp_dsack <span class="o">=</span> 1
net.ipv4.tcp_early_demux <span class="o">=</span> 1
net.ipv4.tcp_early_retrans <span class="o">=</span> 3
net.ipv4.tcp_ecn <span class="o">=</span> 2
net.ipv4.tcp_ecn_fallback <span class="o">=</span> 1
net.ipv4.tcp_fack <span class="o">=</span> 0
net.ipv4.tcp_fastopen <span class="o">=</span> 1
net.ipv4.tcp_fastopen_blackhole_timeout_sec <span class="o">=</span> 3600
net.ipv4.tcp_fastopen_key <span class="o">=</span> 5b1b3bb0-e9881f5a-8bf3fda0-1c410b36
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30
net.ipv4.tcp_frto <span class="o">=</span> 2
net.ipv4.tcp_fwmark_accept <span class="o">=</span> 0
net.ipv4.tcp_inherit_buffsize <span class="o">=</span> 1
net.ipv4.tcp_init_cwnd <span class="o">=</span> 15
net.ipv4.tcp_init_rto <span class="o">=</span> 1000
net.ipv4.tcp_invalid_ratelimit <span class="o">=</span> 500

<span class="c"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效</span>
net.ipv4.tcp_keepalive_time <span class="o">=</span> 7200
<span class="c"># 探测消息未获得响应时，重发该消息的间隔时间（秒）</span>
net.ipv4.tcp_keepalive_intvl <span class="o">=</span> 75
<span class="c"># 在认定TCP连接失效之前，最多发送多少个keepalive探测消息</span>
net.ipv4.tcp_keepalive_probes <span class="o">=</span> 9

net.ipv4.tcp_l3mdev_accept <span class="o">=</span> 0
net.ipv4.tcp_limit_output_bytes <span class="o">=</span> 1048576
net.ipv4.tcp_loss_init_cwnd <span class="o">=</span> 10
<span class="c"># 允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用</span>
net.ipv4.tcp_low_latency <span class="o">=</span> 0
net.ipv4.tcp_max_orphans <span class="o">=</span> 524288
net.ipv4.tcp_max_reordering <span class="o">=</span> 300
net.ipv4.tcp_max_syn_backlog <span class="o">=</span> 62144
net.ipv4.tcp_max_tw_buckets <span class="o">=</span> 6000
net.ipv4.tcp_mem <span class="o">=</span> 2621440      3932160 5242880
net.ipv4.tcp_min_rtt_wlen <span class="o">=</span> 300
net.ipv4.tcp_min_snd_mss <span class="o">=</span> 48
net.ipv4.tcp_min_tso_segs <span class="o">=</span> 2
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_mtu_probe_floor <span class="o">=</span> 48
net.ipv4.tcp_mtu_probing <span class="o">=</span> 0
net.ipv4.tcp_no_metrics_save <span class="o">=</span> 1
net.ipv4.tcp_notsent_lowat <span class="o">=</span> 8388608
net.ipv4.tcp_orphan_retries <span class="o">=</span> 0

net.ipv4.tcp_pacing_ca_ratio <span class="o">=</span> 120
net.ipv4.tcp_pacing_ss_ratio <span class="o">=</span> 200
net.ipv4.tcp_probe_interval <span class="o">=</span> 600
net.ipv4.tcp_probe_threshold <span class="o">=</span> 8
net.ipv4.tcp_proc_sched <span class="o">=</span> 1
net.ipv4.tcp_recovery <span class="o">=</span> 1
net.ipv4.tcp_reordering <span class="o">=</span> 5
net.ipv4.tcp_retrans_collapse <span class="o">=</span> 1
net.ipv4.tcp_retries1 <span class="o">=</span> 5
net.ipv4.tcp_retries2 <span class="o">=</span> 15
net.ipv4.tcp_rfc1337 <span class="o">=</span> 0
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 16384000
net.ipv4.tcp_rto_max <span class="o">=</span> 120
net.ipv4.tcp_rto_min <span class="o">=</span> 200
net.ipv4.tcp_rx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_sack <span class="o">=</span> 1
net.ipv4.tcp_slow_start_after_idle <span class="o">=</span> 0
net.ipv4.tcp_stdurg <span class="o">=</span> 0
net.ipv4.tcp_syn_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_rto_interval <span class="o">=</span> 200

<span class="c"># 表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载</span>
net.ipv4.tcp_syncookies <span class="o">=</span> 1
net.ipv4.tcp_thin_linear_timeouts <span class="o">=</span> 0

<span class="c"># TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项</span>
net.ipv4.tcp_timestamps <span class="o">=</span> 1
net.ipv4.tcp_tso_win_divisor <span class="o">=</span> 3
net.ipv4.tcp_tw_ignore_syn_tsval_zero <span class="o">=</span> 1

<span class="c"># 表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 </span>
net.ipv4.tcp_tw_reuse <span class="o">=</span> 1
<span class="c"># 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡</span>
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30

<span class="c"># 能够更快地回收TIME-WAIT套接字</span>
net.ipv4.tcp_tw_recycle <span class="o">=</span> 1
net.ipv4.tcp_tw_timeout <span class="o">=</span> 60
net.ipv4.tcp_tx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_wan_timestamps <span class="o">=</span> 0
net.ipv4.tcp_window_scaling <span class="o">=</span> 1
net.ipv4.tcp_wmem <span class="o">=</span> 4096000     16384000        32768000
net.ipv4.tcp_workaround_signed_windows <span class="o">=</span> 0
</code></pre></div></div>

<h2 id="优化内容">优化内容</h2>

<blockquote>
  <p>以下均为仅优化单边的 Server 测参数。</p>
</blockquote>

<h3 id="bbr">BBR</h3>

<p>编辑 <code class="language-plaintext highlighter-rouge">/etc/sysctl.conf</code>，添加或修改如下参数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置 tcp 拥塞算法为 bbr</span>
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr

</code></pre></div></div>

<p>使参数立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-p</span>
</code></pre></div></div>

<p><strong>测试结果</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 300  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

436600 87380  100      3000000  300.00      1.06
436600 87380
</code></pre></div></div>

<p>可以看到在开启了 bbr 拥塞算法后，<code class="language-plaintext highlighter-rouge">Trans</code> 由 0.79 升到了 1.06，有了明显的提升。
但是实际优化数据不会这么明显，因为线上环境我们只能开启 server 测的 bbr，而无法控制 client 同时开启。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-a</span> | egrep <span class="s2">"rmem|wmem|adv_win|moderate"</span>
net.core.rmem_default <span class="o">=</span> 327680
net.core.rmem_max <span class="o">=</span> 327680
net.core.wmem_default <span class="o">=</span> 327680
net.core.wmem_max <span class="o">=</span> 3276800
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0
</code></pre></div></div>

<p><strong>测试结果对比</strong></p>

<ul>
  <li>上述默认配置，无调整 buffer</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.59
16384000 1048576
</code></pre></div></div>

<ul>
  <li>强制64KB buffer</li>
</ul>

<p>配置 net.ipv4.tcp_wmem 为 65536 后的测试结果 <code class="language-plaintext highlighter-rouge">sysctl -w net.ipv4.tcp_wmem="65536 65536 65536"</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.16
65535  1048576
</code></pre></div></div>

<p>可以看到之前配置了 64KB 的 send buffer 后，Trans 由 1.59 下降到了 1.16，有明显的下降，但是上述配置是将 min、default、max 均全部强行配置为 64KB，失去了动态伸缩的能力，如果仅配置 default 为 64KB，不限制最大值，则不受影响。</p>

<h2 id="结论">结论</h2>

<p>在目前环境中的内核配置中，对首开有明显影响的只有两个参数：1、BBR 的拥塞算法；2、TCP 的 send buffer 最大值要足够大。
暂无有其它对与直播场景首开有明显影响的参数。</p>

<h1 id="路由优化记录">路由优化记录</h1>

<p>直播片源选用 3.4Mbps 的码率，播放器选择 ffplay 进行拉取，在发送端（直播服务器）通过 tcpdump 抓包，对比查看发送 1MB 数据所耗费的时间线，这里是局域网环境，所以 lastmile 的带宽不是瓶颈。</p>

<p>Tcp 的 initcwnd 默认值为 10，倘若设置过大会造成对网络的冲击，根据经验选择<code class="language-plaintext highlighter-rouge">默认配置 10</code> 与 <code class="language-plaintext highlighter-rouge">40</code> 两者之间进行对比。</p>

<h2 id="环境准备-1">环境准备</h2>

<p>首先在发送端直播服务器上为指定网卡增加 100ms 的主动延迟，以放大数据影响，方便对比结果。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 增加 100ms 的固定延迟
$ sudo tc qdisc change dev eno1 root netem delay 100ms
  
# ping 验证
$ ping 100.100.32.108
PING 100.100.32.108 (100.100.32.108) 56(84) bytes of data.
64 bytes from 100.100.32.108: icmp_seq=1 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=2 ttl=63 time=103 ms
64 bytes from 100.100.32.108: icmp_seq=3 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=4 ttl=63 time=103 ms
^C
--- 100.100.32.108 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3003ms
rtt min/avg/max/mdev = 102.763/103.307/103.550/0.322 ms
</code></pre></div></div>

<h2 id="case1">Case1</h2>

<blockquote>
  <p>未修改 tcp initcwnd 的测试场景。</p>
</blockquote>

<ul>
  <li>在发送端（直播服务器）测抓包：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_10cwnd_100msdelay.pcap
</code></pre></div>    </div>
  </li>
  <li>在远端进行拉流（100.100.32.108）：</li>
</ul>

<p>  拉取播放 10秒左右即可。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffplay http://100.100.57.20:8080/ztest/A123.flv\?domain\=h3.xxx.com
</code></pre></div></div>

<ul>
  <li>Wireshark 分析：</li>
</ul>

<p>  可以看到如下截图，接收 1 * 10^6 即1MB的数据时大约耗时在 900ms。
<img src="/assets/img/blog/tcp_10cwnd_100ms.png" alt="TCP 10 INITCWND 分析图" /></p>

<h2 id="case2">Case2</h2>

<p>调整 initcwnd 为 40，通过 ip route 进行调整。</p>

<ul>
  <li>首先通过 <code class="language-plaintext highlighter-rouge">sudo ip route show</code> 进行查看：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 10
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 10
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 10
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>然后依次对各 route 进行配置：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip route change 100.100.56.254 dev eno1 scope link initcwnd 40
sudo ip route change via 100.100.56.254 dev eno1  initcwnd 40
sudo ip route change 100.100.56.0/23 dev eno1 proto static scope link  initcwnd 40
</code></pre></div></div>

<ul>
  <li>配置后如下：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 40
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 40
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 40
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>在发送端（直播服务器）测抓包</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_40cwnd_100msdelay.pcap
</code></pre></div></div>

<ul>
  <li>Wireshark 分析</li>
</ul>

<p>  可以看到 init cwnd 为 40 后，在 tcp 的慢启动状态发包变得很激进，接收端接收 1MB 的数据大约为 550ms，节省了大约 350ms，大约 3 个 rtt 的时间。
<img src="/assets/img/blog/tcp_40cwnd_100ms.png" alt="TCP 40 INITCWND 分析图" /></p>

<h2 id="结论-1">结论</h2>

<p>  如上，调整 INITCWND 为 40后，在秒开数据为 1MB 的场景中，大约可为秒开节省 3 个左右的 rtt 时间，下一步可以在线上进行初步的验证，可逐步放开该值为 20、30、40，在数据不断的优化的情况下降低调整风险，逐步实现优化。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><category term="Protocol" /><summary type="html"><![CDATA[当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。]]></summary></entry><entry><title type="html">Ubuntu24.04 配置静态 IP</title><link href="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html" rel="alternate" type="text/html" title="Ubuntu24.04 配置静态 IP" /><published>2025-01-08T00:00:00+00:00</published><updated>2025-01-08T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/ubuntu24.04-static-ip</id><content type="html" xml:base="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html"><![CDATA[<blockquote>
  <p>公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。</p>
</blockquote>

<blockquote>
  <p>如下所有操作均使用 <code class="language-plaintext highlighter-rouge">root</code> 权限。</p>
</blockquote>

<blockquote>
  <p>记录该过程主要是因为想当然的以为网关地址就是同网段的 .1，导致配置后网络不通，通过 <code class="language-plaintext highlighter-rouge">ip route</code> 查询后方可。</p>
</blockquote>

<h1 id="查看当前-ip">查看当前 IP</h1>

<p>系统默认开启 DHCP，自动获取 IP，且查看 IP 不再默认支持<code class="language-plaintext highlighter-rouge">ifconfig</code>命令，需要 <code class="language-plaintext highlighter-rouge">ip addr show</code>进行查看。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 2c:f0:5d:2b:11:31 brd ff:ff:ff:ff:ff:ff
    altname enp0s31f6
    inet 100.100.57.20/23 brd 100.100.57.255 scope global noprefixroute eno1
       valid_lft forever preferred_lft forever
</code></pre></div></div>

<p>可以看到自己的 IP 地址为<code class="language-plaintext highlighter-rouge">100.100.57.20</code>。</p>

<h1 id="配置静态-ip">配置静态 IP</h1>

<p>ubuntu 18 以后版本开始使用<code class="language-plaintext highlighter-rouge">netplan</code>配置网卡信息，查看当前系统目录<code class="language-plaintext highlighter-rouge">/etc/netplan/</code>下具体配置文件名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls /etc/netplan
$ 50-cloud-init.yaml
</code></pre></div></div>

<blockquote>
  <p>编辑前建议先进行备份。</p>
</blockquote>

<p><strong>默认配置：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        eno1:
            dhcp4: true
    version: 2
</code></pre></div></div>

<p><strong>查询路由</strong></p>

<p>通过<code class="language-plaintext highlighter-rouge">ip route</code>获取当前路由地址：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ip route
$ default via 100.100.56.254 dev eno1 proto static metric 100
$ default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
$ 100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
</code></pre></div></div>

<p>可以看到默认路由地址为<code class="language-plaintext highlighter-rouge">100.100.56.254</code>。</p>

<p><strong>配置文件</strong></p>

<p><code class="language-plaintext highlighter-rouge">vim /etc/netplan/50-cloud-init.yaml</code>进行编辑,最终内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    version: 2
    ethernets:
        eno1:
            dhcp4: no
            addresses:
             - 100.100.57.20/23
            routes:
              - to: default
                via: 100.100.56.254
            nameservers:
              addresses:
                - 8.8.8.8
                - 8.8.4.4
</code></pre></div></div>

<blockquote>
  <p>注意缩进的格式和位置，不能使用<code class="language-plaintext highlighter-rouge">tab</code>只能用空格进行缩进。</p>
</blockquote>

<p><strong>应用</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netplan apply
</code></pre></div></div>

<p>如果没有格式错误的话，便没有任何输出，否则提示格式错误。
至此配置成功，通过<code class="language-plaintext highlighter-rouge">ip addr show</code>查看确认。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。]]></summary></entry><entry><title type="html">webtransport-go 在直播场景下的优化</title><link href="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html" rel="alternate" type="text/html" title="webtransport-go 在直播场景下的优化" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-01-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream</id><content type="html" xml:base="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html"><![CDATA[<h1 id="背景">背景</h1>
<p>公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。</p>

<blockquote>
  <p>本人经历 2024年 11月变动以后，刚来公司不久，周边同事基本都以 golang 语言开发为主，且基本没有协议的优化经验，只能选择开源项目进行优化， B本人进入公司的时机也不好，该项目已经选定该方案，并且开始上线进行灰度测试，无法推翻重来。
且对比 Tcp 来看，webtransport-go 带来的性能消耗是 tcp 的 5 倍以上。</p>
</blockquote>

<h2 id="为什么不直接使用-quic-go">为什么不直接使用 quic-go</h2>

<p>因为 quic 虽然也是可靠传输，但是 quic 暂不支持通过 Url 来携带业务测参数，如：vhost、token 等的。</p>

<h1 id="初始化">初始化</h1>
<h2 id="代码下载">代码下载</h2>

<p><code class="language-plaintext highlighter-rouge">git clone git@github.com:quic-go/webtransport-go.git</code></p>

<p>拉取相关依赖仓库代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 进入代码目录
cd webtransport-go

# 通过 build 触发代码拉取
go build webtransport_test.go
</code></pre></div></div>

<p>Golang 默认将代码存放在<code class="language-plaintext highlighter-rouge">$GOPATH</code>目录下，我的<code class="language-plaintext highlighter-rouge">GOPATH</code>环境变量配置为 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go</code>，那么拉取的依赖仓库 <code class="language-plaintext highlighter-rouge">quic-go</code> 的存放目录就是 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1</code>，为了方便在 VSCode 中查看代码，在 VSCode 的 WorkSpace 空白处通过右键选择：<code class="language-plaintext highlighter-rouge">Add Folder to WorkSpace</code>，选择上述目录，即可一起查看 <code class="language-plaintext highlighter-rouge">quic-go</code> 相关的代码，如下：
<img src="/assets/img/blog/vscode-go.jpg" alt="" /></p>

<h2 id="quic-go">Quic-go</h2>

<p>Quic-go 作为 webtransport-go 的依赖仓库，提供 quic 的基础传输能力，但是其提供的传输配置能力非常有限，特别是作为发送端时，一些基础的 CWnd、Burst、Ack 等参数均不支持配置，接口文件为：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/interface.go</code></p>

<p>quic-go 内部相关参数主要位于：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/protocol.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/params.go</code></p>

<h1 id="优化项">优化项</h1>

<ul>
  <li>初始化发送包数：</li>
</ul>

<p>文件：<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code> 中指定
<code class="language-plaintext highlighter-rouge">const maxBurstSizePackets = 10</code>，在直播场景，I 帧切片后（1200Bytes/pkt）基本都会超过 10 片，建议配置为 20~30，具体视业务场景中首帧的切换大小，但也不宜过高，控制在 30 以内。
该配置项生效后对秒开的影响较小，属于毫秒级别，原来可能受 pacer 控制在几个 timerGraulariry 中将一个关键帧发送完，该配置的理想效果是减少这几个 timerGraulariry 的延迟。</p>

<ul>
  <li>握手超时时间：
应用层建议也是用 2 秒的配置。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const DefaultHandshakeIdleTimeout = 5 * time.Second
// 建议修改为 2 或者 3 秒，业务测可以快速重连，减少等待时间
const DefaultHandshakeIdleTimeout = 2 * time.Second
</code></pre></div></div>

<ul>
  <li>定时器精度</li>
</ul>

<p>最好是从系统中获取自己的定时器精度（一般是4ms），不建议使用 1 ms 这种精度，过于高频，无效的 cpu 消耗。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const TimerGranularity = time.Millisecond
// 建议值：动态获取系统定时器精度，或者 hardcode 为 4ms 或者 10ms
const TimerGranularity = 4 * time.Millisecond
</code></pre></div></div>

<ul>
  <li>转发模式</li>
</ul>

<p>目前业务集成方在回源时，虽然传输协议使用的是流式传输，但是边缘节点在接收到分片数据后并不会立即进行转发，而是在组装成一个完整的帧以后再一次性进行发送，这样做是为了内部各种封装格式的转换，但是也存在明显的弊端，即在没有收到完整的关键帧以前，不会向 Player 发送任何数据，被回源的关键帧阻塞，间接的增加了首开的延迟。</p>

<p>可优化选项：比如回源的协议与 Player 请求的协议相同，即均为 HTTP-FLV，那么便不再需要进行完整帧的转封装，而直接进行分片的透明转发，同时边缘节点也异步的 cache 分片数据进行组帧操作，转封装分发给其它请求的协议。</p>

<h1 id="faq">FAQ</h1>

<h2 id="webtransport-是否是整帧的收发">Webtransport 是否是整帧的收发？</h2>

<p>不是，websocket 在发送大的数据帧时，会通过 FIN 标记位是否为 1 标记为该 Frame 是否结束，而 WebTransport 中是基于流的传输，需要应用层自行组装完整的数据帧。
<a href="https://www.ietf.org/archive/id/draft-ietf-webtrans-overview-05.html#name-conventions-and-definitions-8">ref link</a></p>

<blockquote>
  <p>A stream is a sequence of bytes that is reliably delivered to the receiving application in the same order as it was transmitted by the sender. Streams can be of arbitrary length, and therefore cannot always be buffered entirely in memory. WebTransport protocols and APIs are expected to provide partial stream data to the application before the stream has been entirely received.</p>
</blockquote>

<h2 id="bbr-sender-配置-startup-的较大带宽但是-max-burst-send-packets-number-却较小能将关键帧的几个切片一次性发送出去吗">BBR sender 配置 startup 的较大带宽，但是 max burst send packets number 却较小，能将关键帧的几个切片一次性发送出去吗？</h2>

<p><code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        p := &amp;pacer{
                maxDatagramSize: initialMaxDatagramSize,
                adjustedBandwidth: func() uint64 {
                        // Bandwidth is in bits/s. We need the value in bytes/s.
                        bw := uint64(getBandwidth() / BytesPerSecond)
                        // Use a slightly higher value than the actual measured bandwidth.
                        // RTT variations then won't result in under-utilization of the congestion window.
                        // Ultimately, this will result in sending packets as acknowledgments are received rather than when timers fire,
                        // provided the congestion window is fully utilized and acknowledgments arrive at regular intervals.
                        return bw * 5 / 4
                },
        }
        p.budgetAtLastSent = p.maxBurstSize()
        return p
}
</code></pre></div></div>

<p>而在初始化时，由于没有 smoothedRTT 的有效值，所以初始化为 <code class="language-plaintext highlighter-rouge">infBandwidth</code> (UINT64_MAX)，
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/bbr_sender.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (b *bbrSender) bandwidthEstimate() Bandwidth {
        srtt := b.rttStats.SmoothedRTT()
        if srtt == 0 {
                // If we haven't measured an rtt, the bandwidth estimate is unknown.
                return infBandwidth
        }
        bw := b.maxBandwidth.GetBest()
        if bw == 0 {
                return infBandwidth
        }
        return bw
}
</code></pre></div></div>

<p>虽然初始化的 bandwidth 比较大，但是 pacer 在发送数据时依然会受限于 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 的配置，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *pacer) maxBurstSize() protocol.ByteCount {
        return utils.Max(
                protocol.ByteCount(uint64((protocol.MinPacingDelay+protocol.TimerGranularity).Nanoseconds())*p.adjustedBandwidth())/1e9,
                maxBurstSizePackets*p.maxDatagramSize,
        )
}
</code></pre></div></div>

<p>所以建议将 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 值配置为 20 ～ 30 之间，根据业务场景，尽量让首帧（I Frame）的所有切片能够一次性发送出去，但是也不宜过高，避免数据突发导致网络拥塞丢包。</p>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><summary type="html"><![CDATA[背景 公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。]]></summary></entry><entry><title type="html">移植裁剪 srs 到 ARMv64 系统设备</title><link href="https://gbcpp.github.io/notes/srs-on-arm.html" rel="alternate" type="text/html" title="移植裁剪 srs 到 ARMv64 系统设备" /><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/srs-on-arm</id><content type="html" xml:base="https://gbcpp.github.io/notes/srs-on-arm.html"><![CDATA[<h1 id="srs-版本">SRS 版本</h1>

<p>srs 源码选择较新的 stable 版本：v5.0-r3</p>

<p><strong>代码拉取</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --branch v5.0-r3 https://github.com/ossrs/srs.git
</code></pre></div></div>

<p><strong>编译</strong></p>

<p>已知设备系统：ARMv8 指令集架构的 Debian，此次测试选择在 Debian 系统下部署 srs 服务进行测试。</p>

<p>使用 docker 进行编译，首先保证开发机上有 docker 服务，编译命令会自行拉取 aarch64 专用编译镜像并编译：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd srs/trunk
$ docker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \
    bash -c "./configure --srt=off --rtc=off --ffmpeg-fit=off --static=on \
        --sanitizer=off --sanitizer-static=off --sanitizer-log=off &amp;&amp; make -j4"
 

# 查看 srs 二进制文件
$ ls -sh objs/srs
</code></pre></div></div>

<h1 id="测试环境">测试环境</h1>

<p>基于当前测试条件，此次测试选择将 srs 服务部署在 Debian 系统的小盒子中进行测试。</p>

<p>Debian 系统小盒子性能如下：</p>
<ul>
  <li>CPU：4 核 4 线程，主频 1.5GHz</li>
  <li>Mem：2GB</li>
  <li>Disk：8GB</li>
</ul>

<p>观众端：</p>

<p>Mac 下 Shell 脚本启动 10 路 ffplay 进行播放，启动命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash repeat_command.sh "ffplay https://ossrs.com:8088/live/livestream.flv"  10
</code></pre></div></div>

<p>repeat_command.sh 脚本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
 
if [ $# -lt 2 ]; then
    echo "Usage: $0 &lt;command&gt; &lt;times&gt;"
    exit 1
fi
 
# 获取参数
command=$1
times=$2
 
# 检查 times 是否是数字
if ! [[ $times =~ ^[0-9]+$ ]]; then
    echo "Error: &lt;times&gt; must be a positive integer."
    exit 1
fi
 
# 循环执行命令
for ((i=1; i&lt;=times; i++)); do
    echo "Executing command '$command' in the background: iteration $i"
    eval "$command &amp;"
done
 
echo "All commands have been executed in the background."
</code></pre></div></div>

<h1 id="srs-配置">SRS 配置</h1>

<p>使用了自签名证书 ossrs.com</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen              1935;
max_connections     1000;
daemon              off;
srs_log_tank        console;
 
http_api {
    enabled         on;
    listen          1985;
}
 
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
 
    https {
        enabled on;
        listen 8088;
        key ./ossrs.key;
        cert ./ossrs.crt;
    }
}
vhost __defaultVhost__ {
    http_remux {
        enabled     on;
        mount       [vhost]/[app]/[stream].flv;
    }
    ingest livestream {
        enabled      on;
        input {
            type    stream;
        url     http://100.100.34.14:8080/live/livestream.flv;
        }
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled          off;
            output          rtmp://0.0.0.0:[port]/live/livestream?vhost=[vhost];
        }
    }
}
</code></pre></div></div>

<h1 id="测试结果">测试结果</h1>

<p>测试条件有限，目前仅测试了如下两种场景和数据，仅供参考。</p>

<p>测试场景：为该 SRS 注入一路 stream 做为源，然后远端从该 SRS 通过 HTTPS-FLV 拉取十路该流。</p>

<p><img src="/assets/img/blog/srs_perf.jpg" alt="" /></p>

<h1 id="srs-支持sni和多证书">SRS 支持SNI和多证书</h1>

<p>目前 srs 仅支持单个 HTTPS Server 的部署，需要自行扩展支持 SNI 的读取、选择指定证书下发的实现，TLS 封装代码在 SrsHttpxConn 类中。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[SRS 版本]]></summary></entry><entry><title type="html">C++ 程序输出当前堆栈</title><link href="https://gbcpp.github.io/notes/print_stacktrace.html" rel="alternate" type="text/html" title="C++ 程序输出当前堆栈" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/print_stacktrace</id><content type="html" xml:base="https://gbcpp.github.io/notes/print_stacktrace.html"><![CDATA[<p>将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。
互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。</p>

<h2 id="头文件">头文件</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h2 id="源码">源码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Utils</span><span class="o">::</span><span class="n">PrintStackTrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxFrames</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxPrettyFunctionNameLength</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">[</span><span class="n">kMaxFrames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 获取当前堆栈中的地址</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrlist</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"StackTraces: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// 解析地址为函数名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">symbollist</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

  <span class="c1">// 解析函数名的更多信息</span>
  <span class="kt">size_t</span> <span class="n">funcNameSize</span> <span class="o">=</span> <span class="n">kMaxPrettyFunctionNameLength</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">funcNameSize</span><span class="p">));</span>

  <span class="c1">// 跳过第一个元素（即本身）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 解析符号名称及偏移量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginName</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beginName</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span> <span class="o">&amp;&amp;</span> <span class="n">endOffset</span> <span class="o">&amp;&amp;</span> <span class="n">beginName</span> <span class="o">&lt;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">beginName</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">beginOffset</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

      <span class="c1">// 解码并打印函数名称</span>
      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span>
          <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">beginName</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funcNameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果无法解析，直接输出原始符号信息</span>
      <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">funcName</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">symbollist</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="编译">编译</h2>

<p><code class="language-plaintext highlighter-rouge">ldflags</code> 参数一定要指定 <code class="language-plaintext highlighter-rouge">-ldynamiclib</code> 告诉链接器将所有符号添加到动态符号表中。这使得运行时调试工具（如 GDB）和运行时函数（如 backtrace）可以访问这些符号。
主要用于调试和诊断目的，以便在运行时能够获取更详细的堆栈信息和符号解析。</p>

<p>对性能几乎没有影响，但是由于增加了符号表信息，会增加包体大小。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。 互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。]]></summary></entry><entry><title type="html">温故而知新之-C++</title><link href="https://gbcpp.github.io/notes/learning-cpp-notes.html" rel="alternate" type="text/html" title="温故而知新之-C++" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/learning-cpp-notes</id><content type="html" xml:base="https://gbcpp.github.io/notes/learning-cpp-notes.html"><![CDATA[<h2 id="指针的退化及如何避免">指针的退化及如何避免</h2>

<p>在C++中，”指针退化”是指当数组作为函数参数传递时，它会”退化”为指向第一个元素的指针。这是因为在C++中，数组并不知道它们自己的大小，所以当你把一个数组作为参数传递给一个函数时，函数并不知道这个数组的大小，只知道它的起始地址。</p>

<p>例如，假设你有一个函数<code class="language-plaintext highlighter-rouge">void foo(int arr[])</code>，当你传递一个数组给这个函数时，例如<code class="language-plaintext highlighter-rouge">int arr[10]; foo(arr);</code>，函数<code class="language-plaintext highlighter-rouge">foo</code>实际上看到的是一个指向<code class="language-plaintext highlighter-rouge">arr</code>的第一个元素的指针，而不是整个数组。</p>

<p>要防止指针退化，有几种方法：</p>

<ol>
  <li>
    <p>使用标准库容器，如<code class="language-plaintext highlighter-rouge">std::vector</code>或<code class="language-plaintext highlighter-rouge">std::array</code>。这些容器知道它们自己的大小，因此不会发生指针退化。例如： <code class="language-plaintext highlighter-rouge">void foo(std::vector&lt;int&gt;&amp; arr)</code>。</p>
  </li>
  <li>
    <p>使用模板函数，使函数可以接受数组的引用，并且能够保留数组的大小信息。例如： <code class="language-plaintext highlighter-rouge">template&lt;size_t N&gt; void foo(int (&amp;arr)[N])</code>。</p>
  </li>
  <li>
    <p>传递数组的大小作为另一个参数。例如： <code class="language-plaintext highlighter-rouge">void foo(int* arr, size_t size)</code>。这样，即使数组退化为指针，函数仍然可以知道数组的大小。</p>
  </li>
</ol>

<h2 id="引用与指针的区别">引用与指针的区别</h2>

<p>在C++中，指针和引用都可以用于间接引用其他对象。然而，它们在语法和行为上有一些关键的不同：</p>

<ol>
  <li>
    <p>初始化：引用在创建时需要初始化，并且一旦初始化后就不能改变引用的目标，也就是说它始终引用最初赋给它的对象。而指针可以在任何时间指向任何对象或者NULL。</p>
  </li>
  <li>
    <p>空值：指针可以为NULL，表示它不指向任何对象。而引用必须始终引用一个有效的对象，不能有NULL引用。</p>
  </li>
  <li>
    <p>间接访问：使用指针时，需要使用解引用运算符(*)来访问它指向的对象，而引用则可以像普通变量那样直接使用。</p>
  </li>
  <li>
    <p>支持的操作：指针支持更多的操作，例如指针算术（即增加或减少指针的值，以指向内存中的不同位置）。引用则不能进行这种操作。</p>
  </li>
  <li>
    <p>内存占用：引用实际上并不占用任何内存，它只是一个别名。而指针是一个实际的变量，它占用内存空间并存储一个地址值。</p>
    <blockquote>
      <p>但引用在程序中并不是不占用任何字节，引用本质上就是一个常量指针（constant pointer）。它在内存中占据的空间和指针一样，通常是 4 字节（在 32 位系统）或 8 字节（在 64 位系统）。然而，引用本身并不存储任何值，它只是一个别名，代表它引用的对象。在某些优化的情况下，如果引用没有被用作一个对象的别名（也就是说，它被直接用于访问该对象），编译器可能会优化掉引用，使其不占用任何内存空间。但是，这种优化并不是在所有情况下都会发生。所以，说引用不占用内存空间并不完全准确，实际情况取决于编译器的优化和引用的使用方式。</p>
    </blockquote>
  </li>
</ol>

<p>总的来说，引用在某些情况下可以提供更简洁的语法，而指针则提供了更大的灵活性和控制能力。选择使用哪一个取决于具体的编程需求。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[指针的退化及如何避免]]></summary></entry><entry><title type="html">面向学习的三种人</title><link href="https://gbcpp.github.io/notes/learning-oriented.html" rel="alternate" type="text/html" title="面向学习的三种人" /><published>2024-04-02T00:00:00+00:00</published><updated>2024-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/learning-oriented</id><content type="html" xml:base="https://gbcpp.github.io/notes/learning-oriented.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者</p>
</blockquote>

<h2 id="1-犯人">1. 犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="2-过客">2. 过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="3-探索者">3. 探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者]]></summary></entry><entry><title type="html">基于 HTTP/3 的 WebTransport</title><link href="https://gbcpp.github.io/protocol/WebTransport.html" rel="alternate" type="text/html" title="基于 HTTP/3 的 WebTransport" /><published>2024-02-01T00:00:00+00:00</published><updated>2024-02-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/WebTransport</id><content type="html" xml:base="https://gbcpp.github.io/protocol/WebTransport.html"><![CDATA[<blockquote>
  <p>本文主要翻译自https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3 ，如有错误请指正。</p>
</blockquote>

<h1 id="摘要">摘要</h1>

<p>WebTransport 是一个协议框架，它强迫客户端受 web 安全模型去与远程服务器进行安全的多路传输；
WebTransport 是一个受 Web 安全模型约束的多路复用安全传输协议，本文将描述一个 WebTransport 协议基于 HTTP3 并提供单向流、双向流和数据报，并全部复用同一个相同的 HTTP3 链接；</p>

<!--more-->

<h1 id="现状">现状</h1>

<p>这是一份 Internet 标准跟踪文档。
本文是  Internet Engineering Task Force（IETF）的产品，它代表了 IETF 社区已达成的共识，它已经经历了公开的审阅并已被 Internet Engineering Steering Group (IESG) 批准出版；更多信息可以参考 <a href="!https://datatracker.ietf.org/doc/html/rfc7841#section-2">Section 2 of RFC 7841</a>。</p>

<h1 id="介绍">介绍</h1>

<p>HTTP3 是在 QUIC [QUIC-TRANSPORT] 之上可以通过 QUIC 链接多路复用 HTTP 请求的协议。本文档定义了一种通过 HTTP3 实现 WebTransport 协议的要求，以实现多路复用 non-HTTP 数据的机制。多个 WebTransport 实例可以同时复用在同一个 HTTP3 链接上进行常规的 HTTP 数据传输。</p>

<h1 id="协议概述">协议概述</h1>

<p>WebTransport Server 通常由一对权限值和录制值来标识  (defined in [RFC3986] Sections 3.2 and 3.3   correspondingly)。
当一个 HTTP3 连接后，Client 和 Server 端都必须发送一个 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 配置以表明它们都支持基于 HTTP3 的 WebTransport。WebTransport 会话由 Client 在给定的 HTTP3 连接内发起，即由 Client 发送一个扩展的 CONNECT 请求，如果 Server 接受该请求，则一个 WebTransport session 便建立了；生成的 stream 将被进一步称为  <em>CONNECT stream</em>，其 stream ID 用于唯一标识当前给定链接内的 WebTransport session。在给定的 WebTransport session 上建立的 CONNECT stream 的 ID 将被进一步称为 <em>Session ID</em>。</p>

<p>会话建立后，双方便可以使用以下机制交换数据：</p>

<ul>
  <li>Client 可以创建一个由特殊的不限制长度的 HTTP3 frame 组成的双向流（bidirectional stream），然后转移该流的所有权给 WebTransport；</li>
  <li>Server 也可以创建一个 bidirectional stream，因为 HTTP3 没有为 Server 端创建 bidirectional stream 定义任何语义（言外之意：不禁止便是允许）；</li>
  <li>Client 和 Server 都可以创建单向流类型（unidirectional stream）；</li>
  <li>可以通过 QUIC DATAGRAM 帧发送数据包 datagram；<a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-DATAGRAM">QUIC-DATAGRAM</a></li>
</ul>

<p>当创建的 CONNECT stream 关闭时，WebTransport 会话也即终止。</p>

<h1 id="会话建立">会话建立</h1>

<h2 id="建立支持传输的-http3-链接">建立支持传输的 HTTP3 链接</h2>

<p>Client 和 Server 必须均在它们的设置框架中发送一个为 <code class="language-plaintext highlighter-rouge">1</code> 的值。终端不能使用任何 WebTransport 的任何功能，除非它们已经协商各种参数。
如果协商了 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 参数，则在协商 HTTP3 中 QUIC DATAGRAMS 时，必须按照 <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3-DATAGRAM">HTTP3-DATAGRAM</a> 进行协商；否则在协商 WebTransport 时如果没有 QUIC DATAGRAM 扩展，将导致 H3_SETTINGS_ERROR。
HTTP3 要求 Client 的 <code class="language-plaintext highlighter-rouge">initial_max_bidi_streams</code> 传输参数设置为 <code class="language-plaintext highlighter-rouge">0</code>。当前的实现是在协商时强制执行这个规定；因此，在 client 发起 bidirectional streams 时，需发送一个非零的 <code class="language-plaintext highlighter-rouge">MAX_STREAMS</code> 。</p>

<h2 id="http3-扩展方法-connect">HTTP3 扩展方法 CONNECT</h2>

<p>RFC8441 在第 4 节中定义了一个扩展方法 <code class="language-plaintext highlighter-rouge">CONNECT</code>，可以通过 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_CONNECT_PROTOCOL</code> 参数激活，该参数是为 HTTP2 定义的，但是该协议不会在 HTTP3 中为 <code class="language-plaintext highlighter-rouge">CONNECT</code> 创建更多的扩展含义；因为 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 配置已经代表了终端支持扩展的 <code class="language-plaintext highlighter-rouge">CONNECT</code>。</p>

<h2 id="创建会话">创建会话</h2>

<p>由于 WebTransport 会话是通过 HTTP3 建立的，所以它们使用 <code class="language-plaintext highlighter-rouge">https</code> URI 规则 <a href="!https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a> 。
为了创建一个 WebTransport 会话，client 可以发送一个 HTTP CONNNECT 请求，其 <code class="language-plaintext highlighter-rouge">:protocol</code> 伪-头域 <a href="!https://datatracker.ietf.org/doc/html/rfc8441">RFC8441</a> 字段必须设置为 <code class="language-plaintext highlighter-rouge">webtransport</code>，<code class="language-plaintext highlighter-rouge">:scheme</code> 字段必须设置为 <code class="language-plaintext highlighter-rouge">https</code>, 同时 <code class="language-plaintext highlighter-rouge">:authorith</code>和 <code class="language-plaintext highlighter-rouge">:path</code> 必须配置，这些字段标识这是一个 WebTransport 服务；一个 <code class="language-plaintext highlighter-rouge">Origin</code> header 必须包含在这个请求中。</p>

<p>在收到一个 <code class="language-plaintext highlighter-rouge">:protocol</code> 字段设置为 <code class="language-plaintext highlighter-rouge">webtransport</code> 的 CONNECT 扩展请求时，HTTP3 服务器可以检查自己是否包含该请求中指定的 <code class="language-plaintext highlighter-rouge">:authorith</code> 和 <code class="language-plaintext highlighter-rouge">:path</code> 配置的 WebTransport 服务，如果没有，它应该返回状态码 404；如果有，它可以通过回复状态码 200 标识接受会话请求。WebTransport server 必须验证 <code class="language-plaintext highlighter-rouge">Origin</code> header 以确保指定 origin 是可以被访问的。</p>

<p>从客户端的角度看，一个 WebTransport 会话建立的标识是 client 收到了 server 的 200 响应；
从服务端的角度来看，一旦发送了 200 响应，就算是建了会话，两端都不能在会话建立之前打开任何 streams 或者发送任何的 datagrams。</p>

<p><strong>基于 HTTP3 的 WebTransport 不支持 0-RTT。</strong></p>

<h2 id="限制同时会话的数量">限制同时会话的数量</h2>

<p>从流控的角度来看，WebTransport 会话数量针对stream 的流控就像常规的 HTTP 请求一样（通过 HTTP CONNECT 请求建立连接）。本协议没有引入新的，单独的流控机制，也不将 HTTP 请求与  WebTransport 会话分离，如果服务器需要限制接收请求的速率，它可以使用其它的机制：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">HTTP_REQUEST_REJECTED</code> error code 定义在 <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3">HTTP3</a> 标识未处理的请求的 HTTP3 堆栈；</p>
  </li>
  <li>
    <p>HTTP 状态码 429 表示达到了服务器的速率控制，请求被拒绝 <a href="!https://datatracker.ietf.org/doc/html/rfc6585">RFC6585</a>；与上一个方法不一样，它直接将这个信号通知给发起的请求的应用程序；</p>
  </li>
</ul>

<h1 id="webtransport-功能列表">WebTransport 功能列表</h1>

<p>WebTransport over HTTP3 提供了以下功能特性：</p>

<ul>
  <li>单向流 unidirectional streams</li>
  <li>双向流 bidirectional streams</li>
  <li>数据包 datagrams</li>
</ul>

<p>以上功能均可由任意一端发起。
Session ID 可用于解复用 Streams 和 Datagrams 以判断属于不同的 WebTransport session，在网络中，session IDs 使用的是 QUIC 可变长度整数方案编码的  <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-TRANSPORT">QUIC-TRANSPORT</a>。</p>

<h2 id="unidirectional-streams">Unidirectional streams</h2>

<p>WebTransport 连接一旦建立，两端均可以打开 Unidirectional streams。HTTP3 unidirectional stream type 应为 0x54，整个包体结构依次是 stream type [0x54]、Session ID、已编码的可变整数类型的长度信息、用户指定的流数据，如下：</p>

<p><strong>Unidirectional WebTransport stream format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           0x54 (i)                          ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="客户端发起的-birectional-streams">客户端发起的 Birectional Streams</h2>

<p>WebTransport 客户端可以通过打开一个 HTTP3 双向流并发送一个帧类型为 <code class="language-plaintext highlighter-rouge">WEBTRANSPORT_STREAM</code> (type=0x41) 的 HTTP3 frame 以初始化一个 WebTransport 的双向流。帧的格式为：frame type、Session ID、已编码可变数据长度、用户数据；
数据帧应该持续到流结束。</p>

<p><strong>WEBTRANSPORT_STREAM frame format:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           0x41 (i)                          ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="服务端发起的-bidirectional-streams">服务端发起的 Bidirectional Streams</h2>

<p>WebTransport 服务端可以通过打开一个 HTTP3 双向流初始化 Bidirectional Stream。请注意：由于 HTTP3 没有为服务器启动定义任何的 Bidirectional Strream 的相关语义，本协议中此类流适用于所有的 HTTP3 连接，前提是 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 选项已经协商过了。这些流的格式如下：</p>

<p><strong>*Server-initiated bidirectional stream format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="数据包-datagrams">数据包 Datagrams</h2>

<p>Datagrams 可以发送   <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-DATAGRAM">QUIC-DATAGRAM</a> and <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3-DATAGRAM">HTTP3-DATAGRAM</a> 定义的 DATAGRAM frame，前提是 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 已协商，流标识符（Flow Identifier）被设置为 session ID，格式如下：</p>

<p><strong>Datagram format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Datagram Body                        ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<p>在 QUIC 中，一个 Datagram 帧最多可以跨越一个数据包中，因为于此，应用程序必须知道可以发送的最大1数据报大小；然而当代理数据报时，逐跳的 MTU 可能并不相同。</p>

<h1 id="会话终止">会话终止</h1>

<p>任何一方都可以通过关闭起初通过发送 CONNECT 请求建立起来的流来关闭当前  WebTransport 会话；在得知会话正在终止时，断点必须停止发送新的 datagrams 并且重置所有与此 session 相关联的 sterams。</p>

<h1 id="安全注意事项">安全注意事项</h1>

<p>WebTransport over HTTP3 满足所有对 WebTransport 协议施加的所有安全要求，由于 Client 有可能不被信任，所以提供了一个client-server 通信的安全框架。
WebTransport over HTTP3 需要基于 QUIC 传输参数，这样可以通过 HTTP3 server 的支持来避免潜在的协议混淆带来的攻击；它还需要使用 Origin header，为服务器提供拒绝访问非源自于 Web 客户端的不被信任的 origin。</p>

<p>就像通过 HTTP3 传输的 HTTP 流量一样，WebTransport 流量汇集不同的来源到同一个链接中，不同的源代表不同的信任域，意味着需要在同一个链接上应对不同的潜在的攻击，一种潜在的攻击是耗尽所有资源，因为所有的传输共享拥塞控制和流量控制，单个客户端大量使用这些资源可能会导致其它传输被终止。所以用户代理应该实施一个公平的方案，以确保链接内的每个传输可以获得可控的合理资源份额，这适用于数据发送和创建新流操作。</p>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><summary type="html"><![CDATA[本文主要翻译自https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3 ，如有错误请指正。]]></summary></entry></feed>