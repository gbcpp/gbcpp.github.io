<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2023-10-05T20:59:53+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">仲儿的自留地</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">图片处理及上传命令行工具 —— PICTL</title><link href="https://lisz.me/tech/project/pictl.html" rel="alternate" type="text/html" title="图片处理及上传命令行工具 —— PICTL" /><published>2023-06-13T13:41:01+09:00</published><updated>2023-06-13T13:41:01+09:00</updated><id>https://lisz.me/tech/project/pictl</id><content type="html" xml:base="https://lisz.me/tech/project/pictl.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  自从博客从 WordPress 转到静态博客（先 Hexo 后 Jekyll）之后，文章的图片处理、图片上传就成了一个不大顺畅的事情。最先是使用了 <a href="https://vgy.me">vgy.me</a> 提供的免费图床，支持直接从剪切板上传，操作上相对比较简单，也不需要任何本地存储。不过后来 vgy.me 进行了升级改版，原先的剪切板上传功能也不再支持了，偶尔还出现图片像素被降低、丢失的问题。同时，考虑到 WebP 格式可能会适合博客使用，而 vgy.me 还不支持该格式。于是开始切换到 “对象存储 + CDN” 的方案。本地准备好的 PNG 格式图片，先通过 <a href="https://developers.google.com/speed/webp/">cwebp</a> 命令行转成 WebP 格式图片，再通过 <a href="https://github.com/gee1k/uPic">uPic</a> 工具修改文件名后上传到对象存储。由于此前采用的是腾讯云的 COS 对象存储和 CDN，经常面临着 SSL 证书更新等琐碎的事情。这样一来，整体的效率实际上并不高，只能说勉强接受。</p>

<h3 id="现有工具及存储考察">现有工具及存储考察</h3>

<p>  为此，也对其他工具和对象存储进行了考察。</p>

<p>  <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款集客户端 UI 和命令行于一体的图片上传工具，虽然可以利用命令串联的方式简单将图片格式转换和上传两步变成一步，但还是有那么点不舒服的地方，比如 PicGo 不提供文件名修改（为固定长度随机字符串）的特性。而 uPic 本身关注于客户端桌面交互，不提供命令行接口。</p>

<p>  至于对象存储，国内各家云服务厂商提供的都需要自行手动更新 SSL 证书，且收费。尽管腾讯云 CDN 目前老用户可以每月领券免费使用，但一旦忘记就开始被收费了。实际上也有逐步转向收费的趋势。国外各家云服务厂商基本上都需要收费使用对象存储或者 CDN，大差不差。</p>

<p>  当然，网上一直有一种 “Backblaze B2 + Cloudflare” 的解决方案。由于 B2 本身存储和读写操作都有免费额度，流量需要收费，且无法自定义域名，而 B2 和 Cloudflare 同属于宽带联盟（内部流量免费），Cloudflare 还提供 URL 重写功能，这种解决方案一时成为了潮流。不过，B2 的访问链接是中间带着一串参数，重写之后仍然还是有部分参数，最终的 URL 并不是那么朴素。总的来说，还是有那么点别扭。</p>

<h3 id="r2-的出现">R2 的出现</h3>

<p>  因此观望了许久，直到 Cloudflare 推出了 R2。R2 是一款对标 AWS S3 的产品，基于 Cloudflare 对宽带联盟的承诺而构建，为存储对象提供零成本出口，实际上就是免费 CDN。由于 Cloudflare 本身就是一家 CDN 服务商，自定义对象存储访问域名、自动生成部署 SSL 证书这些事情就变得轻而易举了。R2 提供 10GB 的免费存储，读操作每月免费 1000 万次，写、更新和删除操作每月免费 100 万次。这对于一般的静态博客来说，应该完全足够了，即使超出了免费额度，超出部分收费也相较其他云服务厂商便宜一些。</p>

<p>  对笔者而言，R2 产品将对象存储和 CDN 两款产品有机地结合起来，解决了静态博客图片对外访问前的“最后一公里”。于是想从 COS 迁移到 R2，无奈 uPic 这个时候卖了个“破绽”。uPic 似乎在开始转向商业收费，Github 上不再发布新版本，而仅在 Appstore 上继续更新对 R2 的支持。当然，Appstore 上的 uPic 是收费的（4.99 美元，其实也不贵）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  R2 虽然说是对标 AWS S3，但是并没有完整实现所有 API 接口，所以目前 Github 上发布的 uPic 版本无法兼容。尽管可以自行通过修改 uPic 的开源代码来实现兼容，但毕竟修改别人的代码的成本还是有一点高的。</p>



 </div> </div>
<h2 id="开个新项目">开个新项目</h2>

<p>  在充分梳理个人使用需求之后，还是决定开个新项目——开发一款简单易用的命令行工具 PICTL（全称 <strong>Pi</strong>cture <strong>C</strong>on<strong>t</strong>ro<strong>l</strong>）。该工具须具备以下特性：</p>

<ul>
  <li>考虑图片的存储空间大小和网页加载时长，所有图片应被压缩并转成 WebP 格式；</li>
  <li>所有图片的名称应被修改成一个固定长度随机字符串，并支持上传到类 S3 的对象存储；</li>
  <li>简单易用，命令行优先，无网页或桌面交互界面；</li>
  <li>（可选）自动添加水印；</li>
  <li>（可选）根据设定自动调整图片尺寸；</li>
  <li>（可选）可以直接从剪切板读取图片。</li>
</ul>

<h2 id="架构设计">架构设计</h2>

<p>  根据所列出的特性，这款命令行工具主要的模块就是：<strong>图片处理模块</strong>和<strong>上传模块</strong>，架构如下图所示。</p>

<p><img src="https://i.lisz.top/blog/Gl8qhI.webp" alt="PICTL 架构图 The architecture of PICTL" /></p>

<p>  图片处理模块包括图片压缩、图片格式转换、图片水印、尺寸调整等功能，可以进行无缝横向扩展。上传模块主要包括对于三种存储方式的支持：<strong>第一类</strong>是最为广泛的类 S3 对象存储，如 R2、AWS S3 及国内外云服务厂商各种对象存储等，<strong>第二类</strong>是目前仍然在博客中广泛流行的第三方图床，如 <a href="https://sm.ms">SM.MS</a>、<a href="https://vgy.me">vgy.me</a>、<a href="https://github.com/chevereto/chevereto">chevereto</a> 类型图床等，<strong>第三类</strong>是自托管 Git 平台和 FTP 平台。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 特此声明 </div> </div> <div class="content"> <p>  鉴于 Github、Gitlab、Gitee 等公共代码托管平台均禁止把 Git 仓库作为图床的做法，本工具仅支持自建 Git 平台，如自建 Gitlab 和 Gitlab Pages。如试图上传到公共代码托管平台，本工具会自行中断上传。</p>



 </div> </div>
<p>  本工具由于仅支持命令行，所以计划用 Python 和 <a href="https://click.palletsprojects.com/">Click</a> 进行开发。虽然借助 <a href="https://google.github.io/python-fire/">Google Fire</a> 也可以快速开发命令行工具，但其使用方式上与原生 *nix 的命令行工具有所不同。相比之下，用 Click 开发可能会麻烦一点，但能够开发出更类原生的 Python 命令行工具。当然，目前开发上还是比较喜欢使用 Rust 或者 Go 语言来开发高性能的命令行工具。不过，本工具只是做一些非常简单的工作，没有性能上的瓶颈，用 Python 开发也足够了。</p>

<h2 id="开发计划">开发计划</h2>

<p>  请移步 <a href="https://github.com/users/zhonger/projects/5">Github Project</a> 了解更多。</p>

<h2 id="使用方法">使用方法</h2>

<p>  目前，PICTL 已经在 <a href="https://github.com/zhonger/pictl/releases">Github</a> 和 <a href="https://pypi.org/project/pictl/">PyPI</a> 同步发布了 v0.1.0 版本。该版本实现了以上架构图中的基本功能，即特性中的前三点必要项。接下来介绍一下如何安装和使用本工具。</p>

<h3 id="安装">安装</h3>

<p>  目前支持两种安装方式：<strong>源码安装</strong>和 <strong>PIP 安装</strong>，后续将增加对于 brew 的支持。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  安装前，请务必确保已满足 Python 版本高于 3.10 的条件。</p>



 </div> </div>
<h4 id="源码安装">源码安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/zhonger/pictl
<span class="nb">cd </span>pictl
pip3 <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<h4 id="pip-安装">PIP 安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>pictl
</code></pre></div></div>

<h3 id="使用">使用</h3>

<h4 id="显示版本">显示版本</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl <span class="nt">-V</span>
PICTL 0.1.0
</code></pre></div></div>

<h4 id="列举所有支持命令">列举所有支持命令</h4>

<p>  目前 v0.1.0 版本包含四个子命令：config（配置管理），compress（图片处理），upload（上传文件）和 cup（一键式压缩、转换、上传）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage
</code></pre></div></div>

<h4 id="config-子命令">config 子命令</h4>

<p>  config 子命令包含 add（添加配置）、delete（删除配置）、info（查看所有配置）和 init（初始化配置）四种操作。使用本工具需要先执行初始行配置操作，再执行其他配置操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config
Usage: pictl config <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

Commands:
  add     Add configs to the config file.
  delete  Delete config group from the config file.
  info    Check the configs.
  init    Initialize config file with default configs.
</code></pre></div></div>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl config init</code> 命令初始化配置。第二次执行时，由于已存在配置文件，会提示已经初始化过了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config init
The settings has been initilized <span class="k">in</span> /home/ubuntu/.pictlrc.

╰─<span class="nv">$ </span>pictl config init
/home/ubuntu/.pictlrc already exists.
Please add settings or change it manaully.
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config info</code> 以 JSON 格式打印所有配置信息。配置文件默认采用 TOML 格式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
<span class="o">}</span>

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.pictlrc
<span class="o">[</span>basic]
length <span class="o">=</span> 6
ntype <span class="o">=</span> <span class="s2">"random"</span>
algorithm <span class="o">=</span> <span class="s2">"sha1"</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config add</code> 以命令行交互方式添加配置（以下是 R2 的例子）。添加完成后可以再次查看新增后的所有配置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config add
<span class="k">******</span> Please input these information <span class="k">******</span>
Group Name <span class="o">(</span>default <span class="s1">'blog'</span><span class="o">)</span>: <span class="nb">test</span>
<span class="o">[</span>?] Type: : R2
   S3
 <span class="o">&gt;</span> R2

Account ID: testid
Bucket Name: <span class="nb">test
</span>Key: testkey
Secret: testsecret
Prefix <span class="o">(</span>Default is None<span class="o">)</span>:
Access Url <span class="o">(</span>like <span class="sb">`</span>https://i.example.com<span class="sb">`</span><span class="o">)</span>: https://i.example.com
New group <span class="s1">'test'</span> has been saved <span class="k">in</span> /Users/zhonger/.pictlrc.

╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
    <span class="s1">'test'</span>: <span class="o">{</span>
        <span class="s1">'endpoint'</span>: <span class="s1">'https://testid.r2.cloudflarestorage.com/test'</span>,
        <span class="s1">'bucket'</span>: <span class="s1">'test'</span>,
        <span class="s1">'prefix'</span>: <span class="s1">''</span>,
        <span class="s1">'key'</span>: <span class="s1">'testkey'</span>,
        <span class="s1">'secret'</span>: <span class="s1">'testsecret'</span>,
        <span class="s1">'url'</span>: <span class="s1">'https://i.example.com'</span>,
        <span class="s1">'type'</span>: <span class="s1">'R2'</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config delete</code> 命令可以选择删除远程配置组（此处为了展示，除 test 外还添加了其他配置组）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config delete
<span class="o">[</span>?] Please <span class="k">select </span>one group: : <span class="nb">test
   </span>blog
   cover
 <span class="o">&gt;</span> <span class="nb">test

test </span>has been deleted.
</code></pre></div></div>

<h4 id="compress-子命令">compress 子命令</h4>

<p>  本子命令输入参数为<strong>图片文件名</strong>，可以带路径。输出图片会被保存在命令执行位置，<strong>而非原图片所在目录</strong>。执行该操作后，图片还不会被上传，需要继续使用 upload 命令完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl compress <span class="nt">-h</span>
Usage: pictl compress <span class="o">[</span>OPTIONS] FILENAME

  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.

  FILENAME is the name of the file to compress.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl compress ../../pictl/fig01.png
The output file is EVyP2J.webp
</code></pre></div></div>

<h4 id="upload-子命令">upload 子命令</h4>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl upload</code> 命令加上指定上传文件名和远程配置组即可完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl upload <span class="nt">-h</span>
Usage: pictl upload <span class="o">[</span>OPTIONS] FILENAME GROUP

  Upload the file to remote storage.

  FILENAME is the name of the file to upload.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl upload EVyP2J.webp <span class="nb">test
</span>Direct URL: https://i.example.com/EVyP2J.webp
Markdown: <span class="o">![</span>EVyP2J.webp]<span class="o">(</span>https://i.example.com/EVyP2J.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/EVyP2J.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"EVyP2J.webp"</span> /&gt;
</code></pre></div></div>

<h4 id="cup-子命令">cup 子命令</h4>

<p>  cup 子命令 = compress 子命令 + upload 子命令，仅需要指定初始图片文件和远程配置组，即可一步完成图片压缩、格式转换、修改名称、上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl cup <span class="nt">-h</span>
Usage: pictl cup <span class="o">[</span>OPTIONS] FILENAME GROUP

  Compress image and upload to remote storage <span class="o">(</span>compress and upload<span class="o">)</span><span class="nb">.</span>

  FILENAME is the name of the file to compress.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl cup ../../pictl/fig01.png <span class="nb">test
</span>The output file is Gl8qhI.webp
Direct URL: https://i.example.com/Gl8qhI.webp
Markdown: <span class="o">![</span>Gl8qhI.webp]<span class="o">(</span>https://i.example.com/Gl8qhI.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/Gl8qhI.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"Gl8qhI.webp"</span> /&gt;
</code></pre></div></div>

<h2 id="todo">TODO</h2>

<p>  目前的 v0.1.0 版本还比较简陋，不过已经能满足笔者的必要需求，有效提升效率。后续将继续完善、新增功能：</p>

<ul>
  <li>自动补全（shell completion），增强命令行使用体验。</li>
  <li>增加对各云服务厂商提供对象存储的支持。</li>
  <li>增加对各流行图床的支持。</li>
  <li>增加对自托管 Git 的支持。</li>
  <li>增加对 FTP 的支持。</li>
  <li>增加包括水印、调整大小等在内的图片处理的支持。</li>
  <li>增加与 Unplash 等公共图库的连接，更加便于博客封面的操作。</li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://blog.cloudflare.com/introducing-r2-object-storage-zh-cn/">隆重推出 Cloudflare R2 Storage —— 快速、可靠的对象存储，减免出口费用</a></li>
  <li><a href="https://developers.cloudflare.com/r2/">R2 文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="project" /><category term="pictl" /><category term="命令行" /><category term="工具" /><category term="cli" /><category term="tool" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">通用运行环境版本管理神器 ASDF</title><link href="https://lisz.me/tech/webmaster/asdf.html" rel="alternate" type="text/html" title="通用运行环境版本管理神器 ASDF" /><published>2023-03-20T15:50:00+09:00</published><updated>2023-03-20T15:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/asdf</id><content type="html" xml:base="https://lisz.me/tech/webmaster/asdf.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  之前介绍了高性能集群中常用的运行环境和软件版本管理工具 Modules，今天打算介绍一款适合个人或团队开发使用的通用运行环境版本管理神器 <a href="https://asdf-vm.com/zh-hans/">ASDF</a>。与高性能计算任务不同，个人或团队开发项目一般来说都是使用独立的设备或环境，然后通过代码版本跟踪 git 等来进行异步协作。所以说，在每个人的单个或多个设备上都安装配置 Modules 显得有点不太现实和高效。但是项目开发所需的代码环境确实有的时候可能比较复杂，比如说同时需要 Ruby、NodeJS、Java、Python 四种环境，而且可能对于每种环境还有版本的限制。这样一来，光配置这一堆环境就要花上大半天时间了。</p>

<h3 id="asdf-简介">ASDF 简介</h3>

<p>  ASDF 提供了全平台通用的环境配置方案，使用单个命令行工具和交互界面就可以管理超复杂的运行环境。以往针对不同运行环境，需要使用不同的配置文件来进行版本的声明。对于 ASDF，只需要一个可共享的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 配置文件即可。ASDF 涵盖了包括 Ruby、NodeJS、Java、PHP、.Net 在内的几百种运行环境，具体可以查看 <a href="https://github.com/asdf-vm/asdf-plugins">ASDF 插件列表</a> 了解更多。</p>

<p>  另外，ASDF 完全支持包括 Bash、Zsh、Fish 和 Elvish 在内的常用 shell 类型，并提供补全功能。在类似 Github Actions 等的 CI/CD 工作流中，也可以轻松使用 ASDF。值得一提的是，笔者翻译了 ASDF 文档的中文版本并被官方采纳，现在 ASDF 官网支持英语、巴西语和中文三种语言。</p>

<h3 id="为何不选其他方案">为何不选其他方案</h3>

<h4 id="docker">Docker</h4>

<p>  很显然，如果大家的设备上都有 Docker 环境且 CPU 架构相同的话，Docker 无疑是最省心的方案。Docker 镜像的确可以轻松涵盖所有开发环境和实际运行环境（Apache 等 HTTP 服务器、数据库以及其他）。相比笨重的 VMware 或 Virtualbox 虚拟机镜像而言，Docker 镜像也更加小巧、便捷。而且团队可以通过在内部搭建自己的 Docker 镜像仓库，来分享这些镜像给所有参与项目的开发者。唯一可能会有问题的是，设备 CPU 架构和操作系统的多样性可能会给实际操作带来了不小的问题。实际上可能会有 Windows 系统、Linux 系统、MacOS 系统以及 Intel 架构、AMD 架构、ARM 架构（如 M1、M2 等）。可行的解决方法是，尽可能地构建更多架构的镜像。</p>

<h4 id="anaconda">Anaconda</h4>

<p>  Anaconda 现在可能已经完全超出了一个 Python 环境管理工具，有的时候也可以当成通用软件或环境管理器来用。但是毕竟还是以科学计算为主要目的，如果项目仅仅是 Python、R 语言可能还是比较合适的，对于实际编程所需的其他运行环境来说可能还是支持不够的。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  据笔者所知，在 <code class="language-plaintext highlighter-rouge">conda-forge</code> 频道里的确有 PHP 等编程语言的支持。除此之外，也有一些热心开发者在个人频道提供了 java-jdk、golang 等编程环境支持。</p>



 </div> </div>
<h4 id="云开发">云开发</h4>

<p>  云开发主要是指基于云基础设施的在线代码开发环境，主要的代表有：</p>

<ul>
  <li><a href="https://aws.amazon.com/cn/cloud9/">Cloud9</a>：笔者最早接触过的云开发，目前已被 AWS 收购，更名为 AWS Cloud9。</li>
  <li><a href="https://github.com/features/codespaces">Codespaces</a>：由 Azure 提供云服务、Github 负责运营的一站式云开发环境。</li>
  <li><a href="https://www.gitpod.io/">Gitpod</a>：基于 VS Code 研发的优秀云开发环境，早期以“便捷、快速”著称，较先于 Codespaces 出现。</li>
  <li><a href="https://cloud.tencent.com/product/cloudstudio">Cloud Studio</a>：由腾讯云提供云服务、基于 VS Code 的国产云开发环境，能够很好地支持个人开发、招聘笔试、课堂教学、应用快捷部署等各种场景。</li>
  <li><a href="https://www.huaweicloud.com/product/cloudide.html">CodeArts IDE Online</a>：由华为云提供云服务、基于 VS Code 的国产云开发环境。除了一般云开发所具备的特点，还支持华为鲲鹏原生环境，能够很好地满足跨架构应用开发的需求。</li>
  <li><a href="https://cn.aliyun.com/product/yunxiao/devstudio">DevStudio</a>：由阿里云提供云服务、基于 VS Code 的国产云开发环境。支持应用开发全流程管理，与阿里云各项基础服务紧密结合，适合大规模团队使用。</li>
</ul>

<p>除了以上列举的云开发之外，也有一些比较传统的小型云开发实践，比如说知名的 <a href="https://jsfiddle.net/">JSFiddle</a>、<a href="https://codepen.io/">CodePen</a>、<a href="https://replit.com/">Replit</a> 等。虽然说这些云开发主要是适合较小代码库，但在实际学习过程中用处也是很大的。</p>

<p>  云开发不仅兼顾了传统开发过程中的协同与流程，又将资源与环境整合在云里面，自然而然是最好的解决方案。随着 VS Code 在开发者之间的流行和云服务提供商的努力，基于 VS Code 的云开发环境层出不穷。即使云开发环境本身免费，云也还是要按量按时计费的。对于还没有足够支持上云的团队或个人来说，ASDF 依然是个不错的选择。</p>

<h2 id="实践">实践</h2>

<h3 id="环境需求">环境需求</h3>

<ul>
  <li>Linux/Unix 环境（Linux、MacOS、Windows WSL）</li>
  <li>git</li>
  <li>bash 等（此处以 zsh 为例）</li>
</ul>

<h3 id="环境配置">环境配置</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码到 ~/.asdf 目录</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.11.3

<span class="c"># 在 ~/.zshrc 文件中加入内容</span>
<span class="nb">tee</span> <span class="nt">-a</span> ~/.zshrc <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
. "</span><span class="nv">$HOME</span><span class="sh">/.asdf/asdf.sh"
</span><span class="no">EOF

</span><span class="c"># 激活配置</span>
<span class="nb">source</span> ~/.zshrc

<span class="c"># 验证</span>
╰─<span class="nv">$ </span>asdf version
v0.11.3-0adc6c1
</code></pre></div></div>

<h3 id="安装插件">安装插件</h3>

<p>  由于 ASDF 支持插件较多，这里以 Python 环境为例介绍 ASDF 安装插件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加插件</span>
asdf plugin add python

<span class="c"># 查看已安装插件</span>
╰─<span class="nv">$ </span>asdf plugin list
python

<span class="c"># 查看最新 Python 版本</span>
╰─<span class="nv">$ </span>asdf latest python
3.11.2

<span class="c"># ASDF 安装 Python 3.11.2 (latest)</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python latest
python-build 3.11.2 /home/ubuntu/.asdf/installs/python/3.11.2
Downloading Python-3.11.2.tar.xz...
-&gt; https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tar.xz
Installing Python-3.11.2...
Installed Python-3.11.2 to /home/ubuntu/.asdf/installs/python/3.11.2

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  ASDF 提供全局版本（Global）和本地版本（Local）两种方式定义运行环境版本。全局版本是系统级别的，类似于 PATH 变量中定义的；本地版本则是为了某个代码库或者部分代码准备的，通常在目录中的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 文件里定义。为了区分全局和本地的效果差别，这里再安装一个指定 Python 版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询 Python 插件支持的所有版本</span>
╰─<span class="nv">$ </span>asdf list all python
2.1.3
2.2.3
......
stackless-3.7.5

<span class="c"># 安装 Python 3.9.0</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python 3.9.0
python-build 3.9.0 /home/zhonger/.asdf/installs/python/3.9.0
Downloading Python-3.9.0.tar.xz...
-&gt; https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tar.xz
Installing Python-3.9.0...
patching file Misc/NEWS.d/next/Build/2021-10-11-16-27-38.bpo-45405.iSfdW5.rst
patching file configure
patching file configure.ac
Installed Python-3.9.0 to /home/zhonger/.asdf/installs/python/3.9.0

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
  3.9.0

<span class="c"># 查看当前系统 Python 及 Python3 版本</span>
╰─<span class="nv">$ </span>python <span class="nt">-V</span>
No python executable found <span class="k">for </span>python system

╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6

<span class="c"># 更改全局版本为 3.11.2 并查看</span>
╰─<span class="nv">$ </span>asdf list
python
 <span class="k">*</span>3.11.2
  3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 创建子目录指定本地版本并查看</span>
<span class="nb">mkdir </span>py <span class="o">&amp;&amp;</span> <span class="nb">cd </span>py
asdf <span class="nb">local </span>python 3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.9.0

<span class="c"># 返回父目录查看 Python 版本</span>
╰─<span class="nv">$ </span><span class="nb">cd</span> .. <span class="o">&amp;&amp;</span> python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 查看当前系统 Python3 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  这里有一点比较有趣的是：由于 ASDF 接管的 <code class="language-plaintext highlighter-rouge">python</code> 命令而非 <code class="language-plaintext highlighter-rouge">python3</code> 命令，所以 <code class="language-plaintext highlighter-rouge">python3</code> 命令输出的版本依然还是系统安装版本。</p>



 </div> </div>
<h3 id="其他相关">其他相关</h3>

<p>  如果想要恢复到系统指定版本，可以很容易使用 <code class="language-plaintext highlighter-rouge">asdf global python system</code> 命令。当然，对于本地版本，可以使用 <code class="language-plaintext highlighter-rouge">asdf local python system</code> 来实现。除此之外，还有一些常规操作如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 Python 指定版本安装位置</span>
╰─<span class="nv">$ </span>asdf where python 3.11.2
/home/zhonger/.asdf/installs/python/3.11.2

<span class="c"># 查看命令所在位置</span>
╰─<span class="nv">$ </span>asdf which python
/home/zhonger/.asdf/installs/python/3.11.2/bin/python

<span class="c"># 查看当前 ASDF 管理的运行环境</span>
╰─<span class="nv">$ </span>asdf current
python          3.11.2          /home/ubuntu/.tool-versions

<span class="c"># 查看全局和本地版本配置文件</span>
╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.tool-versions
python 3.11.2

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/py/.tool-versions
python 3.9.0
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://asdf-vm.com/zh-hans/guide/getting-started.html">ASDF 官网 - 快速入门</a></li>
  <li><a href="https://asdf-vm.com/zh-hans/manage/versions.html">ASDF 官网 - 版本</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Environment" /><category term="Manage" /><category term="Dev Runtime" /><category term="软件环境" /><category term="多版本" /><category term="管理" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Modules 配置之 Python</title><link href="https://lisz.me/tech/webmaster/modules-python.html" rel="alternate" type="text/html" title="Modules 配置之 Python" /><published>2023-03-20T12:48:00+09:00</published><updated>2023-03-20T12:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules-python</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules-python.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  近年来得益于其轻量、易学易用、第三方支持依赖库多的特点，Python 语言大量被用于机器学习相关的研究、项目开发。在学术界，有以 <a href="https://scikit-learn.org">Scikit-Learn</a> 为代表的全能机器学习库；在产业界，有以 <a href="https://www.tensorflow.org">TensorFlow</a>、<a href="https://pytorch.org">PyTorch</a> 为代表的生产级机器学习模型计算框架。（当然，学术界实际上构建大规模深度学习模型时也会用到 PyTorch 等计算框架。）但对于大多数人来说，学习这些库、框架或者借助它们从事某些研究、项目开发时，可能还是在用自己的笔记本、台式机。哪怕是在高校的实验室里，这种事情也是屡见不鲜。因此，有交互界面、相对容易上手的 <a href="https://www.anaconda.com">Anaconda</a> 可能会作为大家管理 Python 环境的首选。</p>

<p>  当我们在用 Python 编写一些代码，而代码一次运行不可能在短短几秒、几分钟内得到结果时，将任务提交给高性能工作站或者集群作业系统就显得格外有效。尤其是当应用规模较大、计算迭代次数较多时，非交互式的作业提交方式会变得更加有利。毕竟如果是用自己的笔记本运行着这么大的计算，资源基本上都被计算占用了，根本没办法用笔记本去干点别的事情。甚至说，计算还会使得 CPU 等核心部件温度上升，从而影响计算性能。这样比较下来，不得不说提交任务给高性能工作站或者集群作业系统是多么明智的选择。</p>

<p>  其实，Anaconda 在没有交互界面的服务器操作系统上也还是可以使用的，我们可以使用其免费的精简版 —— <a href="https://conda.io/miniconda">miniconda</a>。虽然 miniconda 已经是精简版了，但和原生 Python 环境比起来还是要多不少东西的。从高性能计算环境的角度来看，使用 Modules 直接管理 Python 环境实际上更加贴近原生，也更加有利于用户与其他环境搭配使用。比如说安装  Python 的 MPI 支持库 —— MPI4PY，仅需要通过 Modules 管理工具加载 Python 和 MPI 两个基础环境，使用 <code class="language-plaintext highlighter-rouge">pip3 install mpi4py</code> 命令即可安装。</p>

<h2 id="实践">实践</h2>

<p>  将 Python 环境纳入 Modules 管理的步骤就是两步：第一步，编译源代码及安装；第二步，添加 Modules 配置文件。当然，最开始还是需要确认一下编译环境是否完备以及文件夹是否准备好。</p>

<h3 id="环境及文件夹准备">环境及文件夹准备</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装编译环境</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> build-essential libbz2-dev libdb-dev <span class="se">\</span>
  libreadline-dev libffi-dev libgdbm-dev liblzma-dev <span class="se">\</span>
  libncursesw5-dev libsqlite3-dev libssl-dev <span class="se">\</span>
  zlib1g-dev uuid-dev tk-dev wget
  
<span class="c"># 准备文件夹</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/python/3.10.6
</code></pre></div></div>

<h3 id="编译及安装">编译及安装</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源代码</span>
<span class="nb">cd</span> /tmp
wget <span class="nt">-c</span> https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tar.xz

<span class="c"># 解压源代码</span>
<span class="nb">tar </span>xf Python-3.10.6.tar.xz

<span class="c"># 配置安装路径及编译选项</span>
<span class="nb">cd </span>Python-3.10.6
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/python/3.10.6 <span class="nt">--enable-optimizations</span> <span class="nt">--with-lto</span> 

<span class="c"># 编译及安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="配置-modules">配置 Modules</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules/modulefiles/py
<span class="nb">sudo </span>vim /opt/modules/modulefiles/py/3.10.6
</code></pre></div></div>

<p>  首先如上命令准备文件夹，并新建 module 配置文件，内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="se">\t</span>This module file will load Python 3.10.6<span class="s2">"
}

module-whatis  "</span>Enable Python 3.10.6<span class="s2">"

eval set  [ array get env HOME ]
set basedir /opt/python/3.10.6
prepend-path PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/bin<span class="s2">"
prepend-path LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path LD_LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
prepend-path LD_INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
</span></code></pre></div></div>

<h3 id="验证">验证</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
╰─<span class="nv">$ </span>module ava
<span class="nt">--------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  py/3.10.6  use.own

Key:
modulepath
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 加载 python 3.10.6 环境，并确认已加载模块</span>
╰─<span class="nv">$ </span>module load py/3.10.6
╰─<span class="nv">$ </span>module list
Currently Loaded Modulefiles:
 1<span class="o">)</span> py/3.10.6
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认目前 python 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  由于以上操作将 Python 3.10.6 安装到了一个系统文件夹中，编译完成后会出现如下警告提示。不过无须担心，普通用户可以通过 venv 虚拟环境工具正常使用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Installing collected packages: setuptools, pip
  WARNING: The scripts pip3 and pip3.10 are installed <span class="k">in</span> <span class="s1">'/opt/python/3.10.6/bin'</span> which is not on PATH.
  Consider adding this directory to PATH or, <span class="k">if </span>you prefer to suppress this warning, use <span class="nt">--no-warn-script-location</span><span class="nb">.</span>
Successfully installed pip-22.2.1 setuptools-63.2.0
WARNING: Running pip as the <span class="s1">'root'</span> user can result <span class="k">in </span>broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
</code></pre></div></div>

<p>  如下所示，当已经如<strong>验证</strong>部分加载好 python 3.10.6 模块后，使用以下命令新建虚拟环境、激活后即可使用。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>   新建虚拟环境时最后的参数 env 是指虚拟环境的名字，我们可以取任意符合 python 规则的字符串作为虚拟环境名字。值得注意的是，python 虚拟环境有关的文件将会被安装在命令执行的当前目录下的同名文件夹中。为了便于管理和使用，建议将所有的 python 虚拟环境都放置在同一目录下。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 新建 env 虚拟环境</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-m</span> venv <span class="nb">env</span>

<span class="c"># 激活 env 虚拟环境</span>
╰─<span class="nv">$ </span><span class="nb">source env</span>/bin/activate

<span class="c"># 可以看到 &lt;env&gt; 的环境提示</span>
<span class="c"># 尝试升级 pip，可以看到成功升级 </span>
╭─zhonger@lep-u ~ ‹env›
╰─<span class="nv">$ </span>pip3 <span class="nb">install</span> <span class="nt">-U</span> pip
Requirement already satisfied: pip <span class="k">in</span> ./env/lib/python3.10/site-packages <span class="o">(</span>22.2.1<span class="o">)</span>
Collecting pip
  Using cached pip-23.0.1-py3-none-any.whl <span class="o">(</span>2.1 MB<span class="o">)</span>
Installing collected packages: pip
  Attempting uninstall: pip
    Found existing installation: pip 22.2.1
    Uninstalling pip-22.2.1:
      Successfully uninstalled pip-22.2.1
Successfully installed pip-23.0.1

<span class="c"># 取消激活 env 虚拟环境</span>
╰─<span class="nv">$ </span>deactivate
</code></pre></div></div>

<h2 id="有趣的问题">有趣的问题</h2>

<p>  如果使用 module 提供的 python 模块创建了虚拟环境后，实际运行虚拟环境时还需要使用 module 加载 python 模块吗？答案是<strong>不需要</strong>。虚拟环境的本质是拷贝运行相同命令所需的必要文件，如下对比查看一下 python 模块和 env 虚拟环境的顶级目录。可以发现，两者的差别不是很大。env 虚拟环境少了 share 目录，多了 pyvenv.cfg 文件。查看该文件可知，存在与 python 模块之间的关系的声明。再查看 bin 目录，可以看到 python 可执行命令用了链接的方式，pip 命令则是直接从原来的 python 模块复制过来的。于是，这就能允许普通用户自行管理  pip 命令和 python 库了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/python/3.10.6
bin  include  lib  share

╰─<span class="nv">$ </span><span class="nb">ls env
</span>bin  include  lib  lib64  pyvenv.cfg

╰─<span class="nv">$ </span><span class="nb">cat env</span>/pyvenv.cfg
home <span class="o">=</span> /opt/python/3.10.6/bin
include-system-site-packages <span class="o">=</span> <span class="nb">false
</span>version <span class="o">=</span> 3.10.6

╰─<span class="nv">$ </span>ll <span class="nb">env</span>/bin
total 36K
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 8.9K Mar 20 15:20 Activate.ps1
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.0K Mar 20 15:20 activate
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger  908 Mar 20 15:20 activate.csh
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.1K Mar 20 15:20 activate.fish
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3.10
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python -&gt; python3
lrwxrwxrwx 1 zhonger zhonger   30 Mar 20 15:20 python3 -&gt; /opt/python/3.10.6/bin/python3
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python3.10 -&gt; python3
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://docs.python.org/zh-cn/3/using/unix.html#building-python">Python 官方文档 - 构建 Python</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/using/configure.html#configure-options">Python 官方文档 - 性能选项</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">Python 官方文档 - 虚拟环境和包</a></li>
  <li><a href="https://www.python.jp/install/ubuntu/index.html">Ubuntu 環境の Python</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Modules" /><category term="Python" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">集群动态环境管理神器 Modules</title><link href="https://lisz.me/tech/webmaster/modules.html" rel="alternate" type="text/html" title="集群动态环境管理神器 Modules" /><published>2022-10-26T15:48:00+09:00</published><updated>2022-10-26T15:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules.html"><![CDATA[<h2 id="前言">前言</h2>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  Modules 包是一款简化 shell 初始化的工具，允许用户在会话期间使用模块文件轻松切换环境。</p>



 </div> <div class="ref"> ------ Environment Modules 官网 </div> </div>
<p>  在高性能集群或者超算中，我们可以经常看到 Modules 的身影。它可以帮助我们轻松加载运行程序所需的各类环境，比如说笔者之前写过的第一性原理计算软件 CONQUEST 的运行，就需要包括 Intel OneAPI HPCKit、FFTW3、LibXC 在内的多种环境；又比如说运行大规模的机器学习模型时，可能需要 Python、GPU 环境和 PyTorch 等依赖库。</p>

<p>  由于集群往往是面向很多人服务的，如果管理员将软件安装到全局环境，则只能安装某个软件的某个特定版本，而不能同时为不同的用户提供所需的同款软件的不同版本。举个例子，笔者编写的代码只能在 Python 3.10 环境下运行，而其他用户编写的代码所支持的 Python 版本是 3.0，那么可能最简单的解决方法是笔者自行编译一个 Python 3.10 的环境，然后利用 PATH 等变量的配置来提升优先级。或许之后有一天，另外一个用户也要使用 Python 3.10 环境，那么是不是让他再自行编译配置一遍呢？哈哈哈，听起来有点无奈，但是<strong>千万不要高估集群的使用用户</strong>，可能自行编译并配置 Python 3.10 对他们来说也有点困难。因此，Modules 成为了集群动态管理软件环境的最佳选择。集群管理员可以预先编译和配置好各种环境的各种版本，用户使用时只需要执行类似 <code class="language-plaintext highlighter-rouge">module load py/3.10.6</code> 的命令就可以轻松加载 Python 3.10.6 环境。</p>

<p>  Modules 所支持的模块不仅仅可以是编程语言的多版本，还可以是其他任意的基础环境，比如说 gcc、openmpi 等编译环境。这样一来，不仅可以为用户提供足够的编程环境直接使用，还可以为一些想要自行编译运行环境的用户提供了便利。</p>

<h2 id="实践">实践</h2>

<h3 id="源码编译安装-modules">源码编译安装 Modules</h3>

<p>  Modules 可以在 Linux、Windows、MacOS 任一操作系统上安装运行，这里仅介绍类 Unix 操作系统下的编译安装过程。由于 Modules 需要使用 tcl 工具来解析 modulefiles，所以系统必须预先安装 tcl 及其开发者库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 根据实际情况三者选其一</span>
<span class="c"># Debian/Ubuntu 等 APT 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-dev
<span class="c"># CentOS 等 YUM 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-devel
<span class="c"># MacOS 操作系统上安装 tcl （需有 brew 工具）</span>
brew <span class="nb">install </span>tcl-tk

<span class="c"># 下载源代码并解压</span>
wget <span class="nt">-c</span> https://github.com/cea-hpc/modules/releases/download/v5.1.1/modules-5.1.1.tar.gz
<span class="nb">tar </span>xfz modules-5.1.1.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>modules-5.1.1
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules
<span class="c"># MacOS 可能需要如下另外指定 tclConfig.sh 文件所在的位置</span>
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules <span class="nt">--with-tcl</span><span class="o">=</span>/opt/homebrew/opt/tcl-tk/lib

<span class="c"># 编译并安装到 /opt/modules 目录</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="使-modules-生效">使 Modules 生效</h3>

<p>  并非是编译完了之后就可以直接使用 Modules，还有至关重要的一步–<strong>添加生效命令</strong>。首先需要确认当前使用的 Shell 是什么，一般来说默认是 Bash，当然也有 Zsh 等等。然后，在对应的 Shell 配置文件中增加一行生效命令。操作如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认当前使用的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/zsh

<span class="c"># 查看 Modules 支持的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/init
bash            cmake           fish            ksh             lisp            profile.csh     python.py       ruby.rb         tcl             tcsh_completion zsh-functions
bash_completion csh             fish_completion ksh-functions   perl.pm         profile.sh      r.R             sh              tcsh            zsh
<span class="c"># 如上所示，大部分流行的 Shell 都在支持列表中</span>

<span class="c"># 使 Modules 生效</span>
vim ~/.zshrc
<span class="c"># 添加以下内容</span>
<span class="nb">source</span> /opt/modules/init/zsh
</code></pre></div></div>

<h3 id="源码编译安装-tcl">源码编译安装 tcl</h3>

<p>  Modules 的编译安装是不是很简单？不过如果 tcl 工具无法使用命令安装的话，就只能从源码编译安装，也比较方便，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码并解压</span>
wget <span class="nt">-c</span> https://prdownloads.sourceforge.net/tcl/tcl8.6.12-src.tar.gz
<span class="nb">tar </span>xfz tcl8.6.12-src.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> /opt/tcl

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>tcl8.6.12/unix
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/tcl

<span class="c"># 编译并安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="modules-相关命令">Modules 相关命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
module avail / module ava

<span class="c"># 加载指定模块（支持同时加载多个模块）</span>
module load py/3.10.6 mpi

<span class="c"># 查看已加载模块</span>
module list

<span class="c"># 查看指定模块</span>
module show py/3.10.6

<span class="c"># 添加自定义模块配置目录</span>
module use <span class="nt">--apend</span> ~/opt/modulefiles
</code></pre></div></div>

<h2 id="添加软件环境">添加软件环境</h2>

<h3 id="modulefiles-库">Modulefiles 库</h3>

<p>  Modules 编译安装后默认会有一些环境，它们的配置文件都被存储在安装目录的 modulefiles 文件夹中，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>module ava
<span class="nt">---------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  use.own

Key:
modulepath

╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/modulefiles
dot         module-git  module-info modules     null        use.own
</code></pre></div></div>

<p>  一般来说，打算提供给所有用户的环境配置都可以放在这个目录里，这样任何用户都可以查看到。</p>

<h3 id="modulefiles-模板">Modulefiles 模板</h3>

<p>  这里我们可以把 <code class="language-plaintext highlighter-rouge">use.own</code> 文件作为模板来学习一下如何编写 Modulefiles 文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module1.0#####################################################################</span>
<span class="c">##</span>
<span class="c">## use.own modulefile</span>
<span class="c">##</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module file will add </span><span class="se">\$</span><span class="s2">HOME/privatemodules to the"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">list of directories that the module command will search"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">for modules.  Place your own module files here."</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module, when loaded, will create this directory"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">if necessary."</span>
<span class="o">}</span>

module-whatis   <span class="s2">"adds your own modulefiles directory to MODULEPATH"</span>

<span class="nb">eval set</span>  <span class="o">[</span> array get <span class="nb">env </span>HOME <span class="o">]</span>
<span class="nb">set </span>ownmoddir   <span class="nv">$HOME</span>/privatemodules

<span class="c"># create directory if necessary</span>
<span class="k">if</span> <span class="o">[</span> module-info mode load <span class="o">]</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">{</span> <span class="o">!</span> <span class="o">[</span> file exists <span class="nv">$ownmoddir</span> <span class="o">]</span> <span class="o">}</span> <span class="o">{</span>
        file <span class="nb">mkdir</span> <span class="nv">$ownmoddir</span>
        <span class="nb">set </span>null <span class="o">[</span>open <span class="nv">$ownmoddir</span>/null w]
        puts <span class="nv">$null</span> <span class="s2">"#%Module########################################################################"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"## null modulefile"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"proc ModulesHelp { } {"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">This module does absolutely nothing.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">It's meant simply as a place holder in your</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">dot file initialization.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"}"</span>
        puts <span class="nv">$null</span> <span class="s2">""</span>
        puts <span class="nv">$null</span> <span class="s2">"module-whatis   </span><span class="se">\"</span><span class="s2">does absolutely nothing</span><span class="se">\"</span><span class="s2">"</span>
    <span class="o">}</span>
<span class="o">}</span>

module use <span class="nt">--append</span> <span class="nv">$ownmoddir</span>
</code></pre></div></div>

<p>  Modulefiles 文件一般符合以下规则：</p>

<ul>
  <li>Modulefiles 文件必须以 <code class="language-plaintext highlighter-rouge">#%Module1.0</code> 开头；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">proc ModulesHelp {}</code> 函数来添加模块详细描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">module-whatis</code> 字段来添加一句话简短描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">eval set [ array get env HOME]</code> 来获取系统变量 <code class="language-plaintext highlighter-rouge">$HOME</code>；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">set ownmoddir</code> 来定义变量 <code class="language-plaintext highlighter-rouge">ownmoddir</code>；</li>
  <li>后续脚本可以根据需求进行添加内容。</li>
</ul>

<p>  这里先开个坑，后续打算补充 Modules 配置系列文章：</p>

<ul>
  <li><a href="modules-python.html">《Modules 配置之 Python》</a></li>
  <li><a href="modules-conda.html">《Modules 配置之 Anaconda》</a></li>
  <li><a href="modules-intel.html">《Modules 配置之 Intel OneAPI》</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://modules.readthedocs.io/en/latest/index.html">Environment Modules 官方文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="集群" /><category term="Cluster" /><category term="Modules" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 OpenVPN 篇</title><link href="https://lisz.me/tech/webmaster/ldap-openvpn.html" rel="alternate" type="text/html" title="LDAP 集成之 OpenVPN 篇" /><published>2022-09-28T15:04:00+09:00</published><updated>2022-09-28T15:04:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-openvpn</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-openvpn.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="easy-connect">Easy Connect</h3>

<p>  公司、学校、云服务等一般需要将内外网进行分离，如果想要从外部网络访问某些内部应用，通常需要使用公司、学校、云服务提供的专用网络接入服务。国内公司、学校比较常用的是由深信服开发的 Easy Connect，一种 SSL VPN 技术的实现。虽然每年需要支付一定的费用来维护、升级 Easy Connect 服务，但是毕竟它能够提供比较细粒度的权限控制，比如说对目标 IP、目标端口的特别指定，能够有效保护内网服务器只有 Web 应用本身能被用户接入，而类似于 SSH 等服务及端口则可以通过单独申请和配置来实现。总而言之，除了需要付费，似乎没有什么不好的地方。</p>

<p>  实际上如果是在大公司或者学校的话，可能在内网里面还会有更深的内网存在。举个例子，正常的内网是日常的办公或开发网络，服务器所处的内网是独立的网络，即使是已经连接了办公网络，还是需要通过专用网络接入服务器内网才能进行服务器的维护。如果是以数据中心的模式运营的话，甚至说每一次访问服务器都是需要经过临时审批和登录密码发放的。一旦过了有效时间或者完成了任务，访问都将会被拒绝。</p>

<h3 id="openvpn">OpenVPN</h3>

<p>  虽然 Easy Connect 可以用于上述的场景，但是似乎显得有些大材小用了，毕竟还是要支付一定费用的。为了尽量降低成本，开源的 OpenVPN 或许是一种不错的选择。据笔者所知，Easy Connect 根据购买的许可不同允许的同时在线人数可能也会不同，实际上可能存在“需大于供”的问题。为了缓解这一可能存在的问题，还是会搭建一套 OpenVPN 来作为冗余接入方式。其实 OpenVPN 的商业版本许可也是会有人数限制的，只不过因为只是备份方式也没有太大关系。</p>

<p>  OpenVPN 除了开源免费之外，还支持大部分主流的认证方式，比如说 LDAP 认证、微软的商业级目录服务 Active Directory（简称 AD）认证等。近年来，基于 Identify Provider（简称 IdP）、Single Sign On（简称 SSO）、Central Authentication Service（简称 CAS）等的国产化的一站式登录服务解决方案也在逐渐替换原来的 LDAP 或 AD 直接认证，LDAP 或 AD 将作为底层的基础认证方式存在。所以说，开源免费的 LDAP 目录服务在一般的团队中还是足够的，作为 OpenVPN 的认证方式也是完全能满足要求的。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 提醒 </div> </div> <div class="content"> <p>  在公网上搭建专用网络接入服务是需要有工信部颁发的专门资格许可的，一般公司、学校、云服务都是有该类资格许可，所以可以对外提供该项服务。而个人是无法获得这类许可，除非注册公司并申请该类许可。如果个人在云服务上搭建该类服务，将会面临被云服务提供商警告甚至单方面停止服务的风险。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在实践前请务必保证具备以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
  <li>可用的 LDAP 目录服务</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  为了方便部署和测试，这里采用 <a href="https://hub.docker.com/r/wheelybird/openvpn-ldap-otp">wheelybird/openvpn-ldap-otp</a> 提供的 Docker 镜像。这个镜像比较小，同时也支持 x64 和 arm 两种体系架构，能满足大部分主流服务器平台。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">openvpn</span><span class="pi">:</span>
    <span class="na">cap_add</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">NET_ADMIN</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">wheelybird/openvpn-ldap-otp</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">openvpn</span>
    <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">1194:1194/udp"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
     <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
     <span class="pi">-</span> <span class="s">./openvpn-data:/etc/openvpn</span>
    <span class="na">environment</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">OVPN_SERVER_CN=oc-vpn.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_URI=ldap://ldap.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_BASE_DN=ou=users,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_DN=cn=admin,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_PASS=password</span>
     <span class="pi">-</span> <span class="s">LDAP_LOGIN_ATTRIBUTE=uid</span>
     <span class="pi">-</span> <span class="s">LOG_TO_STDOUT=false</span>
     <span class="pi">-</span> <span class="s">OVPN_DNS_SEARCH_DOMAIN=example.com</span>
</code></pre></div></div>

<p>  使用以下 docker-compose.yml 文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。为了能够避免实例在重新创建后证书发生改变，将 Docker 实例中 /etc/openvpn 的目录持久化（与本地目录绑定）是非常重要的。在这里给出的环境变量（environment）中，前三项 OVPN_SERVER_CN、LDAP_URI、LDAP_BASE_DN 是必须要有的。如果 LDAP 目录服务默认是不能被匿名查找的，也必须包含 LDAP_BIND_USER_DN 和 LDAP_BIND_USER_PASS 变量的（即管理员账户名和密码）。当然，如果你想要指定匹配登录用户名字段，则需要新增 LDAP_LOGIN_ATTRIBUTE 变量。该变量默认是 uid 字段，也可以指定为其他 LDAP 目录服务中包含的字段，比如 email。这个镜像默认是会将服务的实时输出打印在终端，如果想要以日志文件的形式保存下来，则将变量 LOG_TO_STDOUT 置为 false 即可。</p>

<p>  一般来说，服务器内网为了管理方便，会根据服务器的 ip 和编号来配置对应的域名解析及反向域名解析，形如 <code class="language-plaintext highlighter-rouge">ec2-1-1-1-1.aws.com</code>，也有可能就是简单的 <code class="language-plaintext highlighter-rouge">c1.sever.aws.com</code>。所以当接入服务器内网后，我们可能会期望用 c1 来作为这台服务器的标签，而在终端我们也可能通过 <code class="language-plaintext highlighter-rouge">ping c1</code> 来测试通路。实际上只要在启动实例时新增变量 OVPN_DNS_SEARCH_DOMAIN 就可以实现，当然这里变量对应的值也应该变成 <code class="language-plaintext highlighter-rouge">server.aws.com</code>。相当于，有了这个配置后，本地 DNS 解析没有记录时会自动尝试加入后缀来解析。这样一来，是不是方便了很多呢？</p>

<p>  除此之外，该镜像还支持其他一些特性，比如 OTP，请访问 <a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 了解更多。</p>

<h4 id="生成配置文件">生成配置文件</h4>

<p>  在生成配置文件上，<a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 要比 <a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a> 更复杂一些，可以手动从 Docker 实例的日志文件或终端输出内容中看到内容，大致内容形式如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------- Start of client.ovpn ----------</span>

client
tls-client
dev tun
persist-key
persist-tun
remote-cert-tls server
key-direction 1
auth SHA512
proto tcp
reneg-sec 0

comp-lzo
redirect-gateway def1
auth-user-pass

<span class="c"># Set log file verbosity</span>
verb 3

&lt;connection&gt;
remote oc-vpn.example.com 1194 udp
float
nobind
&lt;/connection&gt;

&lt;ca&gt;
<span class="nt">-----BEGIN</span> CERTIFICATE-----
.........
.........
<span class="nt">-----END</span> CERTIFICATE-----
&lt;/ca&gt;
&lt;tls-auth&gt;
<span class="c">#</span>
<span class="c"># 2048 bit OpenVPN static key</span>
<span class="c">#</span>
<span class="nt">-----BEGIN</span> OpenVPN Static key V1-----
.........
.........
<span class="nt">-----END</span> OpenVPN Static key V1-----
&lt;/tls-auth&gt;
key-direction 1
<span class="c">#----------  End of client.ovpn  ----------</span>
</code></pre></div></div>

<p>  将以上内容复制保存在 oc-vpn.example.com.ovpn 文件中即可。</p>

<h3 id="测试">测试</h3>

<p>  通常来说使用 OpenVPN 专用或者兼容客户端来加载配置文件 oc-vpn.example.com.ovpn，当然也可以用终端命令连接，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>openvpn <span class="nt">--config</span> oc-vpn.example.com.ovpn
</code></pre></div></div>

<p>  执行上述命令后会提示输入用户名和密码进行认证，认证通过后会建立连接。默认分配的是 10.50.50.0/24 段中的某个 IP，网关为 10.50.50.254，当然这个也可以在启动实例时自行设置。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 再次提醒 </div> </div> <div class="content"> <p>  以上内容比较适用于团队办公或开发网络与服务器网络独立分离的情况（<strong>内网环境</strong>）。请勿在未获得工信部的资质许可的情况下在公网部署类似服务，一旦被云服务提供商监测到，云服务提供商有权进行警告、断网、关停等操作，并且无法申诉。</p>



 </div> </div>
<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a></li>
  <li><a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a></li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1jkj42lj2m4nn">加入链接</a>。</p>



 </div> </div>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="OpenVPN" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 Squid 篇</title><link href="https://lisz.me/tech/webmaster/ldap-squid.html" rel="alternate" type="text/html" title="LDAP 集成之 Squid 篇" /><published>2022-09-28T15:00:00+09:00</published><updated>2022-09-28T15:00:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-squid</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-squid.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Squid cache，简称 Squid，是一款高性能的代理缓存软件。Squid 本身支持包括 HTTP、HTTPS、FTP、SSH 在内的多种协议，且采用一个单独的、非模块化的、I/O 驱动的进程来处理所有的客户端请求，从而提供<strong>主动缓存加速</strong>的功能。除此之外，Squid 还可以提供<strong>应用层过滤控制</strong>的功能，也可与其他的<strong>防病毒</strong>软件一起使用。在一些大公司、学校、研究机构内部，一般采用 Squid 代理上网的方式，可以过滤危险内容或操作、节省网络带宽、提升访问速度。</p>

<p>  但实际上 Squid 代理也可用于正向代理，即为外来用户访问内网应用提速。这也是 CDN（内容分发网络）的加速原理，利用位于全球网络边缘的节点提供服务，而实际上的应用内容则通过边缘节点间的内网来缓存提速。</p>

<p>  虽然 Squid 一般部署在团队或公司网络内部，但是由于用户的权限不同可能需要应用不同的规则，所以能够与 LDAP 认证服务结合就变得非常重要了。</p>

<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在进行正式的实践之前，务必确保已有以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  笔者已经编译并公开了在多种体系架构上可用的 Docker 镜像 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a>。这里直接使用以下 docker-compose.yml 配置文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.2'</span>

<span class="na">services</span><span class="pi">:</span> 
  <span class="na">squid</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/squid</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3128:3128"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span> 
      <span class="pi">-</span> <span class="s">SQUID_SSH=true</span>
      <span class="pi">-</span> <span class="s">SQUID_RSYNC=false</span>
      <span class="pi">-</span> <span class="s">LDAP_ENABLE=true</span>
      <span class="pi">-</span> <span class="s">LDAP_HOST=yourldap.domain.com</span>
      <span class="pi">-</span> <span class="s">LDAP_PORT=389</span>
      <span class="pi">-</span> <span class="s">LDAP_BindDN="cn=admin,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_BindPass="********"</span>
      <span class="pi">-</span> <span class="s">LDAP_DN="ou=Users,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_ATTRIBUT="uid=%s"</span>
      <span class="pi">-</span> <span class="s">PROXY_NAME="Proxy Display Name"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>  上面有关的配置变量及其含义可以访问 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a> 了解更多。</p>

<h4 id="测试">测试</h4>

<p>  通过浏览器访问 http://ip:3128 并输入对应的用户名和密码可以看到类似下面的内容。</p>

<p><img src="https://i.lisz.top/blog/nUOnpb.webp" alt="nUOnpb" /></p>

<h3 id="客户端连接">客户端连接</h3>

<p>  由于我们未指定实际需要访问的地址，Squid 会直接报错。一般使用时，需要使用操作系统的网络设置中的代理来配置好 Squid。如下图所示，勾选“网页代理（HTTP）”并填写相关的 IP、端口、用户名及密码。如果想要同样应用在访问 HTTPS 站点，则还需要勾选“安全网页代理（HTTPS）”及填写相关信息。然后点击保存生效。</p>

<p><img src="https://i.lisz.top/blog/oXWsLE.webp" alt="oXWsLE" /></p>

<p>  这样一来就可以将访问的流量完全交给 Squid 来控制了。当然，如果不确定客户端连接是否成功，可以通过访问 <a href="https://ip.sb">ip.sb</a> 来确认当前客户端流量出口 IP 是否为 Squid 服务器 IP。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://www.squid-cache.org/">Squid cache</a></li>
  <li><a href="https://zh.wikipedia.org/zh-cn/Squid_(%E8%BD%AF%E4%BB%B6)">Squid 软件</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="Squid" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">内网私有域名解析</title><link href="https://lisz.me/tech/webmaster/internal-dns.html" rel="alternate" type="text/html" title="内网私有域名解析" /><published>2022-08-04T11:30:00+09:00</published><updated>2022-08-04T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/internal-dns</id><content type="html" xml:base="https://lisz.me/tech/webmaster/internal-dns.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="域名和域名解析">域名和域名解析</h3>

<p>  大家可能知道，在网络被发明出来之后一段时间，大家采用 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式一起共享资源。后来随着资源越来越多，这样一种方式显得非常不友好。比如说，现在有 254 个 IP，每个 IP 上有 20 个 Web 应用，那么我们就必须记住 5080 个 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的组合，简直太折磨人了。于是在 1983 年，保罗・莫卡派乔斯发明了域名解析服务和域名服务（DNS，Domain Name System）。从此以后，大家开始用域名来访问各种各样的应用服务。显然，相比原来 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式，域名的含义更加具象、更容易被人记住。</p>

<p>  域名解析实际上就是把 IP 和一串有意义的字符对应，这是一对多的关系，即一个 IP 可能对应多个域名。域名的管理单位我们称之为域名注册管理机构，他们掌握着顶级域名的管理权利。比如说，.net、.com、.org 就是顶级域名，域名注册管理机构对顶级域名具有完整的权利。就像上次讲到的 SSL 根证书一样，光有域名注册管理机构还是不够的，他们没有办法直接把域名卖给全世界所有的公司或者个人，而是需要域名注册商承担这部分工作。像我们比较熟知的国内的万网（现在阿里云域名）、DNSPod（现在腾讯云域名）等，国外的 Gandi、Godaddy 等，都是域名注册商。顶级域名根据用途不同可以分为，国别域名后缀和通用域名后缀。国别域名后缀就是指定给各个国家或地区使用的，通用域名后缀就是其余的。我们可以在某域名注册商处购买某个域名后缀（也称顶级域名）的子域名（也称二级域名），比如说我们可以购买域名后缀为 .com 的域名 baidu.com（当然 baidu.com 早就被注册了，我们只能购买还未被注册的域名）。由于一些品牌效应，大部分域名后缀都会保留一些子域名，我们一般称之为<strong>溢价域名</strong>。一般来说，溢价域名也会比普通域名价格更贵。当我们购买了域名之后，域名注册商会免费提供域名解析服务。当然，我们也可以要求使用其他厂商提供的免费或收费域名解析服务，甚至也可自行搭建域名解析服务。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 小提醒 </div> </div> <div class="content"> <p>  国内需具备一定资质才能在公网上搭建域名解析服务，否则会面临警告和阻断的风险。</p>



 </div> </div>
<p>  为了简便，我们一般把域名解析服务称为 DNS 服务。在操作系统中，53 端口被视为 DNS 服务的标准端口（TCP/UDP 服务），853 端口被视为 DNS over TLS 的标准端口（TCP 服务）。除此之外，DNS over HTTPS（TCP 服务）和 DNS over Quic（新协议，UDP 服务）的标准端口是 443。所以现有能够公开使用的 DNS 服务都采用了标准端口，比如国内著名的 114 DNS、阿里云 DNS、腾讯云 DNS、百度云 DNS 都是如此。如果想要了解更多开放可用的 DNS 服务可以查看 <a href="https://adguard-dns.io/kb/general/dns-providers/">这里</a>。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  DNS 按照功能上的不同可以分为 <strong>权威 DNS</strong> 和 <strong>递归 DNS</strong>。权威 DNS 负责对某个或多个子域名进行管理，注册商提供的域名解析服务就是这一类。递归 DNS 负责接收客户端的请求并将查询到的域名对应记录返回给客户端，也就是说它本身不对任何子域名进行管理，只转述别人告诉它的结果。</p>



 </div> </div>
<p>  当我们使用 DNS 时，它（这里指递归 DNS）会如下图所示按照域名系统的构成逐级进行查询。比如说，现在我们想访问 www.baidu.com：</p>

<ol>
  <li>客户端（我们）向递归 DNS 请求解析 www.baidu.com；</li>
  <li>递归 DNS 会先去问一下它的上游 DNS，如果不存在上游 DNS，它就只能去问 DNS 根服务器；</li>
  <li>DNS 根服务器并不知道具体的解析记录，但是会告诉递归 DNS 顶级域名 .com 的 DNS 服务器；</li>
  <li>递归 DNS 接着向 .com 的 DNS 服务器询问；</li>
  <li>结果 .com 的 DNS 服务器也不知道具体的解析记录，但是会告诉递归 DNS 二级域名 baidu.com 的 DNS 服务器；</li>
  <li>这样递归 DNS 才会去问域名 baidu.com 的权威 DNS；</li>
  <li>然后，baidu.com 权威 DNS 响应 www.baidu.com 对应的 A 记录（或者 AAAA 记录）是什么；</li>
  <li>最后，递归 DNS 将解析结果告诉客户端（我们）。</li>
</ol>

<p><img src="https://i.lisz.top/blog/hwyKGH.webp" alt="域名解析过程 DNS Resolution Process" /></p>

<p>  那么问题来了，<strong>一个 DNS 能否同时是权威 DNS 和递归 DNS 呢？</strong>实际上是不可能的，但是可以实现这种效果。如果我们把权威 DNS 隐藏在递归 DNS 的后面，那么对于顶级域名 DNS 来说，你指定的递归 DNS 就是它理解的权威 DNS。这里的隐藏指的是，当有请求询问递归 DNS 的权威解析记录时，递归 DNS 根据规则将请求转发给背后真正的权威 DNS。等待权威 DNS 返回解析记录后，递归 DNS 再把结果返回给请求方（其他递归 DNS 或者客户端）。</p>

<h3 id="私有域名解析">私有域名解析</h3>

<h4 id="必要性">必要性</h4>

<p>  以上谈到的都是公有域名的相关事情，为什么又要考虑私有域名解析呢？首先，公有域名和私有域名本质上可以没有区别，都是在域名注册商处购买的域名，也可以有所区别，即私有域名是未购买的或者是非 ICANN 支持的域名（比如 .lisz 后缀）。这样一来，我们将不再受<strong>域名是否注册</strong>的限制而应用在内部网络中。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  当然，我们应当避免使用 ICANN 支持的域名后缀且可注册的域名，毕竟可能以后会有人购买这个域名。</p>



 </div> </div>
<p>  其次，解析记录的<strong>内外分离</strong>需求。随着基础服务架构和应用架构的不断发展，越来越多像云计算、Kubernetes 这样需要采用域名解析来连通内部服务。如果我们直接采用一个权威 DNS 来解析这些记录，那就意味着所有人都可以通过查询来知道这些解析记录，甚至有些人就能大致猜出服务架构，这并不是很安全。出于安全上的考量，将同一个域名的解析记录进行内外分离能够在一定程度上提升安全。</p>

<p>  如参考资料中《内网域名系统的安全保密风险研究》所说，“随着内网规模的不断扩大，特别是国家电子政务内网的建成、扩展，在电子政务内网中构建国家级可信内网域名体系的需求越来越迫切，内网域名系统会成为内网的核心基础设施，其安全问题将会越来越被关注。”私有域名解析，即内网域名系统在内网安全中发挥着举足轻重的作用。</p>

<h4 id="用途">用途</h4>

<p>  笔者在实际使用 AWS、Azure、Oracle、阿里云、腾讯云、Ucloud 的过程中，也发现了私有域名解析的应用。举个例子，Oracle 云创建的每一台 VPS 都会有一个内部 FQDN（以 oraclecv.com 为后缀的多级域名）。当你在 VPS 上使用 dig 命令查询这个 FQDN 对应的 A 记录时，VPS 的内网 IP 会被返回。当你在自己的设备上使用 dig 命令查询时，返回为空。再举个例子，云计算厂商的 VPS 默认配置的是他们自家的镜像源，比如腾讯云 VPS 的默认镜像源域名为 mirrors.tencentyun.com，而这个域名在公网上是查不到解析记录的。可见，云计算厂商的架构上也在使用私有域名解析。</p>

<p>  当然，云计算厂商们也向用户提供依托于 VPC（私有网络）的私有域名解析服务，即该私有域名解析服务只有在同一 VPC 内的 VPS 可以使用。而我们又知道，VPC 是属于用户个人的，也就是说不同用户之间的私有域名解析服务完全互不干扰。</p>

<p>  在参考资料一中，阿里云列出了实际云服务中私有域名解析的四大应用场景：</p>

<ul>
  <li><strong>主机名管理</strong>：根据用途、机器信息语义化命名，对运维人员更友好。</li>
  <li><strong>内部调用 API</strong>：内部 API 用域名来访问，即使对应集群或者 IP 发生变化，也可以无感切换。</li>
  <li><strong>内部域名隐私保护</strong>：和上面笔者提到的必要性第二点一样，提升隐私保护。</li>
  <li><strong>私有地址反向解析</strong>：绑定后可以通过 host、traceroute 或其他操作直接识别访问 IP 的来源，便于运维人员排查问题。</li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  域名解析分为<strong>正向解析</strong>和<strong>反向解析</strong>，我们一般见过的“域名 → IP”的域名解析就是正向解析，而反向解析则是“IP → 域名”。一般来说，反向解析多用于邮件服务器的可信认证。将 IP 与 邮件服务器域名的正反向解析都绑定后，能够增强邮件服务器的可信度，降低被收信服务器判定为 <strong>垃圾 IP</strong> 发信的概率。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="方案一">方案一</h3>

<p>  内网私有域名解析实际上就是要在内网中搭建一台权威 DNS 和递归 DNS：权威 DNS 用于管理私有域名，递归 DNS 用于解析权威 DNS 记录以及正常的公网解析记录。当然，在公司网络或者机房集群网络中，一般会搭建权威 DNS 集群和递归 DNS 集群来提升可靠性和可用性。权威 DNS 集群通常是主从架构，主节点作为接受域名解析操作的主要接收方，从节点将实时同步主节点记录。当主节点发现故障时，从节点自动升级为主节点。并非所有的集群都是这样，但是这样更加能避免因主节点宕机后无法进行域名解析的更改操作。由于这与采用架设 DNS 服务的软件相关，这里就不作过多探讨。</p>

<p>  与权威 DNS 集群不同的是，内网递归 DNS 集群实际上一般会有两个节点暴露出来。这一点与公网中提供公网递归 DNS 服务是一样的。比如 114 DNS 会告诉大家要设置两个 DNS IP 地址，即 114.114.114.114 和 114.114.115.115。为什么要这样呢？主要还是因为通过冗余来提高可靠性和可用性。我们可能会简单地以为 114 DNS 就只有这两个 IP，但实际上它们的背后还有很多台递归 DNS 服务器。这两台服务器的作用并不是直接处理解析请求，而是为想要域名解析的客户端提供一个更加快和高效的方式来使用递归 DNS。类似于复杂 Web 系统中首先会在交换机上用网关进行优化，然后在服务器上利用 LVS 来负载均衡，之后再利用多个服务后台来分别处理相同的业务，最后再返回信息给用户。这两台递归 DNS 节点也起到了负载均衡的作用。</p>

<p>  当然，这两个 IP 也不是一般的 IP，而是使用了 Anycast 技术的 IP。也就是说，在互联网上会有多台服务器使用了这两个 IP，而当我们向这两个 IP 发起请求时，BGP 会根据客户端所处的地理位置和网络情况将 IP 定位到离客户端最近的两台服务器上。有一个比较客观的体验就是，当我们在全国不同地方 ping 这两个 IP 时，发现似乎延迟差不多且都很短。但是无论我们的骨干网建得多么好，因地理位置和跨网（电信、联通、移动、教育网）所带来的延迟也是无法避免的。唯一一个延迟都很短的可能解释就是响应请求的机器实际上并非同一位置的同两台，而是位于不同位置的不同两台。</p>

<h3 id="方案二">方案二</h3>

<p>  上面的方案考虑的问题比较多，也比较适合在大规模集群或内网中进行实践，但是在小集群中可能就有点过于庞大了，显得没有必要。其实，小集群或者小团队内网可以采用“合二为一”的方案，即递归 DNS 与权威 DNS 由一台服务器来同时提供。由于小集群内网私有域名解析和公有域名解析不需要接近于零的宕机率，所以完全可以最简化。当前最流行的免费解决方案可能就是 AdGuard Home 了。</p>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  AdGuard Home 是一款全网广告拦截与反跟踪软件。在您将其安装完毕后，它将保护您所有家用设备，同时您不再需要安装任何客户端软件。随着物联网与连接设备的兴起，掌控您自己的整个网络环境变得越来越重要。</p>



 </div> <div class="ref"> ------ AdGuard 主页 </div> </div>
<p>  AdGuard Home 之所以这么受到欢迎，主要是因为其丰富的功能和简单的可视化操作，对于管理员来说非常友好。而且，AdGuard Home 的部署也非常简单，支持多平台架构、多方式一键部署，比如 AdGuard Home 也能在 ARM 芯片上用 Docker 容器的方式一键部署。虽然 AdGuard Home 自带简单的解析记录重写，可以满足大部分常用的内网私有域名解析需求，但是像一些比较高级的解析记录可能就无法做到，比如 TXT 记录。尽管 TXT 记录在 <strong>IP</strong> 和<strong>域名</strong>的相互映射中并不起到作用，但是 TXT 记录可以填写比较长的内容，非常适合用来验证对于域名的管理权限，像 HTTPS 证书的申请一般就是采用新增 TXT 记录的方式验证，还有 Gitlab Page 的自定义域名绑定也是如此。所以为了提供比较完整的域名解析服务，这里还是建议增加一个权威 DNS，可以采用 PowerDNS + PowerDNS Admin（交互界面）或者 Bind9 等。</p>

<p>  考虑到友好的交互界面更容易上手使用，这里只介绍 AdGuard Home + PowerDNS 的方案。需要提前准备的环境有：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="adguard-home">AdGuard Home</h3>

<p>  由于 AdGuard Home 官方已经提供了多平台架构的 Docker 镜像，我们直接使用即可，docker-compose.yml 文件如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">adgurad</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">adguard/adguardhome</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">53:53/tcp</span>
      <span class="pi">-</span> <span class="s">53:53/udp</span>
      <span class="pi">-</span> <span class="s">80:80/tcp</span>
      <span class="pi">-</span> <span class="s">443:443/tcp</span>
      <span class="pi">-</span> <span class="s">3000:3000/tcp</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./work:/opt/adguardhome/work</span>
      <span class="pi">-</span> <span class="s">./conf:/opt/adguardhome/conf</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 AdGuard Home 实例。</p>

<h4 id="初始化">初始化</h4>

<p>  使用浏览器访问 <a href="http://localhost:3000">http://localhost:3000</a> 进行实例初始化设置，如下所示根据页面提示设置好用户名和密码。</p>

<p><img src="https://i.lisz.top/blog/PreFoj.webp" alt="初始化 AdGuard Home Initial" /></p>

<p><img src="https://i.lisz.top/blog/7LHDlg.webp" alt="确认端口 Check ports" /></p>

<p><img src="https://i.lisz.top/blog/qjTNW8.webp" alt="设置管理员 Set Admin" /></p>

<p><img src="https://i.lisz.top/blog/yLkLc4.webp" alt="客户端配置指南 Client setting guideline" /></p>

<p><img src="https://i.lisz.top/blog/buQ6LT.webp" alt="完成初始化 Finish the initialization" /></p>

<p>  初始化成功后，页面会自动跳转到登录界面 <a href="http://localhost">http://localhost</a>（80 端口）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于在实际环境中，我们不一定是在本机启动该实例，所以可能需要使用服务器的 IP 来替代 localhost 访问。另外，如果原来就有 Nginx 或其他服务占用了 80 端口，我们在配置端口映射的时候可能就会设置到另外一个端口，因此自动跳转到的页面并非是 AdGuard Home 的首页。我们需要使用 IP + 映射 80 的端口来定位到首页。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/Wwb5At.webp" alt="登录页面 AdGuard Home Login" /></p>

<h4 id="私有域名转发">私有域名转发</h4>

<p>  由于接下来我们将要用 PowerDNS 来管理权威域名解析，所以需要设置私有域名规则，即当 AdGuard Home 收到关于内网自定义权威域名的请求时，就会把请求转给 PowerDNS。这在 AdGuard Home 中也是比较容易就能设置好的，如下图所示，添加一行规则使得匹配的所有二级域名请求转发给 PowerDNS。</p>

<p><img src="https://i.lisz.top/blog/4GMZAO.webp" alt="配置转发 Redirect to Authroized DNS" /></p>

<h3 id="powerdns">PowerDNS</h3>

<p>  虽然 PowerDNS 和 PowerDNS-Admin 官方都提供了 Docker 镜像，但是搭配起来用还是有点莫名其妙的问题。为了更加简单，笔者参考官方自行构建了 <code class="language-plaintext highlighter-rouge">zhonger/pdns</code> 和 <code class="language-plaintext highlighter-rouge">zhonger/powerdns-admin</code> 两个 Docker 镜像，搭配使用更加便捷可用。如果想要了解更多，可以查看 <a href="../docker/powerdns.html">《Docker 镜像构建之 PowerDNS 篇》</a>。
  </p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">pdns</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/pdns:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/tcp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/udp"</span>
      <span class="c1"># - "8081:8081"</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">PDNS_launch=gsqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_gsqlite3_database=/var/lib/powerdns/pdns.sqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_address=0.0.0.0</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_allow_from=127.0.0.1,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16</span>
      <span class="pi">-</span> <span class="s">PDNS_api=yes</span>
      <span class="pi">-</span> <span class="s">PDNS_api_key={Random Long String}</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./powerdns:/var/lib/powerdns</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:latest</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">MYSQL_ALLOW_EMPTY_PASSWORD=yes</span>
      <span class="pi">-</span> <span class="s">MYSQL_DATABASE=powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">MYSQL_USER=pdns</span> 
      <span class="pi">-</span> <span class="s">MYSQL_PASSWORD=mypdns</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./pda-mysql:/var/lib/mysql</span>

  <span class="na">app</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/powerdns-admin:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">pdns</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:80"</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s">json-file</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s">50m</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">SQLALCHEMY_DATABASE_URI=mysql://pdns:mypdns@db/powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">GUNICORN_TIMEOUT=60</span>
      <span class="pi">-</span> <span class="s">GUNICORN_WORKERS=2</span>
      <span class="pi">-</span> <span class="s">GUNICORN_LOGLEVEL=DEBUG</span>
      <span class="pi">-</span> <span class="s">OFFLINE_MODE=False</span> <span class="c1"># True for offline, False for external resources </span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 PowerDNS 和 PowerDNS-Admin 实例。</p>

<h4 id="初始化用户">初始化用户</h4>

<p>  PowerDNS-Admin 本身不会自动初始化管理员用户，而是将注册的第一个用户认定为管理员用户。使用浏览器访问 PowerDNS-Admin 登录页面 <a href="http://localhost:8080">http://localhost:8080</a>，如下图所示点击 Create an account 链接跳转到注册页。</p>

<p><img src="https://i.lisz.top/blog/9NDNpc.webp" alt="PowerDNS-Admin 登录页 Login page" /></p>

<p>  如下图所示，填写姓名、邮箱、用户名和密码，点击 Register 按钮即可完成注册。这里，PowerDNS-Admin 默认采用邮箱的 Gavatar 头像作为用户头像。</p>

<p><img src="https://i.lisz.top/blog/TJqhDE.webp" alt="PowerDNS-Admin 注册页 Register page" /></p>

<h4 id="初始化配置">初始化配置</h4>

<p>  注册和登录后，会跳转到 PDNS 配置页面。这里由于 PDNS 和 PowerDNS-Admin 实例是在同一个网络中，可以直接使用 pdns 来代替 PDNS 实例的 IP 地址。PDNS API KEY 则是刚才启动时设置的那一长串字符（PDNS_api_key）。PDNS VERSION 最好是与 PDNS 实际使用的一致，不过不一致也不会有什么事。<code class="language-plaintext highlighter-rouge">zhonger/pdns:latest</code> 目前实际是 4.6 版本，这里默认填的 4.1.1 也可以。然后点击 Update 按钮保存配置。</p>

<p><img src="https://i.lisz.top/blog/CJ1Wl1.webp" alt="CJ1Wl1" /></p>

<p>  保存配置成功后，如果填写信息无误，点击侧边导航中的 PDNS 就可以看到 PDNS 的各项配置信息。如果填写有误，则没有任何信息。</p>

<p><img src="https://i.lisz.top/blog/UdkXGi.webp" alt="UdkXGi" /></p>

<h4 id="新增域名">新增域名</h4>

<p>  接下来就可以点击侧边导航栏中的 New Domain 来新增私有域名 home.lisz。如下图所示，我们需要填写的是域名，需要选择的是域名模板，一般 basic_template_1 即可。之后点击 Submit 按钮提交。</p>

<p><img src="https://i.lisz.top/blog/nMyRKR.webp" alt="nMyRKR" /></p>

<h4 id="新增解析记录">新增解析记录</h4>

<p>  新增域名成功后，我们就可以在 Dashboard 里面的域名列表看到 home.lisz 了。点击即可进入域名解析。</p>

<p><img src="https://i.lisz.top/blog/naFe9s.webp" alt="naFe9s" /></p>

<p>  这里我们以一个 CNAME 和 A 记录为例，来尝试新增解析记录。如下图所示，点击左上角的 Add Record 添加记录，完成后点击右上角的 Apply Changes 来提交解析记录到 PDNS。</p>

<p><img src="https://i.lisz.top/blog/SmwtCT.webp" alt="SmwtCT" /></p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  实际域名解析时我们一般会采用 CNAME 和 A 记录联合使用的方式，这样相当于在 DNS 解析层面就有负载均衡了。A 记录是域名与 IP 的关系，这就意味着同一个域名可以有多个 A 记录。CNAME 记录是域名与域名的关系，而两个域名分别是为了不同的目的，前一个是为了给大家使用的，后一个是为了运维人员使用的。当存在 CNAME → A 时，客户端会根据网络情况来判断使用哪一条 A 记录对应的 IP，从而提升用户体验。</p>



 </div> </div>
<h3 id="验证">验证</h3>

<h4 id="验证权威-dns-是否正常">验证权威 DNS 是否正常</h4>

<p>  如下所示向 AdGuard Home 询问私有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>─<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 47193
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.home.lisz.                 IN      A

;; ANSWER SECTION:
www.home.lisz.          60      IN      CNAME   www101.home.lisz.
www101.home.lisz.       60      IN      A       192.168.1.1

;; Query time: 20 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:05:15 JST 2022
;; MSG SIZE  rcvd: 79
</span></code></pre></div></div>

<h4 id="验证递归-dns-是否正常">验证递归 DNS 是否正常</h4>

<p>  如下所示，向 AdGuard Home 询问公有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 8988
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.baidu.com.                 IN      A

;; ANSWER SECTION:
www.baidu.com.          831     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       28      IN      CNAME   www.wshifen.com.
www.wshifen.com.        192     IN      A       45.113.192.102
www.wshifen.com.        192     IN      A       45.113.192.101

;; Query time: 244 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:06:03 JST 2022
;; MSG SIZE  rcvd: 127
</span></code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://help.aliyun.com/document_detail/64623.html">阿里云帮助中心 - 云解析 - 应用场景</a></li>
  <li><a href="https://cloud.tencent.com/document/product/1338/50547">腾讯云文档中心 - 子域名递归解析说明</a></li>
  <li><a href="https://support.huaweicloud.com/dns_faq/dns_faq_040.html">华为云文档 - 如何设置内网域名既支持内网解析，也支持公网解析？</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1123748">公司内网搭建代理 DNS 使用内网域名代替 ip 地址</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1821030">一文搞懂 DNS 基础知识，收藏起来有备无患~</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1691018">搞它！！！深入了解DNS域名解析服务，教你搭建一个属于自己的DNS服务器（正向解析、反向解析、泛域名解析、邮件交换解析、别名解析、分离解析，主从结构解析）</a></li>
  <li><a href="https://www.modb.pro/db/433331">推荐一款 Private DNS 服务</a></li>
  <li><a href="https://sspai.com/post/63088">AdGuard Home 安装及使用指北</a></li>
  <li><a href="http://www.gjbmj.gov.cn/n1/2021/0722/c411145-32166624.html">内网域名系统的安全保密风险研究</a></li>
  <li><a href="https://computingforgeeks.com/running-powerdns-and-powerdns-admin-in-docker-containers/">Running PowerDNS and PowerDNS Admin in Docker Containers</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="域名解析" /><category term="DNS" /><category term="私有域名" /><category term="内网" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">内网 HTTPS 可信证书</title><link href="https://lisz.me/tech/webmaster/ca-ssl.html" rel="alternate" type="text/html" title="内网 HTTPS 可信证书" /><published>2022-08-03T11:30:00+09:00</published><updated>2022-08-03T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/ca-ssl</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ca-ssl.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="内网-https-化的必要性">内网 HTTPS 化的必要性</h3>

<p>  开发团队或者公司内部一般会采用内外网隔离、上网行为过滤等措施，比较可靠地保证了内部设备无法被外部网络所侦测，从而可能认为 HTTP 内网站点是一个相对安全的存在。即使在 HTTPS 证书如此盛行的今天，也还暂时不考虑内部站点的 HTTPS 化。<code class="language-plaintext highlighter-rouge">IP + Port</code> 或者 <code class="language-plaintext highlighter-rouge">http://本地域名</code> 的访问方式依旧是座上宾。当然，如果考虑到购买 HTTPS 证书的成本或者团队内网站点采用 Letsencrypt 等免费证书过于麻烦（只能采用 DNS 验证的方式每三个月申请一次新证书），那么自签名 SSL 证书则成为首选了。不过，如果为每一个内网站点都生成一个 SSL 证书，然后让大家都手动把 HTTPS 标为可信，那么当面临大量内网站点时，大家可能要被搞崩溃。更为可行的办法是，<strong>生成一个内网用的根证书，只标记该根证书可信</strong>。</p>

<h3 id="根证书">根证书</h3>

<p>  与其相信别人根证书生成的 SSL 证书，不如相信自己根证书生成的。我们的目的毕竟不是要任何一个人都把我们自签名的证书标为可信，只要在内网内使用内网站点的设备能够信任即可。而且成为一个受到公众信任的根证书是非常困难的一件事，即使经过几十年可能也没有办法做到。如今现有的根证书实际上有限，像我们平常熟悉的 Letsencrypt、ZeroSSL、Cloudflare 等等并不是根证书而是中间证书。有点类似总代理和分代理的感觉，根证书在业界具有广泛的公信力，但是让根证书去给个人或者企业生成证书可能有点忙不过来。于是根证书生成若干个中间证书，再由中间证书来为个人或者企业生成实际的证书。</p>

<p>  一般来说，操作系统或浏览器的产商会预置国际上认可的根证书。如下所示，为 Mac OS 上预置的根证书列表。</p>

<p><img src="https://i.lisz.top/blog/SfWsIJ.webp" alt="Mac OS 预置根证书 Root Certificate" /></p>

<h2 id="实践">实践</h2>

<p>  话不多说，让我们来实践一下如何生成自己的根证书和签发 SSL 证书吧。</p>

<h3 id="生成根证书">生成根证书</h3>

<h4 id="安装-openssl-可选">安装 OpenSSL (可选)</h4>

<p>  此处只考虑 Mac OS 和 Ubuntu，其他环境如何安装可以自行搜索。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Mac OS</span>
brew <span class="nb">install </span>openssl

<span class="c"># Ubuntu</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> openssl
</code></pre></div></div>

<h4 id="创建根密钥">创建根密钥</h4>

<p>  使用以下命令创建根密钥 <code class="language-plaintext highlighter-rouge">zhonger-key.pem</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl genrsa <span class="nt">-out</span> zhonger-key.pem 4096
</code></pre></div></div>

<h4 id="创建根证书并签名">创建根证书并签名</h4>

<p>  使用刚创建好的根密钥 <code class="language-plaintext highlighter-rouge">zhonger-key.pem</code> 生成根证书，并输入相关信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-new</span> <span class="nt">-x509</span> <span class="nt">-days</span> 3600 <span class="nt">-key</span> zhonger-key.pem <span class="nt">-out</span> zhongerca.pem
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>openssl req <span class="nt">-new</span> <span class="nt">-x509</span> <span class="nt">-days</span> 3600 <span class="nt">-key</span> zhonger-key.pem <span class="nt">-out</span> zhongerca.pem 
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">'.'</span>, the field will be left blank.
<span class="nt">-----</span>
Country Name <span class="o">(</span>2 letter code<span class="o">)</span> <span class="o">[</span>AU]:CN
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[</span>Some-State]:Shanghai
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:Shanghai
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[</span>Internet Widgits Pty Ltd]:zhonger
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:zhonger
Common Name <span class="o">(</span>e.g. server FQDN or YOUR name<span class="o">)</span> <span class="o">[]</span>:lisz.me
Email Address <span class="o">[]</span>:contact@lisz.me
</code></pre></div></div>

<h4 id="验证根证书">验证根证书</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>─<span class="nv">$ </span>openssl x509 <span class="nt">-text</span> <span class="nt">-in</span> zhongerca.pem <span class="nt">-noout</span>
Certificate:
    Data:
        Version: 3 <span class="o">(</span>0x2<span class="o">)</span>
        Serial Number:
            44:48:03:56:ff:15:57:03:00:34:1f:85:61:ca:f7:7a:1e:4f:38:8f
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C <span class="o">=</span> CN, ST <span class="o">=</span> Shanghai, L <span class="o">=</span> Shanghai, O <span class="o">=</span> zhonger, OU <span class="o">=</span> zhonger, CN <span class="o">=</span> lisz.me, emailAddress <span class="o">=</span> contact@lisz.me
        Validity
            Not Before: Aug  3 05:25:47 2022 GMT
            Not After : Jun 11 05:25:47 2032 GMT
        Subject: C <span class="o">=</span> CN, ST <span class="o">=</span> Shanghai, L <span class="o">=</span> Shanghai, O <span class="o">=</span> zhonger, OU <span class="o">=</span> zhonger, CN <span class="o">=</span> lisz.me, emailAddress <span class="o">=</span> contact@lisz.me
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: <span class="o">(</span>4096 bit<span class="o">)</span>
                Modulus:
                    00:b2:d1:47:73:8a:83:48:e3:47:1a:41:01:f6:63:
                    69:43:39:71:eb:2b:74:be:dc:63:f3:df:79:66:ee:
                    00:30:65:b3:4f:7e:58:88:00:13:09:e6:4f:74:57:
                    fa:a3:56:24:cd:b6:1f:53:25:77:98:bf:9f:45:64:
                    7c:6c:04:23:c4:8f:0f:bf:2e:b3:d1:2e:4c:05:4d:
                    4c:e6:65:54:ad:0c:35:b7:d9:c8:74:97:19:c7:a5:
                    <span class="nb">cd</span>:9a:a4:73:37:13:71:80:34:7c:bc:b3:41:5a:34:
                    bb:16:82:44:18:a1:0a:a5:f5:f1:07:ca:8d:b3:9a:
                    ef:74:fb:a0:6c:72:4a:53:5c:59:74:6f:aa:c7:bc:
                    48:26:af:1b:70:f3:5f:7f:c7:df:8d:e5:da:e4:f4:
                    d2:fa:90:d3:e2:67:e1:9a:df:c7:c4:c7:53:6f:62:
                    25:ed:ff:0a:17:cf:8d:4d:84:6b:38:cb:49:e7:3d:
                    c5:2b:15:76:e6:eb:cc:17:94:40:20:7d:ee:8c:36:
                    6d:cf:9c:d7:1f:a6:41:20:9d:45:cd:57:8f:a8:61:
                    f8:8b:e9:31:6a:a9:96:c1:db:57:64:0b:09:da:ca:
                    b3:07:d9:55:ed:fe:69:a0:9c:78:5b:59:a5:7b:a1:
                    2b:4d:68:22:b4:7f:db:c6:c1:12:ee:eb:9b:29:38:
                    ae:7b:4c:0d:2a:ab:33:3f:af:a8:7b:ca:89:2c:62:
                    0f:a8:ef:89:60:9e:fd:a2:df:36:6d:70:82:8b:fa:
                    b3:ee:79:7e:fd:3f:e7:90:84:58:85:7e:7e:69:07:
                    1e:50:05:0b:87:4d:66:e4:17:6b:c2:97:03:48:e4:
                    7d:08:b4:81:a6:05:80:60:5c:eb:8d:53:db:7c:62:
                    a8:6d:a7:75:f1:56:b6:d9:0d:6b:3b:be:8b:72:39:
                    8d:e7:2d:77:74:e3:4d:a1:fd:8b:44:f9:ee:fd:0d:
                    04:ec:6a:fc:f3:d2:15:fc:18:ff:7d:33:44:2b:6d:
                    7f:3c:33:21:e1:d8:5f:08:fa:53:fd:26:fb:6e:74:
                    d7:4b:51:62:d3:15:1b:3b:44:78:78:9b:91:c7:ba:
                    82:2b:12:d7:b2:83:0a:39:ec:5e:a9:a9:c1:04:a6:
                    2e:64:a5:ea:15:c3:85:e9:ac:38:6b:22:eb:3b:08:
                    b8:0a:31:10:df:45:1d:76:81:e0:0f:88:e4:00:ef:
                    6e:90:59:8c:d8:36:e9:77:bf:4a:0e:3d:03:02:4d:
                    5d:a7:90:16:81:11:e0:81:bb:e0:18:a3:bb:dc:8d:
                    7d:c6:cf:c6:0b:d2:80:53:ea:d0:27:e6:6a:cc:8e:
                    2b:b3:72:e4:ab:84:88:e2:e9:a5:bb:72:9a:c6:a2:
                    0e:5a:cb
                Exponent: 65537 <span class="o">(</span>0x10001<span class="o">)</span>
        X509v3 extensions:
            X509v3 Subject Key Identifier:
                EE:EF:AE:DB:73:45:9A:6E:82:00:3C:A7:05:0D:60:E4:20:81:3B:02
            X509v3 Authority Key Identifier:
                keyid:EE:EF:AE:DB:73:45:9A:6E:82:00:3C:A7:05:0D:60:E4:20:81:3B:02

            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         98:cf:f4:23:61:d2:2a:64:ce:51:57:1d:fb:61:2f:34:68:86:
         c9:02:5a:c8:97:80:58:c1:7f:04:e1:97:f5:0b:35:d5:c4:91:
         fa:98:8c:73:16:43:b3:af:63:af:2c:30:cf:6a:8e:10:99:bc:
         fd:3d:84:c7:3d:01:e0:8d:8d:d8:76:74:12:69:1a:f5:e5:ec:
         ef:eb:dc:f8:08:0c:c7:03:19:de:c5:e8:c7:4e:b4:5c:67:39:
         9f:33:11:6f:29:e1:03:d8:4e:70:09:7a:69:bd:3a:db:96:71:
         2b:38:c4:46:87:f6:59:34:f9:dc:5c:6d:34:9a:ba:ea:36:13:
         d8:e3:e3:91:ea:70:3b:ea:39:cb:fc:fd:08:0f:73:e5:16:c3:
         0d:9a:62:20:3f:5a:28:90:e6:b2:65:23:a1:ba:d0:77:c0:8e:
         16:51:55:44:f6:4b:16:b9:a1:97:bc:f8:95:70:af:a6:d4:07:
         27:21:96:78:0b:58:18:51:45:a6:ea:07:c8:09:1b:ad:f3:e1:
         16:be:64:bf:8f:b7:4c:d1:e6:d0:c6:c1:db:cd:3d:e9:88:ec:
         e2:87:ff:bd:c3:7b:31:23:00:c3:71:53:90:68:46:99:7d:1d:
         e1:78:26:76:6a:41:8d:9e:9a:55:97:63:a5:df:86:fc:03:9b:
         28:13:55:ff:74:f2:56:d9:20:02:e8:c9:90:4f:b1:5d:1b:66:
         57:4e:f7:c6:50:4f:c9:8b:ff:39:a1:9e:b4:ee:2b:8a:bf:46:
         b4:3e:65:cb:34:12:73:bc:ae:ba:a5:41:20:d4:b9:c5:c4:da:
         89:bd:50:83:27:71:7a:9f:2c:3e:cf:de:db:13:b1:39:cf:4a:
         39:62:68:b3:f5:dc:49:44:3e:c1:cf:0c:a4:9a:4b:cb:5e:ec:
         aa:33:a5:57:ae:c6:f3:4f:69:01:d1:6a:a7:12:90:88:05:e9:
         18:d8:3a:a7:89:70:55:ab:18:ba:4f:28:74:5b:5f:21:8e:66:
         bc:ae:ff:1b:c7:ed:42:73:c1:1c:a4:97:f2:e6:c7:5a:8f:a8:
         44:a5:ed:b7:76:ac:cf:40:f0:a4:4f:22:03:d0:db:db:6e:18:
         32:33:4a:79:c2:bb:98:20:71:03:a7:9c:ea:4e:7e:0a:28:79:
         30:f3:3f:ef:03:b2:e0:00:b0:2b:71:27:8b:fc:f9:a0:e5:b9:
         a0:9e:6f:93:3a:f3:d3:1c:87:8a:b7:2d:5c:38:ab:f9:ff:39:
         8b:52:a5:9a:95:2f:a0:82:b9:b6:f8:9a:c3:e3:55:dd:4b:b5:
         e4:e3:fb:f8:8b:10:50:f8:42:7d:03:fe:72:40:c1:d3:f7:26:
         a7:f9:de:b9:9d:30:26:94
</code></pre></div></div>

<h4 id="安装根证书">安装根证书</h4>

<p>  首次打开刚刚生成的根证书 <code class="language-plaintext highlighter-rouge">zhongerca.pem</code> 会像下面这样显示“此根证书不被信任”，我们可以将下面的使用此证书时的<strong>使用系统默认</strong>改成<strong>始终信任</strong>，然后输入操作系统用户密码即可保存修改。改完之后再次打开如下下图所示，显示“此证书已标记为受此账户信任”。这样一来，由该根证书签发的证书就都会被信任了。</p>

<p><img src="https://i.lisz.top/blog/gkni75.webp" alt="打开根证书 Open Root Certificate file" /></p>

<p><img src="https://i.lisz.top/blog/zJ5dNm.webp" alt="始终信任根证书 Always trust Root Certificate file" /></p>

<h3 id="签发证书">签发证书</h3>

<p>  这里我们打算采用 <a href="https://github.com/jsha/minica">jsha/minica</a> 来辅助快速签发证书。</p>

<h4 id="安装-minica">安装 minica</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Mac OS</span>
brew <span class="nb">install </span>minica

<span class="c"># Other OS</span>
go <span class="nb">install </span>github.com/jsha/minica@latest
</code></pre></div></div>

<h4 id="签发-ssl-证书">签发 SSL 证书</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 给域名签发 SSL 证书</span>
minica <span class="nt">-ca-cert</span> zhongerca.pem <span class="nt">-ca-key</span> zhonger-key.pem <span class="nt">--domains</span> <span class="s2">"sni.lisz.me,zhonger.io,*.zhonger.io"</span>

<span class="c"># 给 IP 签发 SSL 证书</span>
minica <span class="nt">-ca-cert</span> zhongerca.pem <span class="nt">-ca-key</span> zhonger-key.pem <span class="nt">--ip-addresses</span> <span class="s2">"127.0.0.1"</span>
</code></pre></div></div>

<p>  minica 提供了非常简单的方式来签发 SSL 证书，比如说指定根证书和根密钥、指定单个或多个域名、通配符域名以及 IP。minica 签发的证书默认时效为 2年30天（相信可能是考虑到 30天 的缓冲期所以多了一个月）。这里，我们模仿了 Cloudflare 的 SSL 证书生成方式，第一个域名是 <code class="language-plaintext highlighter-rouge">sni.根证书域名</code>，第二个开始才是真正想要签发的域名。由于 minica 默认会将第一个域名作为文件夹的名字生成 SSL 证书 <code class="language-plaintext highlighter-rouge">cert.pem</code> 和 <code class="language-plaintext highlighter-rouge">key.pem</code> 文件，如果采取这种方式在同一目录执行以上签发命令势必会使得旧文件被覆盖，因此推荐像 Certonly 或者 acme.sh 那样修改目录名来区分。</p>

<h2 id="其他">其他</h2>

<h3 id="mkcert">mkcert</h3>

<p>  除了 minica 之外，<a href="https://github.com/FiloSottile/mkcert">FiloSottile/mkcert</a> 提供的 mkcert 工具也非常简单方便。mkcert 会自行生成根证书，然后签发证书。个人觉得，相比 minica 而言，mkcert 更适合个人本地开发 HTTPS 化，而非团队内网 HTTPS 化。</p>

<h3 id="根证书被伪造">根证书被伪造</h3>

<p>  自生成根证书比较令人担心的地方可能就是任何人都可以用同样的方法伪造出相似的根证书。实际上，根证书是独一无二的，即使所有的信息都设置成一样，还是两个根证书。我们需要做的是:</p>

<ul>
  <li>保护好根证书密钥，因为采用同一个密钥是可以生成比较相似的根证书的。当然两个根证书的<strong>序列 ID</strong>、<strong>有效时间</strong>是不会完全一样的。如果密钥不同，自然两个根证书的密钥 ID 也不会相同。</li>
  <li>告诉用户真的根证书是什么样的（序列 ID、密钥 ID、有效时间等）、应该从哪里下载到。这里需要在内网建立一个用于提供下载根证书的站点，而这个站点的SSL 证书最好采用购买的或申请的证书。也就是说，从可靠站点下载的内网 HTTPS 化根证书也是可靠的。</li>
</ul>

<p>  如下所示，是上面生成的根证书和签发的 SSL 证书的密钥 ID 对比。可以看到，两者完全一样，即可信任的 SSL 证书。</p>

<p><img src="https://i.lisz.top/blog/9ieYYm.webp" alt="根证书密钥 ID Root Certificate Key ID" /></p>

<p><img src="https://i.lisz.top/blog/sMYzVn.webp" alt="SSL 证书密钥 ID the Key ID in SSL Certificate" /></p>

<h3 id="其他平台安装根证书">其他平台安装根证书</h3>

<p>  上面已经提到了在 Mac OS 中如何安装根证书，其他平台比如 Windows、Linux、Android、IOS 等也是可以按照类似的方式，略微有些差别。考虑到 Windows 和 Linux 桌面版安装根证书的步骤几乎与 Mac OS 一样就不再赘述，这里主要讲一下 Linux Server、Android、IOS 平台的安装方法。</p>

<h4 id="linux-server">Linux Server</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp </span>zhongerca.pem /usr/local/share/ca-certificates/zhongerca.pem
<span class="nb">sudo </span>update-ca-certificates
</code></pre></div></div>

<h4 id="android-或-harmonyos">Android 或 HarmonyOS</h4>

<p>  以华为鸿蒙系统（HarmonyOS）为例，首先下载根证书到设备上，然后在 <strong>设置 &gt; 安全 &gt; 更多安全设置 &gt; 加密和凭据 &gt; 从存储设备上安装</strong> 中选择已下载的根证书完成安装。安装完成之后可以在同级别的 <strong>受信任的凭据 &gt; 用户</strong> 下面看到安装好的根证书。</p>

<h4 id="ios-或-ipad-os">IOS 或 iPad OS</h4>

<p>  首先下载根证书到设备上，在<strong>文件</strong>中点击打开（会自动跳转到 <strong>设置 &gt; 通用 &gt; VPN与设备管理</strong>）。可以在 <strong>配置描述文件</strong> 列表中看到根证书，点击进去<strong>输入密码并验证</strong>即可。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://cloud.tencent.com/developer/article/1458151">根证书和中间证书的区别</a></li>
  <li><a href="https://docs.microsoft.com/zh-cn/azure/application-gateway/self-signed-certificates">使用自定义根 CA 生成 Azure 应用程序网关自签名证书</a></li>
  <li><a href="https://qiita.com/k_kind/items/b87777efa3d29dcc4467">開発環境を https 化する mkcert の仕組み</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/379501905">mkcert 使用指南：如何快速创建自签名 SSL 证书</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="CA" /><category term="SSL" /><category term="证书" /><category term="内网" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 Nextcloud 篇</title><link href="https://lisz.me/tech/webmaster/ldap-nextcloud.html" rel="alternate" type="text/html" title="LDAP 集成之 Nextcloud 篇" /><published>2022-06-24T14:40:00+09:00</published><updated>2022-06-24T14:40:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-nextcloud</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-nextcloud.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="nextcloud-vs-owncloud">Nextcloud vs ownCloud</h3>

<p>  <a href="https://nextcloud.com">Nextcloud</a> 是一款非常适合个人或者团队使用的开源网盘软件，也有一款和其名字非常相似的 <a href="https://owncloud.com">ownCloud</a>。实际上这两款开源网盘是出自一个人之手，只不过在发展的过程中（2016年），ownCloud 团队内部产生了一些意见分歧，造成了核心开发人员出走创建了 Nextcloud。与 ownCloud 相比，Nextcloud 更加在乎宽广的功能多样性以及安全性，比如说视频会议、在线协作、提供对密码暴力破解的保护、限制密码错误登录的次数等。ownCloud 中可能也有这些功能，但并不包含在开源版本中，而是需要企业订阅版本才能享受这些功能。从这些看来，Nextcloud 似乎更加适合个人或团队使用。</p>

<p>  据笔者所知，国内 F 搜团队所提供的网盘文档-<a href="https:/fdocs.cn">F 文档</a> 实际上就是用 Nextcloud 搭建的。其提供的在线文档编辑采用的是开源的 <a href="https://www.onlyoffice.com">OnlyOffice</a>。</p>

<h3 id="nextcloud-vs-seafile">Nextcloud vs Seafile</h3>

<p>  除了 Nextcloud，国内也有一款也比较好用的开源网盘 <a href="https://www.seafile.com">Seafile</a>。Nextcloud 与 Seafile 虽然都是网盘，但是关注点不大一样。正如上面讲到的 Nextcloud 更在乎协作、功能多样化，而 Seafile 则更在乎稳定和安全。举个例子，Nextcloud 如果不设置服务端加密，所有的文件都会直接存在文件系统中。如果可以访问服务器的文件系统，那么意味着无须任何用户自身的许可就可以查看所有文件。Seafile 默认就将所有文件都分成小块存储，这样一来你是无法直接通过服务器的文件系统读取文件内容的。当然，这样分块存储也有一个好处，在客户端设置同步时会分块进行增量同步，提升了同步的速度和可靠性。不至于一个几个 G 的大文件传到一半中断后又要从头开始上传。不过，这样也有一个比较明显的坏处，如果不借助 Seafile 或其支持团队的帮助，无法自行从分块数据恢复原始文件内容。</p>

<h3 id="ldap-认证集成">LDAP 认证集成</h3>

<p>  从 Nextcloud、ownCloud、Seafile 的官网来看，三者都支持 LDAP/AD 认证集成，但实际上 Seafile 是需要专业版订阅才能有这个功能的，包括 Office 文件预览和编辑、全文检索、断点续传等功能也是需要专业版订阅的。Nextcloud 和 ownCloud 都在开源版本提供了 LDAP 认证集成功能。所以这里也不考虑 Seafile，只以 Nextcloud 为例介绍 LDAP 集成到网盘中。</p>

<h2 id="实践">实践</h2>

<p>  由于之前笔者也曾写过<a href="../docker/nextcloud.html">《Nextcloud 搭建自己的云盘》</a>和<a href="nextcloud-upgrade.html">《Nextcloud 升级那些事儿》</a>两篇文章介绍如何安装和升级 Nextcloud ，所以这里就不再对此进行赘述了。当前开始的环境即是已正常运行的 Nextcloud 实例。</p>

<h3 id="启用-ldap-插件">启用 LDAP 插件</h3>

<p>  在 Nextcloud 的<strong>应用捆绑包</strong>的<strong>企业捆绑包</strong>里就有我们想要用的 LDAP 认证集成插件，点击右侧<strong>启用</strong>按钮即可正常启用。</p>

<p><img src="https://i.lisz.top/blog/nFyWzS.webp" alt="nFyWzS" /></p>

<h3 id="配置-ldap-连接">配置 LDAP 连接</h3>

<p>  在启用 LDAP 插件后，我们就可以在管理员的设置中看见相应的选项。如下图所示，点击用户头像弹出菜单中的<strong>设置</strong>链接。</p>

<p><img src="https://i.lisz.top/blog/8FCrL0.webp" alt="8FCrL0" /></p>

<p>  由于这个设置会同时包含个人用户设置和管理员设置，可以将左侧的导航栏往下拉，看到<strong>管理</strong>中的 <strong>LDAP/AD 集成</strong> 点击进入。</p>

<p><img src="https://i.lisz.top/blog/WiwcTt.webp" alt="WiwcTt" /></p>

<p>  下面是 LDAP/AD 集成的基本设置，主要填写四个信息：LDAP 服务器地址、LDAP 管理员 DN、LDAP 管理员密码、查询基础 DN。由于此处填写的是非真实信息，所以下面会显示<strong>配置错误</strong>的提示。如果填写的 LDAP 信息无误，会自动变成<strong>配置成功</strong>的提示。然后点击<strong>继续</strong>按钮，后面的设置可以保留默认选项即可。当然如果 LDAP 服务与一般的设置有些不同，也要根据实际情况对后面的用户、登录属性、群组信息进行调整，这里就不一一介绍了。</p>

<p><img src="https://i.lisz.top/blog/Lr00tl.webp" alt="Lr00tl" /></p>

<p>  以上配置均完成之后，即可退出登录即可使用 LDAP 账户和密码登录验证是否配置成功（登录界面不会有任何改变）。</p>

<h3 id="其他">其他</h3>

<p>  可能和 Gitlab 的情况有点类似，Nextcloud 本身就有用户体系，然后才接入的 LDAP 认证。其实，我们还是希望 LDAP 用户和原有用户能够自动识别成同一用户，无感完成合并。这里 Nextcloud 和 Gitlab 一样都是凭借着邮箱来判断的。当 LDAP 用户邮箱与 Nextcloud 原有用户邮箱一致时，自动合并成一个用户，并且不再拥有修改用户密码的权利。虽然已经集成了 LDAP 认证，但是我们依然可以用 Nextcloud 自身的用户体系去创建新用户，这其实也是两个用户体系、一个软件系统。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://news.gandi.net/zh-hans/2021/05/nextcloud-vs-owncloud-which-cloud-solution-should-you-choose/">Nextcloud vs ownCloud? 该选择哪一个云端代管方案呢？</a></li>
  <li><a href="https://wzfou.com/nextcloud-seafile/">NextCloud与Seafile对比使用-NextCloud各项全能 Seafile优势突出</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="Nextcloud" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 Gitlab 篇</title><link href="https://lisz.me/tech/webmaster/ldap-gitlab.html" rel="alternate" type="text/html" title="LDAP 集成之 Gitlab 篇" /><published>2022-06-23T15:20:00+09:00</published><updated>2022-06-23T15:20:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-gitlab</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-gitlab.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Gitlab 是一款对标 Github 的开源 Git 管理软件，能够为用户提供非常丰富的功能。因为之前写过的<a href="../tech/docker/gitlab.html">《私有代码托管平台的搭建与运维》</a>和<a href="./gitlab-upgrade.html">《Gitlab 升级那些事儿》</a>已经对 Gitlab 作了比较详细的介绍，这里就不多赘述了。</p>

<h3 id="国内高校-gitlab">国内高校 Gitlab</h3>

<p>  Gitlab 提供了对于多种认证方式的支持，包括自带的用户体系、LDAP、CAS、OAuth 2.0 及其他第三方认证方式。这也为我们实现不同的用户需求提供了可能。国内高校中，中科大和南京大学都为本校生提供了基于 Gitlab 的代码托管服务，访问地址如下。唯一不同的是，中科大采用的社区版本（CE），南京大学采用的是由 Gitlab 在中国的子公司极狐支持的企业版本（EE），据说有一些更先进的功能。当然，考虑到使用 Gitlab 的主要需求是代码托管，而非 Gitlab Pages 功能，两家都没有提供该功能。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">学校</th>
      <th style="text-align: center">Git URL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">中科大</td>
      <td style="text-align: center"><a href="https://git.lug.ustc.edu.cn">https://git.lug.ustc.edu.cn</a></td>
    </tr>
    <tr>
      <td style="text-align: center">南京大学</td>
      <td style="text-align: center"><a href="https://git.nju.edu.cn">https://git.nju.edu.cn</a></td>
    </tr>
  </tbody>
</table>

<p>  言归正传，中科大和南京大学都可以自助注册，只需要是使用学校邮箱即可。中科大同时也提供了 Github、Gitlab、学校一卡通认证。自助注册的好处是，即使已经离校无法使用学校邮箱，实际上也还是可以保留账户继续使用（除非专门对毕业生进行封禁）。其实，对于内部团队使用的 Gitlab 来说，由管理员手动创建用户也是没有什么问题的，毕竟人数不会太多。但是这样一来，可能会出现维护多个账号和密码的烦恼。因此，采用 LDAP 来接入认证是比较合适的。对于非团队用户不打算放在 LDAP 目录里也可以手动在 Gitlab 创建用户，当用户不再使用时就可以封禁。</p>

<h3 id="ldap-用户合并">LDAP 用户合并</h3>

<p>  也可能存在先有 Gitlab 账户、然后才有的 LDAP 目录的情况，这也不要紧，因为 Gitlab 支持 LDAP 认证方式的用户与现有用户进行合并。举个例子，如果我已经在 Gitlab 中创建了用户名为 zhonger、邮箱为 zhonger@example.com 的用户，那么我在 LDAP 目录中只需要把 mail 字段也写成 zhonger@example.com 即可被 Gitlab 识别成同一用户。或者说，我们可以在 Gitlab 中增加 LDAP 目录中的 mail 字段的邮箱（Gitlab 支持同一用户绑定多个邮箱），这样在 Gitlab 中使用 LDAP 认证的时候也会被视为同一用户。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于 LDAP 用户的账户名和密码不会被 Gitlab 接管，所以当你使用 LDAP 认证登录后，原有的同邮箱的 Gitlab 用户就会自动丧失修改密码的权利。除此之外，一切照旧。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<p>  为了更加简便实践并且容易复现，这里采用的是常用的 <a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> Docker 镜像。可以在镜像 Github 页面下载到提供的对应 <a href="https://github.com/sameersbn/docker-gitlab/blob/master/docker-compose.yml">docker-compose.yml</a> 文件。由于 LDAP 并非是默认配置，所以默认是没有 LDAP 配置段的。需要在 docker-compose.yml 文件的 environment 中增加以下环境变量。其中，请根据实际情况更改成相应的信息。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
    <span class="na">environment</span><span class="pi">:</span>
        <span class="s">...</span>
        <span class="s">- LDAP_ENABLED=true</span>
        <span class="s">- LDAP_LABEL=LDAP</span>
        <span class="s">- LDAP_HOST=ldap.example.com</span>
        <span class="s">- LDAP_BIND_DN=cn=admin,dc=example,dc=com</span>
        <span class="s">- LDAP_PASS=xxxxxxxxxxx</span>
        <span class="s">- LDAP_UID=uid</span>
        <span class="s">- LDAP_BASE=ou=people,dc=example,dc=com</span>
<span class="nn">...</span>
</code></pre></div></div>

<p>  使用命令 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 运行一个 Gitlab 实例。由于初始运行需要执行数据库初始化等操作，可能需要几分钟，之后打开指定的端口即可看到如下类似的登录页面。可以看到，这里默认就是使用 LDAP 登录，次要登录方式才是标准登录。</p>

<p><img src="https://i.lisz.top/blog/BaWBKa.webp" alt="登录页面 Login Page" /></p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  这里 Gitlab 默认使用 uid 作为 username，而非常见 LDAP 登录定义里的 cn 字段，所以只需要最简单的 uid 和 password 即可登录成功。</p>



 </div> </div>
<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="Gitlab" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>