<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2024-12-29T12:42:47+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">C++ 程序输出当前堆栈</title><link href="https://gbcpp.github.io/print_stacktrace.html" rel="alternate" type="text/html" title="C++ 程序输出当前堆栈" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/print_stacktrace</id><content type="html" xml:base="https://gbcpp.github.io/print_stacktrace.html"><![CDATA[<p>将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。
互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。</p>

<h2 id="头文件">头文件</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h2 id="源码">源码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Utils</span><span class="o">::</span><span class="n">PrintStackTrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxFrames</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxPrettyFunctionNameLength</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">[</span><span class="n">kMaxFrames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 获取当前堆栈中的地址</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrlist</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"StackTraces: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// 解析地址为函数名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">symbollist</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

  <span class="c1">// 解析函数名的更多信息</span>
  <span class="kt">size_t</span> <span class="n">funcNameSize</span> <span class="o">=</span> <span class="n">kMaxPrettyFunctionNameLength</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">funcNameSize</span><span class="p">));</span>

  <span class="c1">// 跳过第一个元素（即本身）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 解析符号名称及偏移量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginName</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beginName</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span> <span class="o">&amp;&amp;</span> <span class="n">endOffset</span> <span class="o">&amp;&amp;</span> <span class="n">beginName</span> <span class="o">&lt;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">beginName</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">beginOffset</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

      <span class="c1">// 解码并打印函数名称</span>
      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span>
          <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">beginName</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funcNameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果无法解析，直接输出原始符号信息</span>
      <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">funcName</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">symbollist</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="编译">编译</h2>

<p><code class="language-plaintext highlighter-rouge">ldflags</code> 参数一定要指定 <code class="language-plaintext highlighter-rouge">-ldynamiclib</code> 告诉链接器将所有符号添加到动态符号表中。这使得运行时调试工具（如 GDB）和运行时函数（如 backtrace）可以访问这些符号。
主要用于调试和诊断目的，以便在运行时能够获取更详细的堆栈信息和符号解析。</p>

<p>对性能几乎没有影响，但是由于增加了符号表信息，会增加包体大小。</p>]]></content><author><name>Mr Chen</name></author><category term="C++" /><summary type="html"><![CDATA[将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。 互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。]]></summary></entry><entry><title type="html">温故而知新之-C++</title><link href="https://gbcpp.github.io/learning-cpp-notes.html" rel="alternate" type="text/html" title="温故而知新之-C++" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://gbcpp.github.io/learning-cpp-notes</id><content type="html" xml:base="https://gbcpp.github.io/learning-cpp-notes.html"><![CDATA[<h2 id="指针的退化及如何避免">指针的退化及如何避免</h2>

<p>在C++中，”指针退化”是指当数组作为函数参数传递时，它会”退化”为指向第一个元素的指针。这是因为在C++中，数组并不知道它们自己的大小，所以当你把一个数组作为参数传递给一个函数时，函数并不知道这个数组的大小，只知道它的起始地址。</p>

<p>例如，假设你有一个函数<code class="language-plaintext highlighter-rouge">void foo(int arr[])</code>，当你传递一个数组给这个函数时，例如<code class="language-plaintext highlighter-rouge">int arr[10]; foo(arr);</code>，函数<code class="language-plaintext highlighter-rouge">foo</code>实际上看到的是一个指向<code class="language-plaintext highlighter-rouge">arr</code>的第一个元素的指针，而不是整个数组。</p>

<p>要防止指针退化，有几种方法：</p>

<ol>
  <li>
    <p>使用标准库容器，如<code class="language-plaintext highlighter-rouge">std::vector</code>或<code class="language-plaintext highlighter-rouge">std::array</code>。这些容器知道它们自己的大小，因此不会发生指针退化。例如： <code class="language-plaintext highlighter-rouge">void foo(std::vector&lt;int&gt;&amp; arr)</code>。</p>
  </li>
  <li>
    <p>使用模板函数，使函数可以接受数组的引用，并且能够保留数组的大小信息。例如： <code class="language-plaintext highlighter-rouge">template&lt;size_t N&gt; void foo(int (&amp;arr)[N])</code>。</p>
  </li>
  <li>
    <p>传递数组的大小作为另一个参数。例如： <code class="language-plaintext highlighter-rouge">void foo(int* arr, size_t size)</code>。这样，即使数组退化为指针，函数仍然可以知道数组的大小。</p>
  </li>
</ol>

<h2 id="引用与指针的区别">引用与指针的区别</h2>

<p>在C++中，指针和引用都可以用于间接引用其他对象。然而，它们在语法和行为上有一些关键的不同：</p>

<ol>
  <li>
    <p>初始化：引用在创建时需要初始化，并且一旦初始化后就不能改变引用的目标，也就是说它始终引用最初赋给它的对象。而指针可以在任何时间指向任何对象或者NULL。</p>
  </li>
  <li>
    <p>空值：指针可以为NULL，表示它不指向任何对象。而引用必须始终引用一个有效的对象，不能有NULL引用。</p>
  </li>
  <li>
    <p>间接访问：使用指针时，需要使用解引用运算符(*)来访问它指向的对象，而引用则可以像普通变量那样直接使用。</p>
  </li>
  <li>
    <p>支持的操作：指针支持更多的操作，例如指针算术（即增加或减少指针的值，以指向内存中的不同位置）。引用则不能进行这种操作。</p>
  </li>
  <li>
    <p>内存占用：引用实际上并不占用任何内存，它只是一个别名。而指针是一个实际的变量，它占用内存空间并存储一个地址值。</p>
    <blockquote>
      <p>但引用在程序中并不是不占用任何字节，引用本质上就是一个常量指针（constant pointer）。它在内存中占据的空间和指针一样，通常是 4 字节（在 32 位系统）或 8 字节（在 64 位系统）。然而，引用本身并不存储任何值，它只是一个别名，代表它引用的对象。在某些优化的情况下，如果引用没有被用作一个对象的别名（也就是说，它被直接用于访问该对象），编译器可能会优化掉引用，使其不占用任何内存空间。但是，这种优化并不是在所有情况下都会发生。所以，说引用不占用内存空间并不完全准确，实际情况取决于编译器的优化和引用的使用方式。</p>
    </blockquote>
  </li>
</ol>

<p>总的来说，引用在某些情况下可以提供更简洁的语法，而指针则提供了更大的灵活性和控制能力。选择使用哪一个取决于具体的编程需求。</p>]]></content><author><name>Mr Chen</name></author><category term="C++" /><summary type="html"><![CDATA[指针的退化及如何避免]]></summary></entry><entry><title type="html">面向学习的三种人</title><link href="https://gbcpp.github.io/learning-oriented.html" rel="alternate" type="text/html" title="面向学习的三种人" /><published>2024-04-02T00:00:00+00:00</published><updated>2024-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/learning-oriented</id><content type="html" xml:base="https://gbcpp.github.io/learning-oriented.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者</p>
</blockquote>

<h2 id="1-犯人">1. 犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="2-过客">2. 过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="3-探索者">3. 探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者]]></summary></entry><entry><title type="html">NeoVim 安装配置记录</title><link href="https://gbcpp.github.io/notes/neovim.html" rel="alternate" type="text/html" title="NeoVim 安装配置记录" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/neovim</id><content type="html" xml:base="https://gbcpp.github.io/notes/neovim.html"><![CDATA[<blockquote>
  <p>安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。</p>
</blockquote>

<h2 id="windows-wsl-ubuntu">Windows WSL Ubuntu</h2>

<p>  WSL 下 Ubuntu 子系统的安装与原生的 Ubuntu 系统安装有所不同，主要是字体的配置方式上有所区别。</p>

<h3 id="install-neovim">Install NeoVim</h3>

<p>  我选择手动下载 NeoVim，这样可以安装官方最新版本，这里选择目前官方的最新版本 0.10.0，依次执行以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/tools
<span class="nb">cd</span> ~/tools
wget https://github.com/neovim/neovim/releases/download/v0.10.0/nvim-linux64.tar.gz
<span class="nb">tar </span>xzf nvim-linux64.tar.gz
</code></pre></div></div>

<p>上面下载的 <code class="language-plaintext highlighter-rouge">nvim-linux64.tar.gz</code> 为 NeoVim 的二进制包，可直接运行，可以将上述解压的 NeoVim 中的 bin 目录添加到系统环境变量 <code class="language-plaintext highlighter-rouge">PATH</code>中，或者为 NeoVim 在 <code class="language-plaintext highlighter-rouge">/usr/bin</code>目录下添加一个软连接：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> ~/tools/nvim-linux64/bin/nvim /usr/bin/nvim

<span class="c"># 可通过执行以下命令进行校验</span>
nvim <span class="nt">--version</span>
</code></pre></div></div>

<h3 id="neovim-configuration">NeoVim Configuration</h3>

<p>  使用 NeoVim 一个很大的门槛就是前期各种 <code class="language-plaintext highlighter-rouge">Plugins</code>的配置，目前有 <code class="language-plaintext highlighter-rouge">lazyVim</code>将很多易用的 <code class="language-plaintext highlighter-rouge">Plugins</code>打包在了一起，做到了开箱即用。</p>

<p>将 <code class="language-plaintext highlighter-rouge">LazyVim</code> 下载并解压到 <code class="language-plaintext highlighter-rouge">NeoVim</code>的配置目录下，启动 <code class="language-plaintext highlighter-rouge">NeoVim</code>便会自动安装了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 直接 clone 代码到 neovim 的配置文件目录下</span>
git clone https://github.com/LazyVim/starter ~/.config/nvim

<span class="c"># 启动 nvim，自动开始安装</span>
nvim
</code></pre></div></div>

<p>安装完成后，使用 nvim 随便打开一个目录可以看到 NeroTree 中的图标全是小方块，即乱码：</p>

<p><img src="/assets/img/blog/nerofont_0.png" alt="NeroFont0" /></p>

<p>继续以下操作，安装所有符号等宽展示的字体。</p>

<h3 id="install-nerd-font">Install Nerd Font</h3>

<p><a href="https://www.nerdfonts.com/"></a></p>

<p>选择下载 <code class="language-plaintext highlighter-rouge">JetBrainsMono Font</code> 字体，在 Windows 中解压缩后，可以看到内部全是后缀为 <code class="language-plaintext highlighter-rouge">.ttf</code> 的文件，选中后，右键 <code class="language-plaintext highlighter-rouge">安装</code> 即安装成功。</p>

<h3 id="windows-terminal-配置-mono-字体">Windows Terminal 配置 Mono 字体</h3>

<p>我的 <code class="language-plaintext highlighter-rouge">windows terminal</code> 版本如下 ：</p>

<p><img src="/assets/img/blog/win_terminal.png" alt="" /></p>

<p>该版本没有 UI 的配置界面，通过 <code class="language-plaintext highlighter-rouge">settings.json</code> 进行配置，在 <code class="language-plaintext highlighter-rouge">profiles</code> 的 <code class="language-plaintext highlighter-rouge">defaults</code> 配置中添加 <code class="language-plaintext highlighter-rouge">fontFace</code> 字段指定字体，如下：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"defaults"</span><span class="p">:</span><span class="w">
</span><span class="p">{</span><span class="w">
   </span><span class="err">//</span><span class="w"> </span><span class="err">Put</span><span class="w"> </span><span class="err">settings</span><span class="w"> </span><span class="err">here</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="err">you</span><span class="w"> </span><span class="err">want</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">apply</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">all</span><span class="w"> </span><span class="err">profiles.</span><span class="w">
   </span><span class="nl">"fontFace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JetBrainsMono Nerd Font Mono"</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">

</span><span class="err">....</span><span class="w">
</span></code></pre></div></div>

<p>配置成功后，重启 <code class="language-plaintext highlighter-rouge">windows terminal</code>，通过 NeoVim 打开上一次的目录，查看图标显示已正常：</p>

<p><img src="/assets/img/blog/nerofont_1.png" alt="" /></p>

<h2 id="mac">Mac</h2>

<h2 id="ubuntu">Ubuntu</h2>

<h2 id="常用功能介绍">常用功能介绍</h2>

<h3 id="窗口管理">窗口管理</h3>

<ul>
  <li>打开内置控制台，执行命令，这是比较常用的场景，不需要切换窗口，快捷键 <code class="language-plaintext highlighter-rouge">Ctrl + L</code>，目录定位在当前路径，不是当前被打开的目录：</li>
</ul>

<p><img src="/assets/img/blog/nvim_console.png" alt="" /></p>

<blockquote>
  <p>关闭亦是使用该快捷键。</p>
</blockquote>

<ul>
  <li>切换光标在 <code class="language-plaintext highlighter-rouge">NeroTree</code> 和代码窗口中，使用 <code class="language-plaintext highlighter-rouge">Ctrl + h|l</code>，<code class="language-plaintext highlighter-rouge">h</code> 和 <code class="language-plaintext highlighter-rouge">l</code> 是 nvim 中移动光标位置的快捷键，加上 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键便是左右切换窗口的快捷键。</li>
</ul>]]></content><author><name>Mr Chen</name></author><category term="notes" /><category term="develop" /><summary type="html"><![CDATA[安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/tech/float-performance-comparation.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/tech/float-performance-comparation</id><content type="html" xml:base="https://gbcpp.github.io/tech/float-performance-comparation.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<p>由于 float 在内存中的存储结构与 int 不同，需要存储指数和尾数，并且 cpu 是不支持直接对 float 进行运算的，需要将 float 各部分进行转换后计算，对结果再次进行反向操作进行存储，所以大部分情况下均不支持直接使用 float 进行运行，建议用 int 进行转换运行结果。</p>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>由于不同的 CPU 和体系架构对 FPU 支持情况的不同，以及不同的运算方法对结果也有很大的影响， 比如 加、减、乘、除，以及系数的不同：大于 1 或者小于 1 等均有不同的结果，上述结论为选择了较为复杂的计算场景，仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="tech" /><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/float-performance.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/float-performance</id><content type="html" xml:base="https://gbcpp.github.io/float-performance.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>以上仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">获取不同 Clock Id 在不同 Linux Kernel 下的精度</title><link href="https://gbcpp.github.io/measure-clock-resolution.html" rel="alternate" type="text/html" title="获取不同 Clock Id 在不同 Linux Kernel 下的精度" /><published>2023-10-25T00:00:00+00:00</published><updated>2023-10-25T00:00:00+00:00</updated><id>https://gbcpp.github.io/measure-clock-resolution</id><content type="html" xml:base="https://gbcpp.github.io/measure-clock-resolution.html"><![CDATA[]]></content><author><name>Mr Chen</name></author><category term="Linux" /><category term="C++" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">GitHub Pages 博客搭建记录</title><link href="https://gbcpp.github.io/blog-building-notes.html" rel="alternate" type="text/html" title="GitHub Pages 博客搭建记录" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/blog-building-notes</id><content type="html" xml:base="https://gbcpp.github.io/blog-building-notes.html"><![CDATA[<h1 id="渊源">渊源</h1>

<p>  国庆放假期间，机缘巧合看到一篇使用了非常漂亮主题的文章，它也是基于 GitHub 的 Pages 进行搭建和部署的，回想起几年前自己搭建的个人博客（因始终不满足自己的审美要求，已废弃），让我一眼便喜欢上了它，立即决定重建我的个人博客。</p>

<h1 id="博客构建框架">博客构建框架</h1>

<p>  搭建个人博客，大部分人都是通过 GitHub 的 Pages 进行白嫖，但是已有的主题都不是非常完美，对于一个从事非前端开发的人来说，优化调整博客主题到自己满意的程度是非常难的，长时间搞不到自己满意的程度，结局大概率都是废弃。
在看到这篇基于<a href="https://blog.lui8.cn/tech/new-theme-h2o-ac.html">H2O-ac 主题</a> 搭建的的博客后，我决定就是它了，瞬间重拾搭建个人博客的兴趣。</p>

<p>  早些时候，我使用的 GitHub blog 是通过 <code class="language-plaintext highlighter-rouge">Hexo</code> 构建的，<code class="language-plaintext highlighter-rouge">Hexo</code> 是基于 <code class="language-plaintext highlighter-rouge">Node.js</code> 驱动的，而上述博客是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 构建，该框架基于 <code class="language-plaintext highlighter-rouge">Ruby</code> 驱动，它们都是开源的，通过 GitHub 的 star 和 fork 数量，可以看到 <code class="language-plaintext highlighter-rouge">Jekyll</code> 的热度要高于 <code class="language-plaintext highlighter-rouge">Hexo</code>，但是不知道当时自己怎么没有注意到这一点，可能是因为当时是摸着别人过的河，没有了自己的思考。</p>

<p>  由于该主题是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 框架构建的，所以我们就此切换到 <code class="language-plaintext highlighter-rouge">Jekyll</code>，主题就用 <code class="language-plaintext highlighter-rouge">H2O-ac</code>。</p>

<h1 id="初始化">初始化</h1>

<p>  首先创建一个自己的专门用户博客的 public 仓库，这里建议直接从 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 主题作者的 repo <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">jekyll-theme-H2O-ac</a> 中 fork，在命名新的 repo 时，一定要命名自己的 GitHub <code class="language-plaintext highlighter-rouge">name</code> + ‘.github.io’，比如我自己的：gbcpp.github.io，其中 <code class="language-plaintext highlighter-rouge">gbcpp</code> 便是我的 GitHub name，这样做也是官方建议的，同时 Fork 过去的 repo 才可以直接 Publish，而不用做其它任何链接失效之类的修复，而我因为当初好几年没有再折腾过 GitHub 的博客，早已经忘记了这一点，起了个非此模板的名字：<code class="language-plaintext highlighter-rouge">blog</code>、 <code class="language-plaintext highlighter-rouge">webindex</code> 等，部署上的博客有好几处都是无效的链接，需要自行查找并修改，同时博客的 Url 中也要增加子路径。</p>

<p>Fork 后，在该 repo 的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，找到 <code class="language-plaintext highlighter-rouge">Pages</code>，在 <code class="language-plaintext highlighter-rouge">Build and deployment</code> 中选择 <code class="language-plaintext highlighter-rouge">master</code> 分支进行发布，目录就选择 <code class="language-plaintext highlighter-rouge">/(root)</code>, Save 后等待约 3 分钟，即可通过 <code class="language-plaintext highlighter-rouge">xxx.github.io</code> 进行访问。</p>

<p><img src="/assets/img/github_settings.png" alt="" /></p>

<h1 id="个人信息调整">个人信息调整</h1>

<p>虽然经过上述的简单操作，已经能够访问到自己新搭建的博客，但是还有一些个人信息需要调整，在 <code class="language-plaintext highlighter-rouge">.github/workflow</code> 中，每次提交，均会触发 GitHub Actions Workflow，重新执行 Jekyll build &amp; deploy CI 操作，所以我们要为自己的 repo 增加一个 <code class="language-plaintext highlighter-rouge">GITHUB_TOKEN</code>，否则每次 CI 均会报错。如下图所示：</p>

<p><img src="/assets/img/github_token.png" alt="GitHub Token" /></p>

<p>GitHub 的 CI 每次构建完成后会将生成的 <code class="language-plaintext highlighter-rouge">_site</code> 目录 Push 到 <a href="https://jupyterbook.org/en/stable/publish/gh-pages.html"><code class="language-plaintext highlighter-rouge">gh-pages</code></a> 分支。</p>

<p>在该作者的 repo 中，添加的 GitHub workflow 不止 <code class="language-plaintext highlighter-rouge">GitHub</code> 一个，还有亚马逊等其它家，用于网站加速，不过，我个人并没有使用这种多个 workflow 的方式，我删除了除了 ‘jekyll.yml’ 以外所有的 workflow，网站加速请继续往下看。</p>

<h1 id="部署-cdn">部署 CDN</h1>

<p>博客初步建立后，直接访问是非常慢的，没有任何的 CDN 托管加速，而 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 的作者开通了多家国内外 CDN 厂家的托管，访问速度要比直接 xxx.github.io 快很多。</p>

<p>这里我选择了提供全球节点的 <code class="language-plaintext highlighter-rouge">Cloudflare</code> <a href="https://dash.cloudflare.com/">官网</a> 进行托管，主要是因为它对于个人站点是完全免费的，并且操作简单，易上手。</p>

<h2 id="cloudflare-新建-pages">Cloudflare 新建 Pages</h2>

<p>注册并登陆 Cloudflare，进入到个人 <code class="language-plaintext highlighter-rouge">账户主页</code>，进入 <code class="language-plaintext highlighter-rouge">Worker 和 Pages</code>，选择 <code class="language-plaintext highlighter-rouge">Pages</code> 选项，<strong>注意</strong>我们这里选择 <code class="language-plaintext highlighter-rouge">连接到 Git</code>，选择自己的仓库和分支，自动部署即可，如下图：</p>

<p><a href="/assets/img/Cloudflare_GitPages.png"></a></p>

<p>由于我们仅使用了 <code class="language-plaintext highlighter-rouge">jekyll.yml</code> 一个 GitHub Action，该 CI 完成后，会将 <code class="language-plaintext highlighter-rouge">_site</code> 目录自动 push 到 <code class="language-plaintext highlighter-rouge">gp-pages</code> 分支，所以在 <code class="language-plaintext highlighter-rouge">Cloudflare</code> 的 <code class="language-plaintext highlighter-rouge">Pages</code> 配置中，我们选择 <strong>分支</strong> 为 <code class="language-plaintext highlighter-rouge">gh-pages</code>，同时不要添加任何的构建框架和执行命令，只要选择自动选择更新即可。添加完成后的配置如下，可做参考：
<a href="/assets/img/Cloudflare_GitPages2.png"></a></p>

<h2 id="自定义域名">自定义域名</h2>

<p>上述部署完成，可以生成自己博客在 Cloudflare 的域名，比如：xxx-github-io.pages.dev，执行以下步骤将 xxx.github.io 重定向到 xxx-github-io.pages.dev。</p>

<h3 id="cname">CNAME</h3>
<p>Custom domain 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 
博客仓库中新建 <code class="language-plaintext highlighter-rouge">CNAME</code> 文件，填充 Cloudflare 生成的 ‘xxx-github-io.pages.dev’ 域名，并提交。</p>

<h3 id="pages-自定义域名配置">Pages 自定义域名配置</h3>

<p>回到 GitHub 博客仓库的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，在 <code class="language-plaintext highlighter-rouge">Pages</code> 子页面的 <code class="language-plaintext highlighter-rouge">Custom domain</code> 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 保存。以后每次访问自己的 xxx.github.io 便会自动跳转到 xxx-github-io.pages.dev。</p>

<p>当然这样的白嫖效果也就一般般，访问速度并不能完全达到国内建站的速度。</p>

<h1 id="绊脚石">绊脚石</h1>

<h2 id="jekyll-安装">Jekyll 安装</h2>

<p>本人的环境是在 WSL2 下的 Ubuntu Linux 安装的，发现 Jekyll 官方提供的 Installing docs 在 Ubuntu 18.04 及以下由于版本兼容问题已经无法正常的安装了，在 Ubuntu 20.04 中较为顺利，依次执行以下命令不太会遇到太多的问题：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span>
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span>  ruby-full build-essential zlib1g-dev
<span class="nb">echo</span> <span class="s1">'# Install Ruby Gems to ~/gems'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export GEM_HOME="$HOME/gems"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/gems/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc

<span class="c"># 这里 proxychains 为本人配置的 代理，否则容易出现下载失败</span>
<span class="nb">sudo </span>proxychains gem <span class="nb">install </span>jekyll bundler
<span class="nb">sudo </span>proxychains bundle <span class="nb">install</span>
</code></pre></div></div>

<h2 id="h2o-ac-blog-页面异常">H2O-ac Blog 页面异常</h2>

<p>基于作者的最新版本 <code class="language-plaintext highlighter-rouge">master</code> 或者 <code class="language-plaintext highlighter-rouge">tag: v1.2.1</code>，在 <code class="language-plaintext highlighter-rouge">Blog</code> 首页会有如下分页显示的问题，该问题在 GitHub 中已经有人反馈给作者, <a href="https://github.com/zhonger/jekyll-theme-H2O-ac/issues/13">ISSUE</a>，等待作者修复（本人不懂前端，经过几天努力，排查修复失败），不过本人已经排查到该显示问题是从 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 升级到 <code class="language-plaintext highlighter-rouge">v1.1.7</code> 时开始引入的，在本地 build 查看时，没有异常，一旦部署到 GitHub 便异常，所以该站使用的是 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 版本。</p>

<p><a href="/assets/img/jekyll_blog_bug.png"></a></p>

<h2 id="cloudflare-部署报错">Cloudflare 部署报错</h2>

<p>当 Blog 中存在文件 size ~&gt; 25MB 时，Cloudflare 会报错而终止部署，对此需要删除 repo 中所有 size 过大的文件（一般是图片），根据报错，通过以下命令查找并删除所有相关文件的历史记录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 其中 assets/img/shan.png 为要删除的文件</span>
git filter-branch <span class="nt">--force</span> <span class="nt">--index-filter</span> <span class="s1">'git rm --cached --ignore-unmatch assets/img/shan.png'</span> <span class="nt">--prune-empty</span> <span class="nt">--tag-name-filter</span> <span class="nb">cat</span> <span class="nt">--</span> <span class="nt">--all</span>
</code></pre></div></div>

<p>排查结束后，会显示涉及到该文件的分支列表，如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ref <span class="s1">'refs/heads/gh-pages'</span> was rewritten
Ref <span class="s1">'refs/heads/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/dev'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/gh-pages'</span> was rewritten
WARNING: Ref <span class="s1">'refs/remotes/origin/master'</span> is unchanged
</code></pre></div></div>

<p>将 <code class="language-plaintext highlighter-rouge">rewritten</code> 的本地分支 push 到 GitHub，然后在 Cloudflare 上重新部署。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout master
git push <span class="nt">-f</span> origin master

git checkout gh-pages
git push <span class="nt">-f</span> origin gh-pages
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[渊源]]></summary></entry><entry><title type="html">PlantUML-Language Pdf</title><link href="https://gbcpp.github.io/PlantUML-Language-book.html" rel="alternate" type="text/html" title="PlantUML-Language Pdf" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/PlantUML-Language-book</id><content type="html" xml:base="https://gbcpp.github.io/PlantUML-Language-book.html"><![CDATA[<h1 id="plantuml-语法字典">PlantUML 语法字典</h1>

<p>查看 和 下载地址：<a href="/assets/books/PlantUML_Language_Reference_Guide_zh.pdf">PlantUML-Language</a></p>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[PlantUML 语法字典]]></summary></entry><entry><title type="html">RtcDataChannel(sctp) protocol optimize</title><link href="https://gbcpp.github.io/sctp-optimize.html" rel="alternate" type="text/html" title="RtcDataChannel(sctp) protocol optimize" /><published>2023-09-30T00:00:00+00:00</published><updated>2023-09-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/sctp-optimize</id><content type="html" xml:base="https://gbcpp.github.io/sctp-optimize.html"><![CDATA[<h1 id="datachannel-实现">DataChannel 实现</h1>
<p>DataChannel 的实现有两种，webrtc 目前使用自行基于 C++ 开发的 dcsctp，mediasoup 和 libdatachannel 基于 usrsctp，usrsctp 为开源 sctp 协议实现，均遵守 rfc 4960 标准。
RFC：https://tools.ietf.org/html/rfc4960</p>

<h1 id="能力概述">能力概述</h1>
<p>DataChannel (SCTP）支持可靠传输、不可靠传输两种模式，其中不可靠传输有两种方式：一种基于配置包最大生命周期进行配置，另一种是基于最大重传次数进行配置。</p>

<p>如若使用可靠传输只需将Client 端的 reliable 配置为 true 即可，Server 的 usrsctp 中的 <code class="language-plaintext highlighter-rouge">spa.sendv_prinfo.pr_policy</code> 配置为  <code class="language-plaintext highlighter-rouge">SCTP_PR_SCTP_NONE</code> 即可；</p>

<p>如若需要使用不可靠传输模式，则分以下两种方式：基于生存时间和重传次数，二者只能选其一：
基于最大生命周期 <code class="language-plaintext highlighter-rouge">maxRetransTime</code> 为数据报在 sctp 队列中最大存活时间，该参数可以保证发送队列可以快速的情况，尽量降低后续包发送失败的概率，但是存在在网络拥塞的情况下，因 CC 控制导致数据报尚未发送便被清理的问题，即数据包没有经过一次发送便因超时而被清理了。</p>

<p>基于最大重传次数 <code class="language-plaintext highlighter-rouge">maxRetrans</code> 为数据报在发送队列中最多重传的次数，可保证数据至少在网络中发送一次，但如若出现了网络丢包，不会进行重传；注意：在 usrsctp 中，此参数至少要配置为 1 才能保证至少发送一次，与 client 不同。</p>

<h1 id="性能">性能</h1>
<p>两者默认都较弱，不论是其可靠传输，还是不可靠传输，抗弱网能力均较弱，但测试下来 usrsctp 比 dcsctp 要强一些，不过 usrsctp 基于 c 开发，代码缩写、简写严重，难以阅读理解，而 dcsctp 基于 C++ 实现，相对要容易理解一些；</p>

<h1 id="弱网性能">弱网性能</h1>
<p>在可靠传输模式下，30% 的丢包即为上限，整体还不如 tcp，具体数据暂不列了，更高的丢包率测试无法进行下去。</p>

<h2 id="原因分析">原因分析</h2>

<h3 id="发送窗口">发送窗口</h3>

<p>sctp 在拥塞控制算法上与 tcp 类似，分为慢启动、拥塞避免、快速恢复 和快速重传几个阶段。
在出现弱网，即出现 丢包 或者 重传超时的情况时，发送窗口 cwnd 和 慢启动阈值 ssthresh 减半，降低过快，同时其 cwnd 最低值过低，首先从这一点进行入手分析。
以下 Url 是 RFC 中对 CWnd 和 SStreash 的配置策略：
	https://datatracker.ietf.org/doc/html/rfc4960#section-6.3.3
	https://datatracker.ietf.org/doc/html/rfc4960#section-7.2.3
原文如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7.2.3.  Congestion Control

   Upon detection of packet losses from SACK (see Section 7.2.4), an
   endpoint should do the following:

      ssthresh = max(cwnd/2, 4*MTU)
      cwnd = ssthresh
      partial_bytes_acked = 0

   Basically, a packet loss causes cwnd to be cut in half.

   When the T3-rtx timer expires on an address, SCTP should perform slow
   start by:

      ssthresh = max(cwnd/2, 4*MTU)
      cwnd = 1*MTU

   and ensure that no more than one SCTP packet will be in flight for
   that address until the endpoint receives acknowledgement for
   successful delivery of data to that address.
</code></pre></div></div>
<p>大致意思如下：
在检测到丢包时，更新 sstresh 和 cwnd 机制如下：
对原 ssthresh 减半，但最大为 4 个 MTU 大小，这个是致命的，同时将 cwnd 更新为 ssthresh；
当 T3-rtx 重传定时器超时时：
对原 ssthresh 减半，但最大为 4 个 MTU 大小，但对 cwnd 更新为仅 1 个 MTU。
通过上述两种机制，可以看到，在高丢包率的弱网环境中，很容易进入到上述两种 case 中，结合 flighting 的数据大小，导致 sctp 协议可发送数据量奇小 （cwnd 过小），同时因为重传包的优先级高于新生成的数据包，导致协议唯一的一个发送窗口一直在重传旧包，新包很难获取发送机会，这就导致了明显的队头阻塞现象。
解决方案：目标只是为了不使 CWnd 的大小降低的过快，即在检测到丢包和 T3-rtx 超时时，不要立即对 ssthresh 减半，而是更加平滑的去降低，并且提高最小值的上限，通过这两种策略的优化，可以保证 sctp 协议有很高的带宽抢占能力，因为发送窗口越大，带宽抢占能力就越高。</p>

<h3 id="清空队列">清空队列</h3>

<p>通过上述策略优化发送窗口后，可以大幅度提高 sctp 在弱网（双向各30%丢包率）下的带宽传输能力，但是在更极端的网损（40%丢包，甚至更高）场景下，依然会出现队头阻塞现象，发送端不再主动发送新插入的数据，而是优先发送旧包（未收到 Ack），在实际应用场景中，我们希望不论是否收到对端的确认，都不应该阻塞新包的发送，和旧包的清理，以保证发送队列有一个快速的清理速度，且保证所有的数据均有机会被快速的发送到网络中去。
如果双方均为开源的实现，我们可以随意修改 sctp，可快速解决上述问题，但是当一端为浏览器时，我们只能考虑修改 Server 侧的协议实现，以期可以间接的影响到对端（浏览器），让对端（浏览器）最为发送端时，可以快速的清空发送队列，避免队头阻塞，答案就在 SACK 包中，首先看下 SACK 包的协议定义：
https://datatracker.ietf.org/doc/html/rfc4960#section-3.3.4</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.3.4.  Selective Acknowledgement (SACK) (3)

   This chunk is sent to the peer endpoint to acknowledge received DATA
   chunks and to inform the peer endpoint of gaps in the received
   subsequences of DATA chunks as represented by their TSNs.

   The SACK MUST contain the Cumulative TSN Ack, Advertised Receiver
   Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of
   Duplicate TSNs fields.

   By definition, the value of the Cumulative TSN Ack parameter is the
   last TSN received before a break in the sequence of received TSNs
   occurs; the next TSN value following this one has not yet been
   received at the endpoint sending the SACK.  This parameter therefore
   acknowledges receipt of all TSNs less than or equal to its value.

   The handling of a_rwnd by the receiver of the SACK is discussed in
   detail in Section 6.2.1.

   The SACK also contains zero or more Gap Ack Blocks.  Each Gap Ack
   Block acknowledges a subsequence of TSNs received following a break
   in the sequence of received TSNs.  By definition, all TSNs
   acknowledged by Gap Ack Blocks are greater than the value of the
   Cumulative TSN Ack.


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 3    |Chunk  Flags   |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Cumulative TSN Ack                       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Advertised Receiver Window Credit (a_rwnd)           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN 1                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN X                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Chunk Flags: 8 bits

      Set to all '0's on transmit and ignored on receipt.

   Cumulative TSN Ack: 32 bits (unsigned integer)

      This parameter contains the TSN of the last DATA chunk received in
      sequence before a gap.  In the case where no DATA chunk has been
      received, this value is set to the peer's Initial TSN minus one.

   Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned
   integer)

      This field indicates the updated receive buffer space in bytes of
      the sender of this SACK; see Section 6.2.1 for details.

   Number of Gap Ack Blocks: 16 bits (unsigned integer)

      Indicates the number of Gap Ack Blocks included in this SACK.

   

   Number of Duplicate TSNs: 16 bit

      This field contains the number of duplicate TSNs the endpoint has
      received.  Each duplicate TSN is listed following the Gap Ack
      Block list.

   Gap Ack Blocks:

      These fields contain the Gap Ack Blocks.  They are repeated for
      each Gap Ack Block up to the number of Gap Ack Blocks defined in
      the Number of Gap Ack Blocks field.  All DATA chunks with TSNs
      greater than or equal to (Cumulative TSN Ack + Gap Ack Block
      Start) and less than or equal to (Cumulative TSN Ack + Gap Ack
      Block End) of each Gap Ack Block are assumed to have been received
      correctly.

   Gap Ack Block Start: 16 bits (unsigned integer)

      Indicates the Start offset TSN for this Gap Ack Block.  To
      calculate the actual TSN number the Cumulative TSN Ack is added to
      this offset number.  This calculated TSN identifies the first TSN
      in this Gap Ack Block that has been received.

   Gap Ack Block End: 16 bits (unsigned integer)

      Indicates the End offset TSN for this Gap Ack Block.  To calculate
      the actual TSN number, the Cumulative TSN Ack is added to this
      offset number.  This calculated TSN identifies the TSN of the last
      DATA chunk received in this Gap Ack Block.
</code></pre></div></div>

<p>每一个 SACK 包中，均包括一个字段：<code class="language-plaintext highlighter-rouge">Cumulative TSN</code>，该字段标识接收端已确认（通知给 Application）的最大包序号（TSN），通过此字段告诉发送端，不要再发送小于此 TSN 的包，并清空所有队列中，小于等于此 TSN 的数据包，其它的字段均不是最重要的，可以自行决定是否调整。
只有当发送端不断的接收到接收端发来的 SACK 包后，通过其携带的强制前移的 <code class="language-plaintext highlighter-rouge">Cumulative TSN</code> 来清理本地的发送队列，可以保证自己的发送队列一直处于一个较小的 Cache，这样，新插入的数据包便可以被快速的发送出去，避免了因旧包未被 Ack 而导致的队头阻塞问题，更加的贴近 UDP 的行为。</p>

<p>Ok，那么回溯下这个问题的上一步：为什么发送端无法快速的清空自己的发送队列的呢？我们看下 RFC 的定义便知，https://datatracker.ietf.org/doc/html/rfc4960#section-6.1
原文如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6.1.  Transmission of DATA Chunks

   This document is specified as if there is a single retransmission
   timer per destination transport address, but implementations MAY have
   a retransmission timer for each DATA chunk.

   The following general rules MUST be applied by the data sender for
   transmission and/or retransmission of outbound DATA chunks:

   A) At any given time, the data sender MUST NOT transmit new data to
      any destination transport address if its peer's rwnd indicates
      that the peer has no buffer space (i.e., rwnd is 0; see Section
      6.2.1).  However, regardless of the value of rwnd (including if it
      is 0), the data sender can always have one DATA chunk in flight to
      the receiver if allowed by cwnd (see rule B, below).  This rule
      allows the sender to probe for a change in rwnd that the sender
      missed due to the SACK's having been lost in transit from the data
      receiver to the data sender.

      When the receiver's advertised window is zero, this probe is
      called a zero window probe.  Note that a zero window probe SHOULD
      only be sent when all outstanding DATA chunks have been
      cumulatively acknowledged and no DATA chunks are in flight.  Zero
      window probing MUST be supported.

      If the sender continues to receive new packets from the receiver
      while doing zero window probing, the unacknowledged window probes
      should not increment the error counter for the association or any
      destination transport address.  This is because the receiver MAY
      keep its window closed for an indefinite time.  Refer to Section
      6.2 on the receiver behavior when it advertises a zero window.
      The sender SHOULD send the first zero window probe after 1 RTO
      when it detects that the receiver has closed its window and SHOULD
      increase the probe interval exponentially afterwards.  Also note
      that the cwnd SHOULD be adjusted according to Section 7.2.1.  Zero
      window probing does not affect the calculation of cwnd.

      The sender MUST also have an algorithm for sending new DATA chunks
      to avoid silly window syndrome (SWS) as described in [RFC0813].
      The algorithm can be similar to the one described in Section
      4.2.3.4 of [RFC1122].

      However, regardless of the value of rwnd (including if it is 0),
      the data sender can always have one DATA chunk in flight to the
      receiver if allowed by cwnd (see rule B below).  This rule allows
      the sender to probe for a change in rwnd that the sender missed
      due to the SACK having been lost in transit from the data receiver
      to the data sender.

   B) At any given time, the sender MUST NOT transmit new data to a
      given transport address if it has cwnd or more bytes of data
      outstanding to that transport address.

   C) When the time comes for the sender to transmit, before sending new
      DATA chunks, the sender MUST first transmit any outstanding DATA
      chunks that are marked for retransmission (limited by the current
      cwnd).

   D) When the time comes for the sender to transmit new DATA chunks,
      the protocol parameter Max.Burst SHOULD be used to limit the
      number of packets sent.  The limit MAY be applied by adjusting
      cwnd as follows:

      if((flightsize + Max.Burst*MTU) &lt; cwnd) cwnd = flightsize +
      Max.Burst*MTU

      Or it MAY be applied by strictly limiting the number of packets
      emitted by the output routine.

   E) Then, the sender can send out as many new DATA chunks as rule A
      and rule B allow.

   Multiple DATA chunks committed for transmission MAY be bundled in a
   single packet.  Furthermore, DATA chunks being retransmitted MAY be
   bundled with new DATA chunks, as long as the resulting packet size
   does not exceed the path MTU.  A ULP may request that no bundling is
   performed, but this should only turn off any delays that an SCTP
   implementation may be using to increase bundling efficiency.  It does
   not in itself stop all bundling from occurring (i.e., in case of
   congestion or retransmission).

   Before an endpoint transmits a DATA chunk, if any received DATA
   chunks have not been acknowledged (e.g., due to delayed ack), the
   sender should create a SACK and bundle it with the outbound DATA
   chunk, as long as the size of the final SCTP packet does not exceed
   the current MTU.  See Section 6.2.

   IMPLEMENTATION NOTE: When the window is full (i.e., transmission is
   disallowed by rule A and/or rule B), the sender MAY still accept send
   requests from its upper layer, but MUST transmit no more DATA chunks
   until some or all of the outstanding DATA chunks are acknowledged and
   transmission is allowed by rule A and rule B again.

   Whenever a transmission or retransmission is made to any address, if
   the T3-rtx timer of that address is not currently running, the sender
   MUST start that timer.  If the timer for that address is already
   running, the sender MUST restart the timer if the earliest (i.e.,
   lowest TSN) outstanding DATA chunk sent to that address is being
   retransmitted.  Otherwise, the data sender MUST NOT restart the
   timer.

   When starting or restarting the T3-rtx timer, the timer value must be
   adjusted according to the timer rules defined in Sections 6.3.2 and
   6.3.3.

   Note: The data sender SHOULD NOT use a TSN that is more than 2**31 -
   1 above the beginning TSN of the current send window.
</code></pre></div></div>

<p>根据上述定义，再结合上面 CWND 的更新策略，可以推测出，在高丢包的弱网情况下，Sender 很容易 Trigger 因连续未收到 Receiver 的 Ack，同时自己的 Inflighting 数据量较多，导致自己可发送的数据量非常小（最小为 1 个 MTU），甚至发送 0 Bytes 的探测包代替，从而出现严重的对头阻塞问题。</p>

<blockquote>
  <p>但是按照上述方案通过接收端强制偏移 TSN，以达到发送端快速清空发送队列的目标时，DataChannel/SCTP 的可靠传输能力便丧失了。</p>
</blockquote>

<h3 id="sack-chunk-源码">SACK Chunk 源码</h3>

<p>首先整理下 sctp 协议内接收端组装sack 的数据结构 （https://tools.ietf.org/html/rfc4960#section-3.3.4），在 dcsctp 的代码中比较易懂，定义如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SackChunk</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Chunk</span><span class="p">,</span> <span class="k">public</span> <span class="n">TLVTrait</span><span class="o">&lt;</span><span class="n">SackChunkConfig</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">kType</span> <span class="o">=</span> <span class="n">SackChunkConfig</span><span class="o">::</span><span class="n">kType</span><span class="p">;</span>

  <span class="c1">// 可以看出包序号使用的是 uint16_t，只需两个字节  </span>
  <span class="k">struct</span> <span class="nc">GapAckBlock</span> <span class="p">{</span>
    <span class="n">GapAckBlock</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">end</span><span class="p">)</span> <span class="o">:</span> <span class="n">start</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">uint16_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">end</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">GapAckBlock</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">start</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">SackChunk</span><span class="p">(</span><span class="n">TSN</span> <span class="n">cumulative_tsn_ack</span><span class="p">,</span>
            <span class="kt">uint32_t</span> <span class="n">a_rwnd</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;</span> <span class="n">duplicate_tsns</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">cumulative_tsn_ack_</span><span class="p">(</span><span class="n">cumulative_tsn_ack</span><span class="p">),</span>
        <span class="n">a_rwnd_</span><span class="p">(</span><span class="n">a_rwnd</span><span class="p">),</span>
        <span class="n">gap_ack_blocks_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">gap_ack_blocks</span><span class="p">)),</span>
        <span class="n">duplicate_tsns_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">duplicate_tsns</span><span class="p">))</span> <span class="p">{}</span>
  <span class="k">static</span> <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">SackChunk</span><span class="o">&gt;</span> <span class="n">Parse</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">SerializeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ToString</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">TSN</span> <span class="n">cumulative_tsn_ack</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cumulative_tsn_ack_</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">uint32_t</span> <span class="n">a_rwnd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a_rwnd_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">gap_ack_blocks_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;&amp;</span> <span class="n">duplicate_tsns</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">duplicate_tsns_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kGapAckBlockSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kDupTsnBlockSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">TSN</span> <span class="n">cumulative_tsn_ack_</span><span class="p">;</span>             <span class="c1">// 最大已确认包序号，TSN 即为内部传输块的序号</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">a_rwnd_</span><span class="p">;</span>                    <span class="c1">// 接收窗口的大小</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks_</span><span class="p">;</span>  <span class="c1">// GAP 包序号范围，一次聚合多个</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;</span> <span class="n">duplicate_tsns_</span><span class="p">;</span>             <span class="c1">// 收到的已确认的包序号</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这里，可能有些疑问，每次打包的 SACK 中，其 gap_ack_blocks_ 和 duplicate_tsns_ 是否有最大个数/长度限制，因为它们两个毕竟是要全部一个个的序列化到网络包中的，答案是：有的。
两者 gap_ack_blocks_ 和 duplicate_tsns_ 单次限制上限为 20 个，kMaxGapAckBlocksReported 和 kMazhimaxDuplicateTsnReported 均定义为 constexpr 值：20，声明在代码文件：data_tracker.h中。</p>

<h3 id="sack-发包时机">SACK 发包时机</h3>

<p>在 dcsctp 的实现中，sack 的发送时机是动态的。在没有数据包丢失时，每秒钟发送一次，当监测到丢包时，针对每个数据包发送一次 sack；当不直接发送 SACKS 时，将使用 timer 控制 sack 的延迟发送，比如 min(RTO/2，200ms)。</p>

<p>发送端接收到对端回应的 SACK 后，判断如果其 cumulative tsn 比本地记录的最大的 last cumulative tsn 要大（即没有回退），则重启 ts_rtx_ 定时器。</p>

<h1 id="遗留问题">遗留问题</h1>

<h2 id="rtt-计算">RTT 计算</h2>

<p>有明显问题，如下两种：
在 dcsctp 中看到 RTT 的计算是有漏洞的，其在 sack 中没有 gap_ack_blocks 时，通过 cumulative tsn 计算其 rtt，存在两种风险:</p>
<ul>
  <li>这个 sack 整体是有延迟的，其计算 rtt 时，是直接通过 sendts - current ts，明显没有考虑 delay ack time；</li>
  <li>其只有在没有 gap_ack_blocks 时，即没有出现丢包时才统计其 RTT，这样在丢包严重时，可能会出现长时间无法更新 rtt，或者在 rtt 和 loss 突然增大时，出现长时间无法更新 rtt 的情况，一直以旧的 rtt 为准。</li>
</ul>]]></content><author><name>Mr Chen</name></author><category term="协议" /><summary type="html"><![CDATA[DataChannel 实现 DataChannel 的实现有两种，webrtc 目前使用自行基于 C++ 开发的 dcsctp，mediasoup 和 libdatachannel 基于 usrsctp，usrsctp 为开源 sctp 协议实现，均遵守 rfc 4960 标准。 RFC：https://tools.ietf.org/html/rfc4960]]></summary></entry></feed>