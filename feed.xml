<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2025-09-29T06:39:07+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">RUT protocol design</title><link href="https://gbcpp.github.io/protocol/rut-protocol-design.html" rel="alternate" type="text/html" title="RUT protocol design" /><published>2025-09-21T00:00:00+00:00</published><updated>2025-09-21T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/rut-protocol-design</id><content type="html" xml:base="https://gbcpp.github.io/protocol/rut-protocol-design.html"><![CDATA[<h2 id="设计思想">设计思想</h2>

<p>整体参考 quic，将协议格式在传输上进行分层，首先是 Packet 层，每次收发都是一个 Packet，比如用于握手建连的 InitialPacket 和建连后的 DataPacket。
在 Packet 内，是第二层，即 Frame 层，比如包括承载应用层数据的 StreamFrame，以及协议内 CC 用于实时反馈的 FeedbackFrame 和 pingpong frame 等。</p>

<h2 id="设计目标">设计目标</h2>

<p>基于 UDP 实现一个更加高效和通用的数据传输协议，既能满足在 RTC 场景下的数据低延迟传输（尽量到达），也能满足在直播、文件传输、IM 等场景下的可靠传输，在一个链接内通过创建不同的 stream，实现同时支持 可靠 和 不可靠传输，实现 stream 的优先级控制，保证高优先级数据的优先传输。</p>

<p>在协议内部整体通过自定义 Congestion contri algorithm 实现更优的数据传输速率的控制，在每条 stream 内使用不同的发送控制策略，以及 Fec 算法，以适配各种不同的应用场景。</p>

<h2 id="协议设计">协议设计</h2>

<blockquote>
  <p>我们通过 <a href="https://github.com/luismartingarcia/protocol">该工具 protocol</a> 来设计协议的具体格式。</p>
</blockquote>

<h2 id="packet">Packet</h2>

<p>Packet 主要分为两种，一种为在握手建连时的 InitialPacket，也可以认为是 HandshakePacket，在建链成功以后，便不再有此类数据包，后续全部使用 DataPacket，
用于传输应用层的数据，以及协议内的反馈包。</p>

<h3 id="packet-common-header">Packet Common Header</h3>

<p>Packet Common Header 是所有 Packet 的通用包头，包括 InitialPacket 和 DataPacket。
具体格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "type:1,connection_id:1,path_id:1,zero_rtt:1,cid_existence:1,reserved:3,pkt_no:24,connection_id:64,...:32"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|t|c|p|z|c|rese.|                     pkt_no                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                         connection_id                         +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

type：packet type,标识此包为 InitialPacket 还是 DataPacket，这里我们做如此约定：0: InitialPacket，1: DataPacket。
connection_id: 此包的包头中是否存在 connection_id 字段, connection_id 是实现连接迁移功能的作用字段，但并不是每个包都必须要带。
path_id: 在此 DataPacket 的 header 中是否存在 Patch Id 字段，用于开启 MultiPath 时标识数据属于哪一条 Path。
zero_rtt: 标识是否为 0-RTT 的数据包，即在 0-RTT 的建链场景中，用于在三次握手尚未完成时，一端已经开始发送数据，以此 flag 告知对端该数据包合法，需先缓存，在三次握手完成后，不再携带此 flag。
cid_existence: 该 Connection 在后续的连接中是否会使用 conenction id。
reserved: 保留位，用于以后能力扩展。
pkt_no：包序号，每次发送均递增。
payload：各种 frames 的集合。
</code></pre></div></div>

<h3 id="initialpacket">InitialPacket</h3>
<p>InitialPacket 用于初始化连接, 握手类似与 TCP 的3次握手，在在一次RTT中完成。</p>

<p>如上约定，InitialPacket 的 Packet Common Header 中的 type 为 0，在 Packet Common Header 之后，才是该数据包，InitialPacket 的具体格式设计如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "version:7,sync:1,ack:1,rst:1,early_data:1,tags:1,reserved:10,acked_pkt_no:32,early_data_len:16,early_data:112,tag_count:8,tag_len:16,tag_data:40,tag_len:16,tag_data:58"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   version   |s|a|r|e|t|      reserved     |                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                acked_pkt_no               |   early_data_len  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           |                                                   |
+-+-+-+-+-+-+                                                   +
|                                                               |
+                                                               +
|                           early_data                          |
+                                           +-+-+-+-+-+-+-+-+-+-+
|                                           |   tag_count   |   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          tag_len          |                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+
|                  tag_data                 |      tag_len      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           |                                                   |
+-+-+-+-+-+-+                                                   +
|                            tag_data                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

version：the corresponding protocol version, curently we use 1；
s：SYN；
a：ACK；
r：RST；
e：标识在该包中是否包含 early_data 数据段，如果包含则在后续的 data 中进行解析。
t：标识在该包中是否包含自定义的 tags，如果包含则在后续的 data 中进行解析。
</code></pre></div></div>

<h3 id="datapacket">DataPacket</h3>
<p>DataPacket encapsulates all kinds of Frames. Each DataPacket might contains one or more Frames.
DataPacket 封装了所有类型的 Frames，且每个 DataPacket 可以包含多个/种 Frames（至少一个 Frame）。</p>

<p>如上约定，DataPacket 的 Packet Common Header 中的 type 为 1，在 Packet Common Header 之后，才是该数据包，DataPacket 的具体格式设计如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "largest_acked_packet_num:24,path_id:4,frame_count:4,type:5,frame_length:11,frame_data:80,...:128,type:5,frame_length:11,frame_data:80"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            largest_acked_packet_num           |path_id|frame_.|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   type  |     frame_length    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                           frame_data                          +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                              ...                              +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   type  |     frame_length    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                           frame_data                          +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

largest_acked_packet_num：本端从远端接收到的最大的 Ack Packet number。
path_id: 当 Pcketet Common Header 中标识 path id 为 true 后，此字段有效，否则无效。
frame_count：在该包的 payload 中种打包了多少个 Frame。
</code></pre></div></div>

<h2 id="frame">Frame</h2>

<p>帧（Frame）是用来在连接建立后传输不同类型的消息的，比如应用层需要传输的数据，协议内部的统计、反馈数据等。</p>

<h3 id="frame-common-header">Frame Common Header</h3>

<p>Frame Common Header 是每个数据帧的统一包头。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "type:5,frame_length:11,...:48"

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   type  |     frame_length    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                            ...                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
type: 帧类型
frame_length：帧长度
</code></pre></div></div>

<p>暂时定义如下几种 Frame 类型：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">FrameType</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
  <span class="n">kStreamFrame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">kAckFrame</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">kPingFrame</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">kCloseFrame</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="n">kCongestionFeedbackFrame</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
  <span class="n">kControlFrame</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
  <span class="n">kPaddingFrame</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
  <span class="n">kPathEventFrame</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
  <span class="n">kMaxFrameType</span> <span class="o">=</span> <span class="mi">32</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="streamframe">StreamFrame</h3>
<p>StreamFrame 用于承载传输应用层数据.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "stream_id:16,option:1,metadata:1,push:1,reserved:5,writer_flags:8,opt_len:10,opt:40,meta_len:10,meta:48,payload:116"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           stream_id           |o|m|p| reserved|  writer_flags |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      opt_len      |                    opt                    |
+-+-+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                   |      meta_len     |       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       +
|                              meta                             |
+                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       |                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+                                       +
|                                                               |
+                                                               +
|                            payload                            |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

stream_id: 流 Id，整个 connection 内唯一。
option：标识是否携带有 option 数据，如果为 true，则后续 "opt_len" &amp; "opt" 字段均存在，用于传递 stream 内的自定义数据，用于协议内。
metadata：标识是否携带有 metadata 数据，如果为 true，则后续 "meta_len" &amp; "meta" 字段有效，用于传递应用层为该 stream 指定的自定义数据。
push: 标识该 frame 是否应该单独发送出去，而非与其它 Frame 组合发送。
writer_flags: stream 使用的 writer 类型， stream 内部实现传输模式。
reserved: no used
</code></pre></div></div>

<h3 id="ackframe">AckFrame</h3>

<p>AckFrame 用于在接收端对接收的 DataPacket 进行反馈。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "ts:1,ack_delay:8,largest_observed_packet_number:24,largest_observed_recv_time:32,range_length:8,range_count:8,next_range_gap1:8,range_length1:8,...:48,next_range_gapN:8,range_lengthN:8,ts_count:8,delta_number1:8,delta_ms1:8,...:72,delta_numberN:8,delta_msN:8"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|t|   ack_delay   |        largest_observed_packet_number       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| |                  largest_observed_recv_time                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| |  range_length |  range_count  |next_range_gap1|range_length1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| |                             ...                             |
+-+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                 |next_range_gapN|range_lengthN|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| |    ts_count   | delta_number1 |   delta_ms1   |             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             +
|                                                               |
+                                                               +
|                              ...                              |
+ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| | delta_numberN |   delta_msN   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


ts：表示数据中稍后是否会有数据包接收时间戳。
ack_delay：Acking largest_observed_packet_number 这个包序号的延迟时间，单位 ms。
largest_observed_packet_number：接收到最大的数据包序号。
largest_observed_recv_time：接收到 |largest_observed_packet_number| 包的时间。
range_count：the count of ranges;
next_range_gap：the gap in packet number from last range to current range;
range_length：the length of current range;
ts_count：后续数据中包接收时间戳的数量。
delta_number：从|largest_observed_packet_number|到当前包序号的差值。
delta_ms：从|largest_observed_packet_number|收时间到当前包接收时间的差值。
</code></pre></div></div>

<h3 id="closeframe">CloseFrame</h3>

<p>CloseFrame用于关闭特定的流或连接。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "stream_id:16,error_code:16,detail:64"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           stream_id           |           error_code          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                             detail                            +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

stream_id: 要关闭的流的ID，或使用0xFFFF来关闭连接。
error_code：当前关闭操作的错误码
detail：当前关闭操作的详细原因。
</code></pre></div></div>

<h3 id="congestionfeedbackframe">CongestionFeedbackFrame</h3>

<p>CongestionFeedbackFrame用于向对端报告一些网络统计信息。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "reserved:9,lost_ratio:7,delta_from_begin_ms:32,estimated_bandwidth_kbps:32,total_sent_kbps:32,outgoing_stream_count:16,jitter95:16,queueing_time:16,stream_id1:16,sent_kbps1:16,...:48,stream_idN:16,sent_kbpsN:16"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     reserved    |  lost_ratio |      delta_from_begin_ms      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |    estimated_bandwidth_kbps   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |        total_sent_kbps        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |     outgoing_stream_count     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            jitter95           |         queueing_time         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           stream_id1          |           sent_kbps1          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              ...                              |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |           stream_idN          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           sent_kbpsN          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<p>reserved: 保留位。
lost_ratio: 本地统计的丢包率。
delta_from_begin_ms: 发送此包时的链接时间。
estimated_bandwidth_kbps: 自行探测到的带宽，需要高于 16bits，否则65Mbps的带宽会被截断。
total_sent_kbps: 本链接共发送的数据量。
outgoing_stream_count: 发送方向创建的流的数量。
jitter95: 本端统计的 jitter95 指标。
queueing_time: 本端发送队列中的数据带以当前 bwe 需要多久时间发送结束。
stream_id1 和 sent_kbps1 用于标识每路流各自的发送速率。</p>

<h3 id="pingframe">PingFrame</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "kPing:5,frame_length:11"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  kPing  |     frame_length    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h3 id="controlframe">ControlFrame</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./protocol "type:8,frame_id:16,stream_id:16,payload:56"
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      type     |            frame_id           |   stream_id   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                            payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

type: 表示此控制帧的类型。
frame_id: 表示此帧的ID，每个控制帧都有唯一的ID。
stream_id: 表示此控制帧的流ID。
payload: 表示此控制帧的载荷，长度包含在frame_length中。
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>其中control frame 中的</td>
      <td>type</td>
      <td>暂先定义如下类型:</td>
    </tr>
  </tbody>
</table>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">ControlFrameType</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
  <span class="n">kOptionFrame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// 主要用作在传输过程中，对对端做远程的控制</span>

  <span class="n">kMax</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><category term="RUT" /><summary type="html"><![CDATA[设计思想]]></summary></entry><entry><title type="html">Install bcc and use memleak on Ubuntu22.04</title><link href="https://gbcpp.github.io/notes/install-bcc.html" rel="alternate" type="text/html" title="Install bcc and use memleak on Ubuntu22.04" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/install-bcc</id><content type="html" xml:base="https://gbcpp.github.io/notes/install-bcc.html"><![CDATA[<blockquote>
  <p>BCC (BPF Compiler Collection) 是一个强大的工具集，用于开发和运行基于 eBPF 的系统性能分析和网络监控工具。最近需要在为新的运行于 Ubuntu22.04 之上的服务排查内存泄漏的问题，而在 Ubuntu 系统中，虽然可以通过 apt 安装 BCC，但存在很多诡异的兼容性问题，通过源码编译安装的方式能获取最新功能并解决版本兼容问题。这里记录 bcc 在 Ubuntu22.04 下进行编译安装，并进行内存泄漏检测的全部过程。</p>
</blockquote>

<h2 id="环境准备">环境准备</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>su
apt update <span class="o">&amp;&amp;</span> apt upgrade <span class="nt">-y</span>

<span class="c"># 安装必要依赖</span>
apt <span class="nb">install</span> <span class="nt">-y</span> bison build-essential cmake flex git libedit-dev <span class="se">\</span>
  libllvm14 llvm-14-dev libclang-14-dev python3.11 zlib1g-dev libelf-dev <span class="se">\</span>
  libfl-dev python3-distutils pip zip arping netperf iperf3
</code></pre></div></div>

<p>确认 python 环境，安装必备包：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>setuptools
</code></pre></div></div>

<ul>
  <li><strong>安装内核头文件</strong></li>
</ul>

<p>bcc 需要依赖 Linux 内核的头文件，在 orb 虚拟机下，通过 <code class="language-plaintext highlighter-rouge">uname -r</code> 获取到的内核版本有特殊的后缀，无法直接安装。
如我的 orb 虚拟机：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ubuntu22:~/tools# <span class="nb">uname</span> <span class="nt">-r</span>
6.13.7-orbstack-00283-g9d1400e7e9c6

<span class="c"># 通过 apt install lin ux-headers-$(uname -r) 是查找不到对应的安装包的</span>
root@ubuntu22:~/tools# apt <span class="nb">install</span> <span class="nt">-y</span> linux-header-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
E: Unable to locate package linux-header-6.13.7-orbstack-00283-g9d1400e7e9c6
E: Couldn<span class="s1">'t find any package by glob '</span>linux-header-6.13.7-orbstack-00283-g9d1400e7e9c6<span class="s1">'
</span></code></pre></div></div>

<p>如果通过 <code class="language-plaintext highlighter-rouge">apt install linux-headers-$(uname -r)</code> 安装报错，则可以通过安装通用内核头文件版本进行替代：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install</span> <span class="nt">-y</span> linux-headers-generic
</code></pre></div></div>

<h2 id="源码编译步骤">源码编译步骤</h2>

<h3 id="获取源码">获取源码</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/iovisor/bcc.git
<span class="nb">cd </span>bcc
git checkout v0.34.0
</code></pre></div></div>

<h3 id="编译">编译</h3>

<p>依次执行如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build<span class="p">;</span> <span class="nb">cd </span>build
cmake ..
make
make <span class="nb">install
</span>cmake <span class="nt">-DPYTHON_CMD</span><span class="o">=</span>python3 ..
<span class="nb">pushd </span>src/python/
make
make <span class="nb">install
popd</span>
</code></pre></div></div>

<h3 id="验证安装">验证安装</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 依然在 bcc/build 目录下，执行  ./examples/cpp/HelloWorld 输出如下内容即表示编译安装 c++版本可以正常运行</span>
root@:~/workspace/tools/bcc/build# ./examples/cpp/HelloWorld
Starting HelloWorld with BCC 0.34.0+1f63ae6e
           &lt;...&gt;-357844  <span class="o">[</span>002] ....1 1312511.496364: bpf_trace_printk: Hello, World! Here I did a sys_clone call!


<span class="c"># 验证 python 工具是否可用，输出如下内容标识正常可用</span>
<span class="o">(</span>base<span class="o">)</span> root@iZ2ze8gd919c5qtgeqbovnZ:~/workspace/tools/bcc/build# python3 ../examples/hello_world.py
b<span class="s1">'           &lt;...&gt;-356665  [000] ....1 1312599.534997: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'           &lt;...&gt;-3542460 [008] ....1 1312599.535595: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'         flannel-3542460 [008] ....1 1312599.535643: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'         flannel-3542460 [008] ....1 1312599.535675: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'           &lt;...&gt;-3542462 [011] ....1 1312599.535707: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'     cri-dockerd-356665  [000] ....1 1312599.536306: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'           &lt;...&gt;-3542465 [008] ....1 1312599.536762: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'         portmap-3542465 [008] ....1 1312599.536807: bpf_trace_printk: Hello, World!'</span>
b<span class="s1">''</span>
b<span class="s1">'         portmap-3542465 [008] ....1 1312599.536850: bpf_trace_printk: Hello, World!'</span>
</code></pre></div></div>

<h2 id="常见问题">常见问题</h2>

<h3 id="cmake-时报-kernel-headers-kernelheaders_dir-notfound">cmake 时报 Kernel headers: KERNELHEADERS_DIR-NOTFOUND</h3>

<p>cmake 找不到 <code class="language-plaintext highlighter-rouge">linux-headers</code> 目录，如果明确已经安装了，确依然报此问题，则在 <code class="language-plaintext highlighter-rouge">cmake ..</code> 时指定 <code class="language-plaintext highlighter-rouge">linux-headers-generic</code> 的安装目录即可，如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake .. <span class="nt">-DKERNELHEADERS_DIR</span><span class="o">=</span><span class="s2">"/usr/include/x86_64-linux-gnu"</span>
</code></pre></div></div>

<h3 id="make-时报-python3-相关错误modulenotfounderror">make 时报 python3 相关错误：ModuleNotFoundError</h3>

<p>如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"/home/chengaoyuan/opensource/bcc/build/src/python/bcc-python3/setup.py"</span>, line 3, <span class="k">in</span> &lt;module&gt;
    from setuptools import setup
ModuleNotFoundError: No module named <span class="s1">'setuptools'</span>
make[2]: <span class="k">***</span> <span class="o">[</span>src/python/CMakeFiles/bcc_py_python3.dir/build.make:84: src/python/bcc-python3/dist/bcc-0.34.0+d7667cf9.tar.gz] Error 1
make[1]: <span class="k">***</span> <span class="o">[</span>CMakeFiles/Makefile2:1047: src/python/CMakeFiles/bcc_py_python3.dir/all] Error 2
make: <span class="k">***</span> <span class="o">[</span>Makefile:146: all] Error 2
</code></pre></div></div>

<p>原因为系统的 Python 环境可能被自己折腾乱了，直接手动补充安装即可：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install</span> <span class="nt">-y</span> pip
pip3 <span class="nb">install </span>setuptools
</code></pre></div></div>

<h3 id="找不到lbbccsoo-中某个符号">找不到lbbcc.so.o 中某个符号</h3>

<p>执行 hello_world.py 脚本输出报错类似如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AttributeError: /lib/x86_64-linux-gnu/libbcc.so.0: undefined symbol: bpf_module_create_b
</code></pre></div></div>

<p>原因为 python3 中加载以来的 libbcc.so 版本与编译安装的不匹配导致，将 bcc/build 中生成的对 python3 进行覆盖即可：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 进入 bcc/build 目录</span>
<span class="nb">cp</span> <span class="nt">-rf</span> ./src/python/bcc-python3/bcc/<span class="k">*</span> /usr/lib/python3/dist-packages/bcc/
</code></pre></div></div>

<h3 id="找不到-asmtypesh-头文件">找不到 <code class="language-plaintext highlighter-rouge">asm/types.h</code> 头文件</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ubuntu22:~/tools# /usr/share/bcc/examples/hello_world.py<span class="o">)</span>
In file included from &lt;built-in&gt;:2:
In file included from /virtual/include/bcc/bpf.h:12:
In file included from include/linux/types.h:6:
include/uapi/linux/types.h:5:10: fatal error: <span class="s1">'asm/types.h'</span> file not found
<span class="c">#include &lt;asm/types.h&gt;</span>
         ^~~~~~~~~~~~~
1 error generated.
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"/usr/share/bcc/examples/hello_world.py"</span>, line 12, <span class="k">in</span> &lt;module&gt;
    BPF<span class="o">(</span><span class="nv">text</span><span class="o">=</span><span class="s1">'int kprobe__sys_clone(void *ctx) { bpf_trace_printk("Hello, World!\\n"); return 0; }'</span><span class="o">)</span>.trace_print<span class="o">()</span>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File <span class="s2">"/usr/lib/python3/dist-packages/bcc/__init__.py"</span>, line 505, <span class="k">in </span>__init__
    raise Exception<span class="o">(</span><span class="s2">"Failed to compile BPF module %s"</span> % <span class="o">(</span>src_file or <span class="s2">"&lt;text&gt;"</span><span class="o">))</span>
Exception: Failed to compile BPF module &lt;text&gt;
</code></pre></div></div>

<blockquote>
  <p>在 orb 下的 ubuntu 虚拟机中遇到的，在 orbstack 的 ubuntu 下暂时未解决，网上找的解决方案基本是两种，可以尝试下，不过在我的 orbstack ubuntu 下不生效。
1、主动link /usr/include/x86_64-linux-gnu/asm 到 /usr/include/asm，也就是软链接过去。
2、另一种方案是通过安装 gcc-multilib 进行解决：apt-get install -y gcc-multilib。</p>
</blockquote>

<h2 id="内存泄漏检测">内存泄漏检测</h2>

<h3 id="示例代码">示例代码</h3>

<p>命名为 <code class="language-plaintext highlighter-rouge">test.cpp</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="n">g_vec</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">memory_test</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">111</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="n">g_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ptr2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__PRETTY_FUNCTION__</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_func</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">num</span><span class="p">;</span>
  <span class="n">memory_test</span><span class="p">();</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 模拟内存泄漏</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">my_func</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">itor</span> <span class="o">:</span> <span class="n">g_vec</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">free</span><span class="p">(</span><span class="n">itor</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="静态编译链接方式检测">静态编译链接方式检测</h3>

<p>使用静态方式进行编译：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-g</span> <span class="nt">-static</span> test.cpp <span class="nt">-o</span> test.exe
</code></pre></div></div>

<p>生成的 <code class="language-plaintext highlighter-rouge">test.exe</code> 二进制文件无任何依赖，所以系统调用的一些接口符号均在 <code class="language-plaintext highlighter-rouge">test.exe</code> 文件中。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">memleak</code> 进行检测(需要 root 权限)：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -O 为指定符号文件； -p 为指定进程的 ID</span>
memleak <span class="nt">-O</span> test.exe <span class="nt">-p</span> <span class="k">${</span><span class="nv">pid</span><span class="k">}</span>
</code></pre></div></div>

<p><em>输出内容：</em></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>base<span class="o">)</span> root@iZ2ze8gd919c5qtgeqbovnZ:~/workspace/tools/bcc/build# ps <span class="nt">-aef</span> | <span class="nb">grep test
</span>root     3553018 3552090  0 21:56 pts/0    00:00:00 ./test.exe
root     3553054 3357603  0 21:56 pts/10   00:00:00 <span class="nb">grep</span> <span class="nt">--color</span><span class="o">=</span>auto <span class="nb">test</span>
<span class="o">(</span>base<span class="o">)</span> root@iZ2ze8gd919c5qtgeqbovnZ:~/workspace/tools/bcc/build# memleak-bpfcc <span class="nt">-O</span> /root/workspace/debug/test.exe <span class="nt">-p</span> 3553018
Attaching to pid 3553018, Ctrl+C to quit.
<span class="o">[</span>21:56:42] Top 10 stacks with outstanding allocations:
	555 bytes <span class="k">in </span>5 allocations from stack
		memory_test<span class="o">()</span>+0x33 <span class="o">[</span>test.exe]
		my_func<span class="o">(</span>int<span class="o">)</span>+0x14 <span class="o">[</span>test.exe]
		main+0x2e <span class="o">[</span>test.exe]
		__libc_start_call_main+0x6a <span class="o">[</span>test.exe]
<span class="o">[</span>21:56:47] Top 10 stacks with outstanding allocations:
	256 bytes <span class="k">in </span>1 allocations from stack
		operator new<span class="o">(</span>unsigned long<span class="o">)</span>+0x1c <span class="o">[</span>test.exe]
		std::allocator_traits&lt;std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::allocate<span class="o">(</span>std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span>&amp;, unsigned long<span class="o">)</span>+0x2c <span class="o">[</span>test.exe]
		std::_Vector_base&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::_M_allocate<span class="o">(</span>unsigned long<span class="o">)</span>+0x2e <span class="o">[</span>test.exe]
		void std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::_M_realloc_insert&lt;char<span class="k">*</span> const&amp;&gt;<span class="o">(</span>__gnu_cxx::__normal_iterator&lt;char<span class="k">**</span>, std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>, char<span class="k">*</span> const&amp;<span class="o">)</span>+0x95 <span class="o">[</span>test.exe]
		std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::push_back<span class="o">(</span>char<span class="k">*</span> const&amp;<span class="o">)</span>+0x7c <span class="o">[</span>test.exe]
		memory_test<span class="o">()</span>+0x60 <span class="o">[</span>test.exe]
		my_func<span class="o">(</span>int<span class="o">)</span>+0x14 <span class="o">[</span>test.exe]
		main+0x2e <span class="o">[</span>test.exe]
		__libc_start_call_main+0x6a <span class="o">[</span>test.exe]
	1110 bytes <span class="k">in </span>10 allocations from stack
		memory_test<span class="o">()</span>+0x33 <span class="o">[</span>test.exe]
		my_func<span class="o">(</span>int<span class="o">)</span>+0x14 <span class="o">[</span>test.exe]
		main+0x2e <span class="o">[</span>test.exe]
		__libc_start_call_main+0x6a <span class="o">[</span>test.exe]
<span class="o">[</span>21:56:52] Top 10 stacks with outstanding allocations:
	256 bytes <span class="k">in </span>1 allocations from stack
		operator new<span class="o">(</span>unsigned long<span class="o">)</span>+0x1c <span class="o">[</span>test.exe]
		std::allocator_traits&lt;std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::allocate<span class="o">(</span>std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span>&amp;, unsigned long<span class="o">)</span>+0x2c <span class="o">[</span>test.exe]
		std::_Vector_base&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::_M_allocate<span class="o">(</span>unsigned long<span class="o">)</span>+0x2e <span class="o">[</span>test.exe]
		void std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::_M_realloc_insert&lt;char<span class="k">*</span> const&amp;&gt;<span class="o">(</span>__gnu_cxx::__normal_iterator&lt;char<span class="k">**</span>, std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>, char<span class="k">*</span> const&amp;<span class="o">)</span>+0x95 <span class="o">[</span>test.exe]
		std::vector&lt;char<span class="k">*</span>, std::allocator&lt;char<span class="k">*</span><span class="o">&gt;</span> <span class="o">&gt;</span>::push_back<span class="o">(</span>char<span class="k">*</span> const&amp;<span class="o">)</span>+0x7c <span class="o">[</span>test.exe]
		memory_test<span class="o">()</span>+0x60 <span class="o">[</span>test.exe]
		my_func<span class="o">(</span>int<span class="o">)</span>+0x14 <span class="o">[</span>test.exe]
		main+0x2e <span class="o">[</span>test.exe]
		__libc_start_call_main+0x6a <span class="o">[</span>test.exe]
	1665 bytes <span class="k">in </span>15 allocations from stack
		memory_test<span class="o">()</span>+0x33 <span class="o">[</span>test.exe]
		my_func<span class="o">(</span>int<span class="o">)</span>+0x14 <span class="o">[</span>test.exe]
		main+0x2e <span class="o">[</span>test.exe]
		__libc_start_call_main+0x6a <span class="o">[</span>test.exe]
</code></pre></div></div>

<p>每 10 秒钟输出一次，<code class="language-plaintext highlighter-rouge">Top 10 stacks with outstanding allocations:</code> 下面为内存申请且未释放的前 10 个堆栈信息。</p>

<h3 id="非静态编译链接方式检测">非静态编译链接方式检测</h3>

<p>使用非静态方式进行编译：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-g</span> test.cpp <span class="nt">-o</span> test.exe
</code></pre></div></div>

<p>生成的 <code class="language-plaintext highlighter-rouge">test.exe</code> 二进制文件有系统标准库依赖，如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>base<span class="o">)</span> root@:~/workspace/debug# ldd test.exe
	linux-vdso.so.1 <span class="o">(</span>0x00007fffab6d7000<span class="o">)</span>
	libstdc++.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libstdc++.so.6 <span class="o">(</span>0x00007f3ca7fb6000<span class="o">)</span>
	libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f3ca7d8d000<span class="o">)</span>
	libm.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libm.so.6 <span class="o">(</span>0x00007f3ca7ca6000<span class="o">)</span>
	/lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f3ca81f3000<span class="o">)</span>
	libgcc_s.so.1 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libgcc_s.so.1 <span class="o">(</span>0x00007f3ca7c86000<span class="o">)</span>
</code></pre></div></div>

<p>我们要动态追踪的系统调用 malloc、free 等在 libc.so 中，所以通过 -O 指定的符号文件在 /lib/x86_64-linux-gnu/libc.so.6 中。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">memleak</code> 进行检测(需要 root 权限)：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -O 为指定符号文件； -p 为指定进程的 ID</span>
memleak <span class="nt">-O</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="nt">-p</span> <span class="k">${</span><span class="nv">pid</span><span class="k">}</span>
</code></pre></div></div>

<p><em>输出内容：</em></p>

<p>同静态编译链接方式内容。</p>

<h3 id="精确定位行号">精确定位行号</h3>

<p>有时候仅仅输出函数名称还不足够明确定位代码具体位置（如：函数体较长，存在多个申请内存的操作），那么就需要通过 <code class="language-plaintext highlighter-rouge">objdump</code> 和 <code class="language-plaintext highlighter-rouge">addr2line</code> 工具对函数地址进行解析。
这两个工具需要安装 <code class="language-plaintext highlighter-rouge">binutils，安装： </code>apt-get install -y binutils`。</p>

<p>例如需要排查上述一处 memory_test 中的一处内存泄漏：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	555 bytes <span class="k">in </span>5 allocations from stack
		memory_test<span class="o">()</span>+0x33 <span class="o">[</span>test.exe]
</code></pre></div></div>

<ul>
  <li>首先通过 objdump 找到二进制中函数地址</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>objdump <span class="nt">-d</span> test.exe | <span class="nb">grep </span>memory_test
0000000000404605 &lt;_Z11memory_testv&gt;:
  404641:       74 0c                   je     40464f &lt;_Z11memory_testv+0x4a&gt;
  40469e:       74 05                   je     4046a5 &lt;_Z11memory_testv+0xa0&gt;
  4046b6:       e8 4a ff ff ff          call   404605 &lt;_Z11memory_testv&gt;
000000000040481f &lt;_GLOBAL__sub_I__Z11memory_testv&gt;:
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">_Z11memory_testv</code> 为 <code class="language-plaintext highlighter-rouge">c++</code> 编译器为 <code class="language-plaintext highlighter-rouge">memory_test</code> 生成的修饰名，<code class="language-plaintext highlighter-rouge">_Z11</code> 表示这是一个函数，<code class="language-plaintext highlighter-rouge">v</code> 表示函数参数为空。
找到 <code class="language-plaintext highlighter-rouge">memory_test</code> 的函数地址为<code class="language-plaintext highlighter-rouge">404605</code> ,内存泄漏位置的函数偏移为 <code class="language-plaintext highlighter-rouge">0x33，则内存地址为</code> <code class="language-plaintext highlighter-rouge">0x404605 + 0x33 = 0x404638</code>，所以具体的泄漏代码位置为：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>addr2line <span class="nt">-e</span> test.exe 0x404638
/mnt/data/debug/test.cpp:9
</code></pre></div></div>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>通过 nm 也可以获取指定函数的地址，如： nm test.exe</td>
        <td>grep memory_test</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="与-asanaddress-sanitizer-的区别">与 ASAN(Address Sanitizer) 的区别</h3>

<p>通过 bcc 的 memleak 进行内存泄漏的检测，即可以对明显的 new/malloc 与 delete/free 的不对称进行检测，bcc 的 memleak 的主要优势在于可以在不重启进程，同时在不对进程造成任何性能影响的情况下，对内存进行检测。
还有就是对类似示例代码中对 vector 不断的增加数据导致内存不断的增长，但实际数据并为泄漏，在程序退出时还会删除的这种场景是不同于 ASAN 的检测的（ASAN 不检测这种场景），这类问题反而是线上最难解决的内存泄漏的问题。</p>

<p>但是 bcc 的 memleak 没有 ASAN 的内存越界、践踏的检测，所以在开发测试阶段应该用 ASAN 进行验证，及时找出内存的错误操作，消除 crash 的风险。</p>

<h2 id="todo">TODO</h2>

<p>1、 解决 orbstack 下 ubuntu 源码安装 bcc。</p>

<p>2、 将 ubuntu 下源码编译安装的 bcc tools进行 dep 打包，实现一键安装。</p>

<h2 id="参考资料">参考资料</h2>

<p>BCC 官方文档：https://github.com/iovisor/bcc/blob/master/INSTALL.md</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="bcc" /><category term="ebpf" /><summary type="html"><![CDATA[BCC (BPF Compiler Collection) 是一个强大的工具集，用于开发和运行基于 eBPF 的系统性能分析和网络监控工具。最近需要在为新的运行于 Ubuntu22.04 之上的服务排查内存泄漏的问题，而在 Ubuntu 系统中，虽然可以通过 apt 安装 BCC，但存在很多诡异的兼容性问题，通过源码编译安装的方式能获取最新功能并解决版本兼容问题。这里记录 bcc 在 Ubuntu22.04 下进行编译安装，并进行内存泄漏检测的全部过程。]]></summary></entry><entry><title type="html">Mac 系统环境配置异常记录</title><link href="https://gbcpp.github.io/notes/mac-env-fix.html" rel="alternate" type="text/html" title="Mac 系统环境配置异常记录" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/mac-env-fix</id><content type="html" xml:base="https://gbcpp.github.io/notes/mac-env-fix.html"><![CDATA[<blockquote>
  <p>整理记录 Mac 下开发、学习环境中遇到的疑难杂症及其解决过程和方案。</p>
</blockquote>

<h1 id="mac-下-vscode-和-cursor-ide-的-vim-插件长按键不生效">Mac 下 VSCode 和 Cursor IDE 的 vim 插件长按键不生效</h1>

<ul>
  <li>VSCode</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 标准版 VSCode</span>
defaults write com.microsoft.VSCode ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VSCode Insider 版</span>
defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VS Codium</span>
defaults write com.vscodium ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VS Codium Exploration 用户</span>
defaults write com.microsoft.VSCodeExploration ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># 全局设置（慎用）</span>
defaults delete <span class="nt">-g</span> ApplePressAndHoldEnabled
</code></pre></div></div>

<ul>
  <li>Cursor</li>
</ul>

<p>虽然 Cursor 也是基于 VSCode，但是需要额外的配置才行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults write <span class="s2">"</span><span class="si">$(</span>osascript <span class="nt">-e</span> <span class="s1">'id of app "Cursor"'</span><span class="si">)</span><span class="s2">"</span> ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>
</code></pre></div></div>

<blockquote>
  <p>上述命令执行完后，均需要重启 IDE。</p>
</blockquote>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[整理记录 Mac 下开发、学习环境中遇到的疑难杂症及其解决过程和方案。]]></summary></entry><entry><title type="html">HTTP3/QUIC 在部分iPhone设备下卡顿问题排查</title><link href="https://gbcpp.github.io/notes/quic-stuck-on-iphone.html" rel="alternate" type="text/html" title="HTTP3/QUIC 在部分iPhone设备下卡顿问题排查" /><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/quic-stuck-on-iphone</id><content type="html" xml:base="https://gbcpp.github.io/notes/quic-stuck-on-iphone.html"><![CDATA[<blockquote>
  <p>  直播的边缘服务器开启 HTTP3 以后，出现 iPhone 的部分机型明显卡顿的问题，而 HTTP2 确不会，明显不符合预期。正常应该是使用了 QUIC 的 HTTP3 的传输效果优于 TCP 才对，这才是大部分机型的表现。</p>
</blockquote>

<h2 id="排查过程">排查过程</h2>

<h3 id="协议对比">协议对比</h3>

<p>在指定的 iPhone 设备上通过后台控制、确认播放端使用的 HTTP 版本，明确在正常的网络环境下使用 TCP 的播放效果要明显优于基于 UDP 的 HTTP3，明显问题现象。</p>

<h3 id="mtu-问题">MTU 问题</h3>

<p>通过打开 quic-go 中的 debug log，看到播放端在出现卡顿时，出现大概率的 <code class="language-plaintext highlighter-rouge">lost packet</code>，怀疑是 quic-go 的 MTU 探测问题，探测到错误的 max packet size 导致发送了过大的数据包触发的 IP 分片导致的丢失。</p>

<p>  。。。。。。   此处省略一万字，debug 排查 guic-go 中的 MTU 探测模块代码逻辑简单、清晰，没有代码问题。</p>

<p>那么如果将 quic-go 中的 MTU 探测关闭，让其一直固定使用 initial 的 max packet size：1252，会有问题吗？</p>

<p>通过 quic-go 的配置 <code class="language-plaintext highlighter-rouge">DisablePathMTUDiscovery</code> 将其置为 <code class="language-plaintext highlighter-rouge">true</code>, 其默认为 <code class="language-plaintext highlighter-rouge">false</code>，进行测试验证后，发现卡顿现象消失了，可以明确问题就是 MTU 的问题了，链路上发送了超过实际 MTU 大小的数据，触发的 IP 分片导致大量的丢包，从而出现的卡顿。</p>

<h3 id="抓包验证">抓包验证</h3>

<p>依然开启 quic-go 的 MTU-Discorver 功能: <code class="language-plaintext highlighter-rouge">DisablePathMTUDiscovery</code> 将其置为 <code class="language-plaintext highlighter-rouge">false</code>。</p>

<ul>
  <li>Server 测抓包</li>
</ul>

<p>Server 测通过 <code class="language-plaintext highlighter-rouge">tcpdump</code> 抓包即可，命令： <code class="language-plaintext highlighter-rouge">tcpdump -i any -s 1500 udp src port 4443 -v</code> 抓取自己从 HTTP3 端口 4443 发送方向的数据包，重点是查看数据包的大小是否有在本地发送时出现切包的情况。</p>

<ul>
  <li>iPhone 设备测抓包</li>
</ul>

<p>通过 <code class="language-plaintext highlighter-rouge">xcode</code> 工具集中的 <code class="language-plaintext highlighter-rouge">rvictl</code> 结合 <code class="language-plaintext highlighter-rouge">wireshark</code> 进行抓包。</p>

<p>首先 Mac 上需要安装 <code class="language-plaintext highlighter-rouge">xcode</code> 开发工具，将 iPhone 连接 Mac 后，通过 xcode 查看该 iPhone 设备的 Identifier ID，在 <code class="language-plaintext highlighter-rouge">xcode</code> 的 <code class="language-plaintext highlighter-rouge">window</code> 菜单 ==<code class="language-plaintext highlighter-rouge">》Device</code> 选项 进行查看：</p>

<p><img src="/assets/img/blog/xcode-identifier.png" alt="获取 iPhone ID" /></p>

<p><strong>启动虚拟网卡：</strong></p>

<p>Terminal 中命令启动：<code class="language-plaintext highlighter-rouge">rvictl -s 00008130-00012C163EC2001C </code>，如果失败，会有 <code class="language-plaintext highlighter-rouge">FAILED</code> 的输出提示。</p>

<p><strong>启动 WireShark：</strong></p>

<p>需要 <code class="language-plaintext highlighter-rouge">root </code>权限，从 Terminal 中进行启动： <code class="language-plaintext highlighter-rouge">sudo wireshark</code>，选择网卡 <strong>rvi</strong> 网卡进行抓取，可以添加过滤条件，如：<code class="language-plaintext highlighter-rouge">udp.port == 4443</code></p>

<ul>
  <li>复现抓包</li>
</ul>

<p>手机测通过 HTTP3 拉流复现后，分别查看 Server 和 iPhone 测的抓包结果进行分析：</p>

<p>下图可以看到server 在发送 1400+ 的数据包的时候，是未分片且带有 <code class="language-plaintext highlighter-rouge">DF</code> flag 的，<strong>server 发送的所有数据包均是如此</strong>：</p>

<p><img src="/assets/img/blog/server-quic-capture0.png" alt="Server 抓包截图（未切片）" /></p>

<p>iPhone 测抓包可以看到首先收到的 1400+ 的 数据包是带有 <code class="language-plaintext highlighter-rouge">DF</code> flag 的，同时也没有进行切片，如下图：</p>

<p><img src="/assets/img/blog/client-quic-capture.png" alt="iPhone 抓包1（首先无分片）" /></p>

<p>但是在后面很快就出现了 IP 分片，且去除了 DF flag 的数据包，iPhone 测只能接收到一半的数据包：</p>

<p><img src="/assets/img/blog/client-quic-capture2.png" alt="iPhone 抓包2（被分片）" /></p>

<blockquote>
  <p>注意：该问题在仅在我司的 Wifi 网络环境下存在，4G/5G 网络条件下不存在。</p>
</blockquote>

<h2 id="结论">结论</h2>

<p>   通过上述抓包可以看到是因为链路中某个路由设备对 MTU 大于 1400 的数据包进行了强行切片，分成了 2 片进行发送，这里存在两个问题：</p>

<p>1、该路由设备放行了前面一小部分大于 1400 的数据包，接收端接收并 Ack 给了发送端，导致发送端的 Mtu 探测模块爬升到了更高的值，但是后面该路由设备又对 1400+ 的数据包改变了策略，不允许通过，而 quic-go 中的 mtu 探测模块又没有向下探测 mtu 的能力，导致业务遇到该场景必死无疑。</p>

<p>2、发送端发送的数据包已经明确设置了 <code class="language-plaintext highlighter-rouge">DF</code> 即 <code class="language-plaintext highlighter-rouge">Don't fragment</code> 的 flag，路由设备在收到超过自己 MTU 设备时应该直接丢掉，而非先进行放行，然后强行忽略 DF flag 进行切片转发，让接收端产生误判。</p>

<p>   对比抓取其它使用 HTTP3/QUIC 协议的 APP 数据包，比如油管的短视频和直播，可以看到其并未向上探测 MTU，使用的是固定的 1250 这样的一个 MTU 大小。</p>

<p>   使用 1300 以内的 MTU 大小是网络兼容性最好选择，但是会牺牲一定的服务器网络数据包处理的性能，像 Google 这样的 APP 亦是如此。如果需要追求极致性能，还有一个解决方案，那就是为 MTU 探测模块增加向下探测的能力，比如这种场景，已经探测到了 1400 的大小，但是后续路由器开启切片导致大量的丢包，协议内部开始向下探测 MTU 大小，或者重新从 1000/1200 开始探测即可。</p>

<h2 id="后续">后续</h2>

<p>   无</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Protocol" /><summary type="html"><![CDATA[  直播的边缘服务器开启 HTTP3 以后，出现 iPhone 的部分机型明显卡顿的问题，而 HTTP2 确不会，明显不符合预期。正常应该是使用了 QUIC 的 HTTP3 的传输效果优于 TCP 才对，这才是大部分机型的表现。]]></summary></entry><entry><title type="html">golang 问题记录</title><link href="https://gbcpp.github.io/notes/golang-issues.html" rel="alternate" type="text/html" title="golang 问题记录" /><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/golang-issues</id><content type="html" xml:base="https://gbcpp.github.io/notes/golang-issues.html"><![CDATA[<p>  </p>
<blockquote>
  <p>记录 Golang 学习、开发过程中的一些疑难杂症。</p>
</blockquote>

<h1 id="环境问题">环境问题</h1>

<h2 id="missing-gosum-entry-for-module">missing go.sum entry for module</h2>

<p>曾经编译过的代码出现类似如下的错误 <code class="language-plaintext highlighter-rouge">missing go.sum entry for module</code>，各种依赖缺失的 mod，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base/file.go:10:2: missing go.sum entry for module providing package github.com/astaxie/beego/logs; to add:
	go mod download github.com/astaxie/beego
base/name_generate.go:6:2: missing go.sum entry for module providing package github.com/google/uuid (imported by ben/base); to add:
	go get ben/base
helpers/data_analysis/base/bar_base.go:6:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/charts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/metrics.go:9:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/components (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/bar_base.go:7:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/opts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
</code></pre></div></div>

<p><strong>解决办法</strong></p>

<p>使用 <code class="language-plaintext highlighter-rouge">go mod tidy</code> 来整理依赖，该命令有如下作用：</p>

<ul>
  <li>删除不需要的依赖包</li>
  <li>下载新的依赖包</li>
  <li>更新 <code class="language-plaintext highlighter-rouge">go.sum</code></li>
</ul>

<p>重新执行 <code class="language-plaintext highlighter-rouge">go run</code> <code class="language-plaintext highlighter-rouge">go build</code> 问题解决。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[   记录 Golang 学习、开发过程中的一些疑难杂症。]]></summary></entry><entry><title type="html">直播回源优化</title><link href="https://gbcpp.github.io/notes/optimize-back-to-source.html" rel="alternate" type="text/html" title="直播回源优化" /><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/optimize-back-to-source</id><content type="html" xml:base="https://gbcpp.github.io/notes/optimize-back-to-source.html"><![CDATA[<blockquote>
  <p>该文档主要考虑的是针对需要回源时秒开的优化。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>  当前 streamd server 在收到拉流请求时，若需要回源，在回源后 streamd 下发给 Player 数据时使用的是帧级别的下发，特别是在接收首个关键帧时，只有接收到完整的视频帧以后，方才开始下发给 Player，这样无形中增加了一定的数据接收+组帧的耗时，通过当前 superset 的数据分析，在需要回源的 case 中， streamd 等待接收首个视频关键帧的时长几乎全部超过 100ms 以上，这便为该次播放请求增加了固定时间的延迟，优化空间明显。</p>

<h1 id="优化内容">优化内容</h1>

<p>  针对当前数据转发的模式，将帧级别的转发模式优化为 Slice 级别的转发模式。</p>

<h2 id="流程图">流程图</h2>

<p><img src="/assets/img/blog/streamd-optimize.png" alt="数据转发流程图" /></p>

<h2 id="优点">优点</h2>

<ul>
  <li>加快秒开速度，减少回源阶段 Block 等待时间，初步估计对回源 case 的秒开优化在百毫秒以上。</li>
  <li>Streamd 下发数据时基于 Slice 进行下发，数据发送更加平滑，减少 Frame 级别的下发带来的网络拥塞，有益于卡顿率的降低。</li>
</ul>

<h2 id="缺点">缺点</h2>

<p>  Streamd 服务在各协议的封装性上需要结构性的调整，数据流程改动较大，需要考虑不同 Protocol/Muxer/Demuxer 之间的兼容性，可能难以实现所有 Protocol/Muxer/Demuxer 之间的分片转发，但依然有很大的优化场景需求。
最理想的情况为：源站提供 FLV 的数据拉流协议，而 Streamd 也是用 FLV 的回源拉流协议，Streamd 在接收端最多需要处理 FLV Header Tag 的部分信息，不阻塞 Slice 的下发。</p>

<h2 id="flv-格式">FLV 格式</h2>

<p><a href="https://blog.ibaoger.com/2017/06/04/flv-file-format/">Reference URL</a></p>

<p><img src="/assets/img/blog/flv-format.png" alt="FLV format" /></p>

<h1 id="srs-现状">SRS 现状</h1>

<p>  那么问题来了， srs 是否已经考虑到这一点的优化空间呢？</p>

<p>  对比查看 srs 是否使用的这种透明转发模式，还是帧转发模式？
这里记录的为使用 HTTP-FLV 回源协议的代码流程。</p>

<p>srs 需要回源时建议优先使用 Edge 模式，回源时，内部首先创建一个 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream</code> 实例，用于向源站发起连接，并用于实时的接收、处理数据，代码文件：<code class="language-plaintext highlighter-rouge">srs_app_edge.cpp</code>。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">connect</code> ==&gt; <code class="language-plaintext highlighter-rouge">do_connect</code> 发起向源站的连接请求，判定 http response status code 非 404、非 302 后，开始接收、处理媒体数据。</p>

<p>事件轮询在 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::ingest()</code> 中，同步模式不断循环执行 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream::recv_message()</code> 接收完整的数据，而后通过 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::process_publish_message</code> 将数据流转到后序处理的模块，比如 Source、Consumer 等，但在这之前重点是确认在 recv_message 中是否会 block 等待完整的一个 tag data。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsEdgeFlvUpstream</span><span class="o">::</span><span class="n">recv_message</span><span class="p">(</span><span class="n">SrsCommonMessage</span><span class="o">**</span> <span class="n">pmsg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">time</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag header"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">srs_freepa</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag data"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">pps</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_previous_tag_size</span><span class="p">(</span><span class="n">pps</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read pts"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">stream_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SrsCommonMessage</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">srs_rtmp_create_msg</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"create message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">pmsg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到首先读取 tag_header，然后从header 中获取 tag size 开始读取指定size 的tag data，<code class="language-plaintext highlighter-rouge">SrsFlvDecoder::read_tag_data()</code> ==» <code class="language-plaintext highlighter-rouge">SrsHttpFileReader:read()</code></p>

<p>可以看到在 <code class="language-plaintext highlighter-rouge">SrsHttpFileReader::read(void* buf, size_t count, ssize_t* pnread)</code> 中其会持续的尝试去接收指定 size 大小的数据，直到接收完整，或者 io 报错，源码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsHttpFileReader</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="o">*</span> <span class="n">pnread</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">http</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">total_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total_read</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">ssize_t</span> <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">http</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">total_read</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">count</span> <span class="o">-</span> <span class="n">total_read</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nread</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">srs_assert</span><span class="p">(</span><span class="n">nread</span><span class="p">);</span>
        <span class="n">total_read</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pnread</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pnread</span> <span class="o">=</span> <span class="n">total_read</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>结论：</strong> 当前 srs 使用的是帧级别的转发模式，没有实现分片的透明转发。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[该文档主要考虑的是针对需要回源时秒开的优化。]]></summary></entry><entry><title type="html">直播场景TCP秒开优化</title><link href="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html" rel="alternate" type="text/html" title="直播场景TCP秒开优化" /><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/tcp-optimize-livestream-scene</id><content type="html" xml:base="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html"><![CDATA[<blockquote>
  <p>当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>公司使用静态节点和动态节点作为边缘以节省成本，且多种业务集中进行混布，其中动态节点质量较差，但成本较低，也是导致问题的关键所在，在对Linux 内核的升级和参数调整操作上一定要慎重。</p>

<p><strong>当前动态节点版本及相关配置：</strong></p>

<ul>
  <li>内核版本：5.4.119-19-0006</li>
  <li>见下面章节</li>
</ul>

<h1 id="优化验证">优化验证</h1>

<h2 id="环境准备">环境准备</h2>

<h3 id="tc-配置">TC 配置</h3>

<p>首先安装 tc 工具，系统默认不安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> iproute2

tc <span class="nt">--version</span>
</code></pre></div></div>

<p><strong>启动配置网损:</strong></p>

<p>比如配置 <code class="language-plaintext highlighter-rouge">lo</code> 网卡 50～150ms 左右的延迟，且包含 0～15% 的一个随机丢包，配置如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>su
<span class="nv">$ </span>tc qdisc add dev lo root netem delay 50ms 25ms distribution normal loss random 0% 15%

<span class="c"># 查看配置是否生效</span>
<span class="nv">$ </span>tc qdisc show dev lo
  qdisc netem 8002: root refcnt 2 limit 1000 delay 50ms  25ms
</code></pre></div></div>

<p><strong>验证：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ping 127.0.0.1 <span class="nt">-i</span> 0.2
PING 127.0.0.1 <span class="o">(</span>127.0.0.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>102 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>115 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>175 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>80.4 ms
<span class="nt">---</span> 127.0.0.1 ping statistics <span class="nt">---</span>
21 packets transmitted, 20 received, 4.7619% packet loss, <span class="nb">time </span>4016ms
rtt min/avg/max/mdev <span class="o">=</span> 48.201/113.013/207.390/42.338 ms, pipe 2
</code></pre></div></div>

<p><strong>恢复：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 删除配置</span>
<span class="nv">$ </span>tc qdisc del dev lo root
</code></pre></div></div>

<p><strong>注意：</strong> 不要无脑 copy 别人的 tc 配置命令，使用了 <code class="language-plaintext highlighter-rouge">channge</code> 而非 <code class="language-plaintext highlighter-rouge">add</code>，导致 <code class="language-plaintext highlighter-rouge">Error: Qdisc not found. To create specify NLM_F_CREATE flag.</code> 报错，还以为内核缺少 sch_netem 模块，差点重新安装完整内核。
可以通过命令：<code class="language-plaintext highlighter-rouge">modinfo sch_netem</code> 查看系统是否已经安装有 <code class="language-plaintext highlighter-rouge">sche_netem</code> 模块，如果没有就会报错，有的话会有模块信息输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename:       /lib/modules/6.8.0-51-generic/kernel/net/sched/sch_netem.ko.zst
description:    Network characteristics emulator qdisc
license:        GPL
srcversion:     7631AD62974660130A36DCA
depends:
retpoline:      Y
intree:         Y
name:           sch_netem
vermagic:       6.8.0-51-generic SMP preempt mod_unload modversions
sig_id:         PKCS#7
signer:         Build <span class="nb">time </span>autogenerated kernel key
sig_key:        29:0D:80:5A:E0:B3:D6:D4:D4:D3:D0:EF:AB:48:F3:DB:73:58:2F:63
sig_hashalgo:   sha512
signature:      03:A4:1E:0E:CA:01:0F:58:3E:93:93:A7:25:97:FC:82:3E:4F:60:CA:
                00:84:75:DF:A3:20:F7:1B:92:9D:B1:58:6D:E2:47:92:84:83:00:FD:
                ...
</code></pre></div></div>

<h3 id="netperf">NetPerf</h3>

<ul>
  <li>启动 netserver</li>
</ul>

<p>启动 <code class="language-plaintext highlighter-rouge">netserver</code>, <code class="language-plaintext highlighter-rouge">netserver</code> 与 <code class="language-plaintext highlighter-rouge">netperf</code> 是同一套 Tools，只是 server 测启动命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netserver <span class="nt">-h</span>

Usage: netserver <span class="o">[</span>options]

Options:
    <span class="nt">-h</span>                Display this text
    <span class="nt">-D</span>                Do not daemonize
    <span class="nt">-d</span>                Increase debugging output
    <span class="nt">-f</span>                Do not spawn chilren <span class="k">for </span>each <span class="nb">test</span>, run serially
    <span class="nt">-L</span> name,family    Use name to pick listen address and family <span class="k">for </span>family
    <span class="nt">-N</span>                No debugging output, even <span class="k">if </span>netperf asks
    <span class="nt">-p</span> portnum        Listen <span class="k">for </span>connect requests on portnum.
    <span class="nt">-4</span>                Do IPv4
    <span class="nt">-6</span>                Do IPv6
    <span class="nt">-v</span> verbosity      Specify the verbosity level
    <span class="nt">-V</span>                Display version information and <span class="nb">exit</span>
    <span class="nt">-Z</span> passphrase     Expect passphrase as the first thing received


<span class="c"># 启动命令</span>
<span class="nv">$ </span>~<span class="nv">$ </span><span class="nb">sudo </span>netserver <span class="nt">-p</span> 1234 <span class="nt">-D</span> <span class="nt">-4</span>
check_if_inetd: enter
setup_listens: enter
create_listens: called with host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span> family AF_INET<span class="o">(</span>2<span class="o">)</span>
getaddrinfo returned the following <span class="k">for </span>host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span>  family AF_INET
        cannonical name: <span class="s1">'(nil)'</span>
        flags: 1 family: AF_INET: socktype: SOCK_STREAM protocol IPPROTO_TCP addrlen 16
        sa_family: AF_INET sadata: 4 210 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Starting netserver with host <span class="s1">'IN(6)ADDR_ANY'</span> port <span class="s1">'1234'</span> and family AF_INET
accept_connections: enter
set_fdset: enter list 0x5f3130ac4740 fd_set 0x7fff92fb9450
setting 3 <span class="k">in </span>fdset

</code></pre></div></div>

<p>使 <code class="language-plaintext highlighter-rouge">netserver</code> 监听在 1234 端口上，并指定 IPv4 协议，-D 表示不在后台运行。</p>

<ul>
  <li>启动 Client</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 10  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 100,3000000
</code></pre></div></div>

<p>参数说明：
-H： 指定 server 的 IP 地址
-p： 指定 server 的 port
-l： 指定测试运行多长时间，单位：秒
-t： 运行模式，我们使用 <code class="language-plaintext highlighter-rouge">TCP_CRR</code> 来模拟 client 请求与 server 建连以后，由server 下发一定的数据量以后，关闭连接的这种 request/response 模式
-r： 分别指定 request 和 response 的字节数大小</p>

<h2 id="默认配置benchmark">默认配置Benchmark</h2>

<p>记录下当前内核参数中与 tcp 相关的配置，并获取当前配置的 Benchmark 数据，用以在后续的优化中进行对比。
首先直接用 <code class="language-plaintext highlighter-rouge">netperf</code> 执行 20分钟的测试数据获取：</p>

<p>首先获取下当前测试流的关键帧的大小用以模拟尽量贴近实际业务场景的模拟：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 首先 dump 到本地</span>
ffmpeg <span class="nt">-i</span> http://xxxx/yyyyy/zzzzzzz.flv <span class="nt">-c</span> copy  1.flv

<span class="c"># 然后获取该片段的的首个关键帧的大小</span>
ffmpeg <span class="nt">-i</span> 1.flv <span class="nt">-frames</span>:v 1 <span class="nt">-f</span> image2pipe <span class="nt">-vcodec</span> mjpeg - | <span class="nb">wc</span> <span class="nt">-c</span>

<span class="c"># 可以看到最后输出的为：117118，即 114KB 左右。</span>
</code></pre></div></div>

<p>netperf 模拟 Player 请求下发直播数据，这里设置让 server 一次性下发 300KB 的数据，同时假设 Client 的 request 默认为 1KB,
测试 20分钟，命令如下：</p>

<p><strong>测试数据：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 1200  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

16384  131072 100      3000000  100.01      0.79
16384  131072
</code></pre></div></div>

<blockquote>
  <p>上述测试数据输出的 <code class="language-plaintext highlighter-rouge">Local /Remote</code> 可以看到在下面多出一行，分别表示的是 local 和 remote 的 socket send and recv buffer’s bytes。
最后一列 <code class="language-plaintext highlighter-rouge">Trans</code> 表示的便是在测试的这段时间内平均每秒钟可以执行了多少次请求，即 0.79 次，相当于 Qps，越大说明效率越高。</p>
</blockquote>

<h1 id="tcp-内核参数优化">TCP 内核参数优化：</h1>

<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数说明</a></p>

<h2 id="内核参数配置">内核参数配置</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@XXXLink64 ~]# sysctl <span class="nt">-a</span> | <span class="nb">grep</span> <span class="s2">"net</span><span class="se">\.</span><span class="s2">ipv4</span><span class="se">\.</span><span class="s2">tcp"</span>

<span class="c"># 下面 4 个参数不区分协议</span>
<span class="c"># 默认的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_max <span class="o">=</span> 327680
<span class="c"># 默认的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_max <span class="o">=</span> 3276800

<span class="c"># 在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，默认值是 1000</span>
net.core.netdev_max_backlog <span class="o">=</span> 3000

<span class="c"># 定义了系统中每一个端口最大的监听队列的长度，是个全局的参数</span>
net.core.somaxconn <span class="o">=</span> 2048

<span class="c"># 表示每个套接字所允许的最大缓冲区的大小</span>
net.core.optmem_max <span class="o">=</span> 81920

<span class="c"># 自动调整 tcp recv buffer</span>
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0

<span class="c"># 用于控制当服务器的监听队列（listen 队列）溢出时，是否向客户端发送 TCP 重置（RST）信号以终止连接</span>
net.ipv4.tcp_abort_on_overflow <span class="o">=</span> 0

<span class="c"># 内核中与 TCP 窗口大小相关的一个参数，它影响接收窗口的大小调整行为</span>
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1

net.ipv4.tcp_allowed_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_app_win <span class="o">=</span> 31

<span class="c"># 尽量合并包一起发送，减少发包数量。enable 了会增加延迟，建议关闭</span>
net.ipv4.kcp_autocorking <span class="o">=</span> 1

net.ipv4.tcp_available_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_available_ulp <span class="o">=</span> 
net.ipv4.tcp_base_mss <span class="o">=</span> 1024
net.ipv4.tcp_challenge_ack_limit <span class="o">=</span> 1000
net.ipv4.tcp_comp_sack_delay_ns <span class="o">=</span> 1000000
net.ipv4.tcp_comp_sack_nr <span class="o">=</span> 44
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr
net.ipv4.tcp_dsack <span class="o">=</span> 1
net.ipv4.tcp_early_demux <span class="o">=</span> 1
net.ipv4.tcp_early_retrans <span class="o">=</span> 3
net.ipv4.tcp_ecn <span class="o">=</span> 2
net.ipv4.tcp_ecn_fallback <span class="o">=</span> 1
net.ipv4.tcp_fack <span class="o">=</span> 0
net.ipv4.tcp_fastopen <span class="o">=</span> 1
net.ipv4.tcp_fastopen_blackhole_timeout_sec <span class="o">=</span> 3600
net.ipv4.tcp_fastopen_key <span class="o">=</span> 5b1b3bb0-e9881f5a-8bf3fda0-1c410b36
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30
net.ipv4.tcp_frto <span class="o">=</span> 2
net.ipv4.tcp_fwmark_accept <span class="o">=</span> 0
net.ipv4.tcp_inherit_buffsize <span class="o">=</span> 1
net.ipv4.tcp_init_cwnd <span class="o">=</span> 15
net.ipv4.tcp_init_rto <span class="o">=</span> 1000
net.ipv4.tcp_invalid_ratelimit <span class="o">=</span> 500

<span class="c"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效</span>
net.ipv4.tcp_keepalive_time <span class="o">=</span> 7200
<span class="c"># 探测消息未获得响应时，重发该消息的间隔时间（秒）</span>
net.ipv4.tcp_keepalive_intvl <span class="o">=</span> 75
<span class="c"># 在认定TCP连接失效之前，最多发送多少个keepalive探测消息</span>
net.ipv4.tcp_keepalive_probes <span class="o">=</span> 9

net.ipv4.tcp_l3mdev_accept <span class="o">=</span> 0
net.ipv4.tcp_limit_output_bytes <span class="o">=</span> 1048576
net.ipv4.tcp_loss_init_cwnd <span class="o">=</span> 10
<span class="c"># 允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用</span>
net.ipv4.tcp_low_latency <span class="o">=</span> 0
net.ipv4.tcp_max_orphans <span class="o">=</span> 524288
net.ipv4.tcp_max_reordering <span class="o">=</span> 300
net.ipv4.tcp_max_syn_backlog <span class="o">=</span> 62144
net.ipv4.tcp_max_tw_buckets <span class="o">=</span> 6000
net.ipv4.tcp_mem <span class="o">=</span> 2621440      3932160 5242880
net.ipv4.tcp_min_rtt_wlen <span class="o">=</span> 300
net.ipv4.tcp_min_snd_mss <span class="o">=</span> 48
net.ipv4.tcp_min_tso_segs <span class="o">=</span> 2
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_mtu_probe_floor <span class="o">=</span> 48
net.ipv4.tcp_mtu_probing <span class="o">=</span> 0
net.ipv4.tcp_no_metrics_save <span class="o">=</span> 1
net.ipv4.tcp_notsent_lowat <span class="o">=</span> 8388608
net.ipv4.tcp_orphan_retries <span class="o">=</span> 0

net.ipv4.tcp_pacing_ca_ratio <span class="o">=</span> 120
net.ipv4.tcp_pacing_ss_ratio <span class="o">=</span> 200
net.ipv4.tcp_probe_interval <span class="o">=</span> 600
net.ipv4.tcp_probe_threshold <span class="o">=</span> 8
net.ipv4.tcp_proc_sched <span class="o">=</span> 1
net.ipv4.tcp_recovery <span class="o">=</span> 1
net.ipv4.tcp_reordering <span class="o">=</span> 5
net.ipv4.tcp_retrans_collapse <span class="o">=</span> 1
net.ipv4.tcp_retries1 <span class="o">=</span> 5
net.ipv4.tcp_retries2 <span class="o">=</span> 15
net.ipv4.tcp_rfc1337 <span class="o">=</span> 0
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 16384000
net.ipv4.tcp_rto_max <span class="o">=</span> 120
net.ipv4.tcp_rto_min <span class="o">=</span> 200
net.ipv4.tcp_rx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_sack <span class="o">=</span> 1
net.ipv4.tcp_slow_start_after_idle <span class="o">=</span> 0
net.ipv4.tcp_stdurg <span class="o">=</span> 0
net.ipv4.tcp_syn_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_rto_interval <span class="o">=</span> 200

<span class="c"># 表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载</span>
net.ipv4.tcp_syncookies <span class="o">=</span> 1
net.ipv4.tcp_thin_linear_timeouts <span class="o">=</span> 0

<span class="c"># TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项</span>
net.ipv4.tcp_timestamps <span class="o">=</span> 1
net.ipv4.tcp_tso_win_divisor <span class="o">=</span> 3
net.ipv4.tcp_tw_ignore_syn_tsval_zero <span class="o">=</span> 1

<span class="c"># 表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 </span>
net.ipv4.tcp_tw_reuse <span class="o">=</span> 1
<span class="c"># 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡</span>
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30

<span class="c"># 能够更快地回收TIME-WAIT套接字</span>
net.ipv4.tcp_tw_recycle <span class="o">=</span> 1
net.ipv4.tcp_tw_timeout <span class="o">=</span> 60
net.ipv4.tcp_tx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_wan_timestamps <span class="o">=</span> 0
net.ipv4.tcp_window_scaling <span class="o">=</span> 1
net.ipv4.tcp_wmem <span class="o">=</span> 4096000     16384000        32768000
net.ipv4.tcp_workaround_signed_windows <span class="o">=</span> 0
</code></pre></div></div>

<h2 id="优化内容">优化内容</h2>

<blockquote>
  <p>以下均为仅优化单边的 Server 测参数。</p>
</blockquote>

<h3 id="bbr">BBR</h3>

<p>编辑 <code class="language-plaintext highlighter-rouge">/etc/sysctl.conf</code>，添加或修改如下参数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置 tcp 拥塞算法为 bbr</span>
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr

</code></pre></div></div>

<p>使参数立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-p</span>
</code></pre></div></div>

<p><strong>测试结果</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 300  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

436600 87380  100      3000000  300.00      1.06
436600 87380
</code></pre></div></div>

<p>可以看到在开启了 bbr 拥塞算法后，<code class="language-plaintext highlighter-rouge">Trans</code> 由 0.79 升到了 1.06，有了明显的提升。
但是实际优化数据不会这么明显，因为线上环境我们只能开启 server 测的 bbr，而无法控制 client 同时开启。</p>

<h3 id="socketbuffer">SocketBuffer</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-a</span> | egrep <span class="s2">"rmem|wmem|adv_win|moderate"</span>
net.core.rmem_default <span class="o">=</span> 327680
net.core.rmem_max <span class="o">=</span> 327680
net.core.wmem_default <span class="o">=</span> 327680
net.core.wmem_max <span class="o">=</span> 3276800
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0
</code></pre></div></div>

<p><strong>测试结果对比</strong></p>

<ul>
  <li>上述默认配置，无调整 buffer</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.59
16384000 1048576
</code></pre></div></div>

<ul>
  <li>强制64KB buffer</li>
</ul>

<p>配置 net.ipv4.tcp_wmem 为 65536 后的测试结果 <code class="language-plaintext highlighter-rouge">sysctl -w net.ipv4.tcp_wmem="65536 65536 65536"</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.16
65535  1048576
</code></pre></div></div>

<p>可以看到之前配置了 64KB 的 send buffer 后，Trans 由 1.59 下降到了 1.16，有明显的下降，但是上述配置是将 min、default、max 均全部强行配置为 64KB，失去了动态伸缩的能力，如果仅配置 default 为 64KB，不限制最大值，则不受影响。</p>

<h3 id="tcp_fastopen">tcp_fastopen</h3>

<p>在上述配置中，tcp_fastopen 配置为 1，即仅开启 Client 的 fastopen，而未开启 server 测的 fastopen，不是最佳配置，需要调整为 3 同时开启 client 和 server 测的 fastopen。
tcp_fastopen 配置项说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tcp_fastopen - INTEGER
	Enable TCP Fast Open (RFC7413) to send and accept data in the opening
	SYN packet.

	The client support is enabled by flag 0x1 (on by default). The client
	then must use sendmsg() or sendto() with the MSG_FASTOPEN flag,
	rather than connect() to send data in SYN.

	The server support is enabled by flag 0x2 (off by default). Then
	either enable for all listeners with another flag (0x400) or
	enable individual listeners via TCP_FASTOPEN socket option with
	the option value being the length of the syn-data backlog.

	The values (bitmap) are

	=====  ======== ======================================================
	  0x1  (client) enables sending data in the opening SYN on the client.
	  0x2  (server) enables the server support, i.e., allowing data in
			a SYN packet to be accepted and passed to the
			application before 3-way handshake finishes.
	  0x4  (client) send data in the opening SYN regardless of cookie
			availability and without a cookie option.
	0x200  (server) accept data-in-SYN w/o any cookie option present.
	0x400  (server) enable all listeners to support Fast Open by
			default without explicit TCP_FASTOPEN socket option.
	=====  ======== ======================================================

</code></pre></div></div>

<h2 id="结论">结论</h2>

<p>在目前环境中的内核配置中，对首开有明显影响的只有三个参数：</p>
<ul>
  <li>1、BBR 的拥塞算法；</li>
  <li>2、TCP 的 send buffer 最大值要足够大；</li>
  <li>3、开启 tcp_fastopen 需要开启 server 测，至少为 2。</li>
</ul>

<h1 id="路由优化记录">路由优化记录</h1>

<p>直播片源选用 3.4Mbps 的码率，播放器选择 ffplay 进行拉取，在发送端（直播服务器）通过 tcpdump 抓包，对比查看发送 1MB 数据所耗费的时间线，这里是局域网环境，所以 lastmile 的带宽不是瓶颈。</p>

<p>Tcp 的 initcwnd 默认值为 10，倘若设置过大会造成对网络的冲击，根据经验选择<code class="language-plaintext highlighter-rouge">默认配置 10</code> 与 <code class="language-plaintext highlighter-rouge">40</code> 两者之间进行对比。</p>

<h2 id="环境准备-1">环境准备</h2>

<p>首先在发送端直播服务器上为指定网卡增加 100ms 的主动延迟，以放大数据影响，方便对比结果。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 增加 100ms 的固定延迟
$ sudo tc qdisc change dev eno1 root netem delay 100ms
  
# ping 验证
$ ping 100.100.32.108
PING 100.100.32.108 (100.100.32.108) 56(84) bytes of data.
64 bytes from 100.100.32.108: icmp_seq=1 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=2 ttl=63 time=103 ms
64 bytes from 100.100.32.108: icmp_seq=3 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=4 ttl=63 time=103 ms
^C
--- 100.100.32.108 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3003ms
rtt min/avg/max/mdev = 102.763/103.307/103.550/0.322 ms
</code></pre></div></div>

<h2 id="case1">Case1</h2>

<blockquote>
  <p>未修改 tcp initcwnd 的测试场景。</p>
</blockquote>

<ul>
  <li>在发送端（直播服务器）测抓包：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_10cwnd_100msdelay.pcap
</code></pre></div>    </div>
  </li>
  <li>在远端进行拉流（100.100.32.108）：</li>
</ul>

<p>  拉取播放 10秒左右即可。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffplay http://100.100.57.20:8080/ztest/A123.flv\?domain\=h3.xxx.com
</code></pre></div></div>

<ul>
  <li>Wireshark 分析：</li>
</ul>

<p>  可以看到如下截图，接收 1 * 10^6 即1MB的数据时大约耗时在 900ms。
<img src="/assets/img/blog/tcp_10cwnd_100ms.png" alt="TCP 10 INITCWND 分析图" /></p>

<h2 id="case2">Case2</h2>

<p>调整 initcwnd 为 40，通过 ip route 进行调整。</p>

<ul>
  <li>首先通过 <code class="language-plaintext highlighter-rouge">sudo ip route show</code> 进行查看：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 10
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 10
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 10
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>然后依次对各 route 进行配置：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip route change 100.100.56.254 dev eno1 scope link initcwnd 40
sudo ip route change via 100.100.56.254 dev eno1  initcwnd 40
sudo ip route change 100.100.56.0/23 dev eno1 proto static scope link  initcwnd 40
</code></pre></div></div>

<ul>
  <li>配置后如下：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 40
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 40
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 40
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>在发送端（直播服务器）测抓包</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_40cwnd_100msdelay.pcap
</code></pre></div></div>

<ul>
  <li>Wireshark 分析</li>
</ul>

<p>  可以看到 init cwnd 为 40 后，在 tcp 的慢启动状态发包变得很激进，接收端接收 1MB 的数据大约为 550ms，节省了大约 350ms，大约 3 个 rtt 的时间。
<img src="/assets/img/blog/tcp_40cwnd_100ms.png" alt="TCP 40 INITCWND 分析图" /></p>

<h2 id="结论-1">结论</h2>

<p>  如上，调整 INITCWND 为 40后，在秒开数据为 1MB 的场景中，大约可为秒开节省 3 个左右的 rtt 时间，下一步可以在线上进行初步的验证，可逐步放开该值为 20、30、40，在数据不断的优化的情况下降低调整风险，逐步实现优化。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><category term="Protocol" /><summary type="html"><![CDATA[当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。]]></summary></entry><entry><title type="html">Ubuntu24.04 配置静态 IP</title><link href="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html" rel="alternate" type="text/html" title="Ubuntu24.04 配置静态 IP" /><published>2025-01-08T00:00:00+00:00</published><updated>2025-01-08T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/ubuntu24.04-static-ip</id><content type="html" xml:base="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html"><![CDATA[<blockquote>
  <p>公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。</p>
</blockquote>

<blockquote>
  <p>如下所有操作均使用 <code class="language-plaintext highlighter-rouge">root</code> 权限。</p>
</blockquote>

<blockquote>
  <p>记录该过程主要是因为想当然的以为网关地址就是同网段的 .1，导致配置后网络不通，通过 <code class="language-plaintext highlighter-rouge">ip route</code> 查询后方可。</p>
</blockquote>

<h1 id="查看当前-ip">查看当前 IP</h1>

<p>系统默认开启 DHCP，自动获取 IP，且查看 IP 不再默认支持<code class="language-plaintext highlighter-rouge">ifconfig</code>命令，需要 <code class="language-plaintext highlighter-rouge">ip addr show</code>进行查看。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 2c:f0:5d:2b:11:31 brd ff:ff:ff:ff:ff:ff
    altname enp0s31f6
    inet 100.100.57.20/23 brd 100.100.57.255 scope global noprefixroute eno1
       valid_lft forever preferred_lft forever
</code></pre></div></div>

<p>可以看到自己的 IP 地址为<code class="language-plaintext highlighter-rouge">100.100.57.20</code>。</p>

<h1 id="配置静态-ip">配置静态 IP</h1>

<p>ubuntu 18 以后版本开始使用<code class="language-plaintext highlighter-rouge">netplan</code>配置网卡信息，查看当前系统目录<code class="language-plaintext highlighter-rouge">/etc/netplan/</code>下具体配置文件名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls /etc/netplan
$ 50-cloud-init.yaml
</code></pre></div></div>

<blockquote>
  <p>编辑前建议先进行备份。</p>
</blockquote>

<p><strong>默认配置：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        eno1:
            dhcp4: true
    version: 2
</code></pre></div></div>

<p><strong>查询路由</strong></p>

<p>通过<code class="language-plaintext highlighter-rouge">ip route</code>获取当前路由地址：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ip route
$ default via 100.100.56.254 dev eno1 proto static metric 100
$ default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
$ 100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
</code></pre></div></div>

<p>可以看到默认路由地址为<code class="language-plaintext highlighter-rouge">100.100.56.254</code>。</p>

<p><strong>配置文件</strong></p>

<p><code class="language-plaintext highlighter-rouge">vim /etc/netplan/50-cloud-init.yaml</code>进行编辑,最终内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    version: 2
    ethernets:
        eno1:
            dhcp4: no
            addresses:
             - 100.100.57.20/23
            routes:
              - to: default
                via: 100.100.56.254
            nameservers:
              addresses:
                - 8.8.8.8
                - 8.8.4.4
</code></pre></div></div>

<blockquote>
  <p>注意缩进的格式和位置，不能使用<code class="language-plaintext highlighter-rouge">tab</code>只能用空格进行缩进。</p>
</blockquote>

<p><strong>应用</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netplan apply
</code></pre></div></div>

<p>如果没有格式错误的话，便没有任何输出，否则提示格式错误。
至此配置成功，通过<code class="language-plaintext highlighter-rouge">ip addr show</code>查看确认。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。]]></summary></entry><entry><title type="html">webtransport-go 在直播场景下的优化</title><link href="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html" rel="alternate" type="text/html" title="webtransport-go 在直播场景下的优化" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-01-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream</id><content type="html" xml:base="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html"><![CDATA[<h1 id="背景">背景</h1>
<p>公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。</p>

<blockquote>
  <p>本人经历 2024年 11月变动以后，刚来公司不久，周边同事基本都以 golang 语言开发为主，且基本没有协议的优化经验，只能选择开源项目进行优化， B本人进入公司的时机也不好，该项目已经选定该方案，并且开始上线进行灰度测试，无法推翻重来。
且对比 Tcp 来看，webtransport-go 带来的性能消耗是 tcp 的 5 倍以上。</p>
</blockquote>

<h2 id="为什么不直接使用-quic-go">为什么不直接使用 quic-go</h2>

<p>因为 quic 虽然也是可靠传输，但是 quic 暂不支持通过 Url 来携带业务测参数，如：vhost、token 等的。</p>

<h1 id="初始化">初始化</h1>
<h2 id="代码下载">代码下载</h2>

<p><code class="language-plaintext highlighter-rouge">git clone git@github.com:quic-go/webtransport-go.git</code></p>

<p>拉取相关依赖仓库代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 进入代码目录
cd webtransport-go

# 通过 build 触发代码拉取
go build webtransport_test.go
</code></pre></div></div>

<p>Golang 默认将代码存放在<code class="language-plaintext highlighter-rouge">$GOPATH</code>目录下，我的<code class="language-plaintext highlighter-rouge">GOPATH</code>环境变量配置为 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go</code>，那么拉取的依赖仓库 <code class="language-plaintext highlighter-rouge">quic-go</code> 的存放目录就是 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1</code>，为了方便在 VSCode 中查看代码，在 VSCode 的 WorkSpace 空白处通过右键选择：<code class="language-plaintext highlighter-rouge">Add Folder to WorkSpace</code>，选择上述目录，即可一起查看 <code class="language-plaintext highlighter-rouge">quic-go</code> 相关的代码，如下：
<img src="/assets/img/blog/vscode-go.jpg" alt="" /></p>

<h2 id="quic-go">Quic-go</h2>

<p>Quic-go 作为 webtransport-go 的依赖仓库，提供 quic 的基础传输能力，但是其提供的传输配置能力非常有限，特别是作为发送端时，一些基础的 CWnd、Burst、Ack 等参数均不支持配置，接口文件为：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/interface.go</code></p>

<p>quic-go 内部相关参数主要位于：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/protocol.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/params.go</code></p>

<h1 id="优化项">优化项</h1>

<ul>
  <li>初始化发送包数：</li>
</ul>

<p>文件：<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code> 中指定
<code class="language-plaintext highlighter-rouge">const maxBurstSizePackets = 10</code>，在直播场景，I 帧切片后（1200Bytes/pkt）基本都会超过 10 片，建议配置为 20~30，具体视业务场景中首帧的切换大小，但也不宜过高，控制在 30 以内。
该配置项生效后对秒开的影响较小，属于毫秒级别，原来可能受 pacer 控制在几个 timerGraulariry 中将一个关键帧发送完，该配置的理想效果是减少这几个 timerGraulariry 的延迟。</p>

<ul>
  <li>握手超时时间：
应用层建议也是用 2 秒的配置。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const DefaultHandshakeIdleTimeout = 5 * time.Second
// 建议修改为 2 或者 3 秒，业务测可以快速重连，减少等待时间
const DefaultHandshakeIdleTimeout = 2 * time.Second
</code></pre></div></div>

<ul>
  <li>定时器精度</li>
</ul>

<p>最好是从系统中获取自己的定时器精度（一般是4ms），不建议使用 1 ms 这种精度，过于高频，无效的 cpu 消耗。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const TimerGranularity = time.Millisecond
// 建议值：动态获取系统定时器精度，或者 hardcode 为 4ms 或者 10ms
const TimerGranularity = 4 * time.Millisecond
</code></pre></div></div>

<ul>
  <li>转发模式</li>
</ul>

<p>目前业务集成方在回源时，虽然传输协议使用的是流式传输，但是边缘节点在接收到分片数据后并不会立即进行转发，而是在组装成一个完整的帧以后再一次性进行发送，这样做是为了内部各种封装格式的转换，但是也存在明显的弊端，即在没有收到完整的关键帧以前，不会向 Player 发送任何数据，被回源的关键帧阻塞，间接的增加了首开的延迟。</p>

<p>可优化选项：比如回源的协议与 Player 请求的协议相同，即均为 HTTP-FLV，那么便不再需要进行完整帧的转封装，而直接进行分片的透明转发，同时边缘节点也异步的 cache 分片数据进行组帧操作，转封装分发给其它请求的协议。</p>

<h1 id="faq">FAQ</h1>

<h2 id="webtransport-是否是整帧的收发">Webtransport 是否是整帧的收发？</h2>

<p>不是，websocket 在发送大的数据帧时，会通过 FIN 标记位是否为 1 标记为该 Frame 是否结束，而 WebTransport 中是基于流的传输，需要应用层自行组装完整的数据帧。
<a href="https://www.ietf.org/archive/id/draft-ietf-webtrans-overview-05.html#name-conventions-and-definitions-8">ref link</a></p>

<blockquote>
  <p>A stream is a sequence of bytes that is reliably delivered to the receiving application in the same order as it was transmitted by the sender. Streams can be of arbitrary length, and therefore cannot always be buffered entirely in memory. WebTransport protocols and APIs are expected to provide partial stream data to the application before the stream has been entirely received.</p>
</blockquote>

<h2 id="bbr-sender-配置-startup-的较大带宽但是-max-burst-send-packets-number-却较小能将关键帧的几个切片一次性发送出去吗">BBR sender 配置 startup 的较大带宽，但是 max burst send packets number 却较小，能将关键帧的几个切片一次性发送出去吗？</h2>

<p><code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        p := &amp;pacer{
                maxDatagramSize: initialMaxDatagramSize,
                adjustedBandwidth: func() uint64 {
                        // Bandwidth is in bits/s. We need the value in bytes/s.
                        bw := uint64(getBandwidth() / BytesPerSecond)
                        // Use a slightly higher value than the actual measured bandwidth.
                        // RTT variations then won't result in under-utilization of the congestion window.
                        // Ultimately, this will result in sending packets as acknowledgments are received rather than when timers fire,
                        // provided the congestion window is fully utilized and acknowledgments arrive at regular intervals.
                        return bw * 5 / 4
                },
        }
        p.budgetAtLastSent = p.maxBurstSize()
        return p
}
</code></pre></div></div>

<p>而在初始化时，由于没有 smoothedRTT 的有效值，所以初始化为 <code class="language-plaintext highlighter-rouge">infBandwidth</code> (UINT64_MAX)，
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/bbr_sender.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (b *bbrSender) bandwidthEstimate() Bandwidth {
        srtt := b.rttStats.SmoothedRTT()
        if srtt == 0 {
                // If we haven't measured an rtt, the bandwidth estimate is unknown.
                return infBandwidth
        }
        bw := b.maxBandwidth.GetBest()
        if bw == 0 {
                return infBandwidth
        }
        return bw
}
</code></pre></div></div>

<p>虽然初始化的 bandwidth 比较大，但是 pacer 在发送数据时依然会受限于 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 的配置，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *pacer) maxBurstSize() protocol.ByteCount {
        return utils.Max(
                protocol.ByteCount(uint64((protocol.MinPacingDelay+protocol.TimerGranularity).Nanoseconds())*p.adjustedBandwidth())/1e9,
                maxBurstSizePackets*p.maxDatagramSize,
        )
}
</code></pre></div></div>

<p>所以建议将 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 值配置为 20 ～ 30 之间，根据业务场景，尽量让首帧（I Frame）的所有切片能够一次性发送出去，但是也不宜过高，避免数据突发导致网络拥塞丢包。</p>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><summary type="html"><![CDATA[背景 公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。]]></summary></entry><entry><title type="html">移植裁剪 srs 到 ARMv64 系统设备</title><link href="https://gbcpp.github.io/notes/srs-on-arm.html" rel="alternate" type="text/html" title="移植裁剪 srs 到 ARMv64 系统设备" /><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/srs-on-arm</id><content type="html" xml:base="https://gbcpp.github.io/notes/srs-on-arm.html"><![CDATA[<h1 id="srs-版本">SRS 版本</h1>

<p>srs 源码选择较新的 stable 版本：v5.0-r3</p>

<p><strong>代码拉取</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --branch v5.0-r3 https://github.com/ossrs/srs.git
</code></pre></div></div>

<p><strong>编译</strong></p>

<p>已知设备系统：ARMv8 指令集架构的 Debian，此次测试选择在 Debian 系统下部署 srs 服务进行测试。</p>

<p>使用 docker 进行编译，首先保证开发机上有 docker 服务，编译命令会自行拉取 aarch64 专用编译镜像并编译：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd srs/trunk
$ docker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \
    bash -c "./configure --srt=off --rtc=off --ffmpeg-fit=off --static=on \
        --sanitizer=off --sanitizer-static=off --sanitizer-log=off &amp;&amp; make -j4"
 

# 查看 srs 二进制文件
$ ls -sh objs/srs
</code></pre></div></div>

<h1 id="测试环境">测试环境</h1>

<p>基于当前测试条件，此次测试选择将 srs 服务部署在 Debian 系统的小盒子中进行测试。</p>

<p>Debian 系统小盒子性能如下：</p>
<ul>
  <li>CPU：4 核 4 线程，主频 1.5GHz</li>
  <li>Mem：2GB</li>
  <li>Disk：8GB</li>
</ul>

<p>观众端：</p>

<p>Mac 下 Shell 脚本启动 10 路 ffplay 进行播放，启动命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash repeat_command.sh "ffplay https://ossrs.com:8088/live/livestream.flv"  10
</code></pre></div></div>

<p>repeat_command.sh 脚本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
 
if [ $# -lt 2 ]; then
    echo "Usage: $0 &lt;command&gt; &lt;times&gt;"
    exit 1
fi
 
# 获取参数
command=$1
times=$2
 
# 检查 times 是否是数字
if ! [[ $times =~ ^[0-9]+$ ]]; then
    echo "Error: &lt;times&gt; must be a positive integer."
    exit 1
fi
 
# 循环执行命令
for ((i=1; i&lt;=times; i++)); do
    echo "Executing command '$command' in the background: iteration $i"
    eval "$command &amp;"
done
 
echo "All commands have been executed in the background."
</code></pre></div></div>

<h1 id="srs-配置">SRS 配置</h1>

<p>使用了自签名证书 ossrs.com</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen              1935;
max_connections     1000;
daemon              off;
srs_log_tank        console;
 
http_api {
    enabled         on;
    listen          1985;
}
 
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
 
    https {
        enabled on;
        listen 8088;
        key ./ossrs.key;
        cert ./ossrs.crt;
    }
}
vhost __defaultVhost__ {
    http_remux {
        enabled     on;
        mount       [vhost]/[app]/[stream].flv;
    }
    ingest livestream {
        enabled      on;
        input {
            type    stream;
        url     http://100.100.34.14:8080/live/livestream.flv;
        }
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled          off;
            output          rtmp://0.0.0.0:[port]/live/livestream?vhost=[vhost];
        }
    }
}
</code></pre></div></div>

<h1 id="测试结果">测试结果</h1>

<p>测试条件有限，目前仅测试了如下两种场景和数据，仅供参考。</p>

<p>测试场景：为该 SRS 注入一路 stream 做为源，然后远端从该 SRS 通过 HTTPS-FLV 拉取十路该流。</p>

<p><img src="/assets/img/blog/srs_perf.jpg" alt="" /></p>

<h1 id="srs-支持sni和多证书">SRS 支持SNI和多证书</h1>

<p>目前 srs 仅支持单个 HTTPS Server 的部署，需要自行扩展支持 SNI 的读取、选择指定证书下发的实现，TLS 封装代码在 SrsHttpxConn 类中。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[SRS 版本]]></summary></entry></feed>