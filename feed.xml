<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2023-10-26T09:54:40+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">获取不同 Clock 在不同 Linux Kernel 下的精度</title><link href="https://gbcpp.github.io/measure-clock-resolution.html" rel="alternate" type="text/html" title="获取不同 Clock 在不同 Linux Kernel 下的精度" /><published>2023-10-25T00:00:00+00:00</published><updated>2023-10-25T00:00:00+00:00</updated><id>https://gbcpp.github.io/measure-clock-resolution</id><content type="html" xml:base="https://gbcpp.github.io/measure-clock-resolution.html"><![CDATA[]]></content><author><name>Mr Chen</name></author><category term="Linux" /><category term="C++" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">GitHub Pages 博客搭建记录</title><link href="https://gbcpp.github.io/blog-building-notes.html" rel="alternate" type="text/html" title="GitHub Pages 博客搭建记录" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/blog-building-notes</id><content type="html" xml:base="https://gbcpp.github.io/blog-building-notes.html"><![CDATA[<h1 id="渊源">渊源</h1>

<p>  国庆放假期间，机缘巧合看到一篇使用了非常漂亮主题的文章，它也是基于 GitHub 的 Pages 进行搭建和部署的，回想起几年前自己搭建的个人博客（因始终不满足自己的审美要求，已废弃），让我一眼便喜欢上了它，立即决定重建我的个人博客。</p>

<h1 id="博客构建框架">博客构建框架</h1>

<p>  搭建个人博客，大部分人都是通过 GitHub 的 Pages 进行白嫖，但是已有的主题都不是非常完美，对于一个从事非前端开发的人来说，优化调整博客主题到自己满意的程度是非常难的，长时间搞不到自己满意的程度，结局大概率都是废弃。
在看到这篇基于<a href="https://blog.lui8.cn/tech/new-theme-h2o-ac.html">H2O-ac 主题</a> 搭建的的博客后，我决定就是它了，瞬间重拾搭建个人博客的兴趣。</p>

<p>  早些时候，我使用的 GitHub blog 是通过 <code class="language-plaintext highlighter-rouge">Hexo</code> 构建的，<code class="language-plaintext highlighter-rouge">Hexo</code> 是基于 <code class="language-plaintext highlighter-rouge">Node.js</code> 驱动的，而上述博客是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 构建，该框架基于 <code class="language-plaintext highlighter-rouge">Ruby</code> 驱动，它们都是开源的，通过 GitHub 的 star 和 fork 数量，可以看到 <code class="language-plaintext highlighter-rouge">Jekyll</code> 的热度要高于 <code class="language-plaintext highlighter-rouge">Hexo</code>，但是不知道当时自己怎么没有注意到这一点，可能是因为当时是摸着别人过的河，没有了自己的思考。</p>

<p>  由于该主题是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 框架构建的，所以我们就此切换到 <code class="language-plaintext highlighter-rouge">Jekyll</code>，主题就用 <code class="language-plaintext highlighter-rouge">H2O-ac</code>。</p>

<h1 id="初始化">初始化</h1>

<p>  首先创建一个自己的专门用户博客的 public 仓库，这里建议直接从 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 主题作者的 repo <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">jekyll-theme-H2O-ac</a> 中 fork，在命名新的 repo 时，一定要命名自己的 GitHub <code class="language-plaintext highlighter-rouge">name</code> + ‘.github.io’，比如我自己的：gbcpp.github.io，其中 <code class="language-plaintext highlighter-rouge">gbcpp</code> 便是我的 GitHub name，这样做也是官方建议的，同时 Fork 过去的 repo 才可以直接 Publish，而不用做其它任何链接失效之类的修复，而我因为当初好几年没有再折腾过 GitHub 的博客，早已经忘记了这一点，起了个非此模板的名字：<code class="language-plaintext highlighter-rouge">blog</code>、 <code class="language-plaintext highlighter-rouge">webindex</code> 等，部署上的博客有好几处都是无效的链接，需要自行查找并修改，同时博客的 Url 中也要增加子路径。</p>

<p>Fork 后，在该 repo 的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，找到 <code class="language-plaintext highlighter-rouge">Pages</code>，在 <code class="language-plaintext highlighter-rouge">Build and deployment</code> 中选择 <code class="language-plaintext highlighter-rouge">master</code> 分支进行发布，目录就选择 <code class="language-plaintext highlighter-rouge">/(root)</code>, Save 后等待约 3 分钟，即可通过 <code class="language-plaintext highlighter-rouge">xxx.github.io</code> 进行访问。</p>

<p><img src="/assets/img/github_settings.png" alt="" /></p>

<h1 id="个人信息调整">个人信息调整</h1>

<p>虽然经过上述的简单操作，已经能够访问到自己新搭建的博客，但是还有一些个人信息需要调整，在 <code class="language-plaintext highlighter-rouge">.github/workflow</code> 中，每次提交，均会触发 GitHub Actions Workflow，重新执行 Jekyll build &amp; deploy CI 操作，所以我们要为自己的 repo 增加一个 <code class="language-plaintext highlighter-rouge">GITHUB_TOKEN</code>，否则每次 CI 均会报错。如下图所示：</p>

<p><img src="/assets/img/github_token.png" alt="GitHub Token" /></p>

<p>GitHub 的 CI 每次构建完成后会将生成的 <code class="language-plaintext highlighter-rouge">_site</code> 目录 Push 到 <a href="https://jupyterbook.org/en/stable/publish/gh-pages.html"><code class="language-plaintext highlighter-rouge">gh-pages</code></a> 分支。</p>

<p>在该作者的 repo 中，添加的 GitHub workflow 不止 <code class="language-plaintext highlighter-rouge">GitHub</code> 一个，还有亚马逊等其它家，用于网站加速，不过，我个人并没有使用这种多个 workflow 的方式，我删除了除了 ‘jekyll.yml’ 以外所有的 workflow，网站加速请继续往下看。</p>

<h1 id="部署-cdn">部署 CDN</h1>

<p>博客初步建立后，直接访问是非常慢的，没有任何的 CDN 托管加速，而 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 的作者开通了多家国内外 CDN 厂家的托管，访问速度要比直接 xxx.github.io 快很多。</p>

<p>这里我选择了提供全球节点的 <code class="language-plaintext highlighter-rouge">Cloudflare</code> <a href="https://dash.cloudflare.com/">官网</a> 进行托管，主要是因为它对于个人站点是完全免费的，并且操作简单，易上手。</p>

<h2 id="cloudflare-新建-pages">Cloudflare 新建 Pages</h2>

<p>注册并登陆 Cloudflare，进入到个人 <code class="language-plaintext highlighter-rouge">账户主页</code>，进入 <code class="language-plaintext highlighter-rouge">Worker 和 Pages</code>，选择 <code class="language-plaintext highlighter-rouge">Pages</code> 选项，<strong>注意</strong>我们这里选择 <code class="language-plaintext highlighter-rouge">连接到 Git</code>，选择自己的仓库和分支，自动部署即可，如下图：</p>

<p><a href="/assets/img/Cloudflare_GitPages.png"></a></p>

<p>由于我们仅使用了 <code class="language-plaintext highlighter-rouge">jekyll.yml</code> 一个 GitHub Action，该 CI 完成后，会将 <code class="language-plaintext highlighter-rouge">_site</code> 目录自动 push 到 <code class="language-plaintext highlighter-rouge">gp-pages</code> 分支，所以在 <code class="language-plaintext highlighter-rouge">Cloudflare</code> 的 <code class="language-plaintext highlighter-rouge">Pages</code> 配置中，我们选择 <strong>分支</strong> 为 <code class="language-plaintext highlighter-rouge">gh-pages</code>，同时不要添加任何的构建框架和执行命令，只要选择自动选择更新即可。添加完成后的配置如下，可做参考：
<a href="/assets/img/Cloudflare_GitPages2.png"></a></p>

<h2 id="自定义域名">自定义域名</h2>

<p>上述部署完成，可以生成自己博客在 Cloudflare 的域名，比如：xxx-github-io.pages.dev，执行以下步骤将 xxx.github.io 重定向到 xxx-github-io.pages.dev。</p>

<h3 id="cname">CNAME</h3>
<p>Custom domain 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 
博客仓库中新建 <code class="language-plaintext highlighter-rouge">CNAME</code> 文件，填充 Cloudflare 生成的 ‘xxx-github-io.pages.dev’ 域名，并提交。</p>

<h3 id="pages-自定义域名配置">Pages 自定义域名配置</h3>

<p>回到 GitHub 博客仓库的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，在 <code class="language-plaintext highlighter-rouge">Pages</code> 子页面的 <code class="language-plaintext highlighter-rouge">Custom domain</code> 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 保存。以后每次访问自己的 xxx.github.io 便会自动跳转到 xxx-github-io.pages.dev。</p>

<p>当然这样的白嫖效果也就一般般，访问速度并不能完全达到国内建站的速度。</p>

<h1 id="绊脚石">绊脚石</h1>

<h2 id="jekyll-安装">Jekyll 安装</h2>

<p>本人的环境是在 WSL2 下的 Ubuntu Linux 安装的，发现 Jekyll 官方提供的 Installing docs 在 Ubuntu 18.04 及以下由于版本兼容问题已经无法正常的安装了，在 Ubuntu 20.04 中较为顺利，依次执行以下命令不太会遇到太多的问题：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span>
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span>  ruby-full build-essential zlib1g-dev
<span class="nb">echo</span> <span class="s1">'# Install Ruby Gems to ~/gems'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export GEM_HOME="$HOME/gems"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/gems/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc

<span class="c"># 这里 proxychains 为本人配置的 代理，否则容易出现下载失败</span>
<span class="nb">sudo </span>proxychains gem <span class="nb">install </span>jekyll bundler
<span class="nb">sudo </span>proxychains bundle <span class="nb">install</span>
</code></pre></div></div>

<h2 id="h2o-ac-blog-页面异常">H2O-ac Blog 页面异常</h2>

<p>基于作者的最新版本 <code class="language-plaintext highlighter-rouge">master</code> 或者 <code class="language-plaintext highlighter-rouge">tag: v1.2.1</code>，在 <code class="language-plaintext highlighter-rouge">Blog</code> 首页会有如下分页显示的问题，该问题在 GitHub 中已经有人反馈给作者, <a href="https://github.com/zhonger/jekyll-theme-H2O-ac/issues/13">ISSUE</a>，等待作者修复（本人不懂前端，经过几天努力，排查修复失败），不过本人已经排查到该显示问题是从 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 升级到 <code class="language-plaintext highlighter-rouge">v1.1.7</code> 时开始引入的，在本地 build 查看时，没有异常，一旦部署到 GitHub 便异常，所以该站使用的是 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 版本。</p>

<p><a href="/assets/img/jekyll_blog_bug.png"></a></p>

<h2 id="cloudflare-部署报错">Cloudflare 部署报错</h2>

<p>当 Blog 中存在文件 size ~&gt; 25MB 时，Cloudflare 会报错而终止部署，对此需要删除 repo 中所有 size 过大的文件（一般是图片），根据报错，通过以下命令查找并删除所有相关文件的历史记录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 其中 assets/img/shan.png 为要删除的文件</span>
git filter-branch <span class="nt">--force</span> <span class="nt">--index-filter</span> <span class="s1">'git rm --cached --ignore-unmatch assets/img/shan.png'</span> <span class="nt">--prune-empty</span> <span class="nt">--tag-name-filter</span> <span class="nb">cat</span> <span class="nt">--</span> <span class="nt">--all</span>
</code></pre></div></div>

<p>排查结束后，会显示涉及到该文件的分支列表，如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ref <span class="s1">'refs/heads/gh-pages'</span> was rewritten
Ref <span class="s1">'refs/heads/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/dev'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/gh-pages'</span> was rewritten
WARNING: Ref <span class="s1">'refs/remotes/origin/master'</span> is unchanged
</code></pre></div></div>

<p>将 <code class="language-plaintext highlighter-rouge">rewritten</code> 的本地分支 push 到 GitHub，然后在 Cloudflare 上重新部署。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout master
git push <span class="nt">-f</span> origin master

git checkout gh-pages
git push <span class="nt">-f</span> origin gh-pages
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[渊源]]></summary></entry><entry><title type="html">PlantUML-Language Pdf</title><link href="https://gbcpp.github.io/PlantUML-Language-book.html" rel="alternate" type="text/html" title="PlantUML-Language Pdf" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/PlantUML-Language-book</id><content type="html" xml:base="https://gbcpp.github.io/PlantUML-Language-book.html"><![CDATA[<h1 id="plantuml-语法字典">PlantUML 语法字典</h1>

<p>查看 和 下载地址：<a href="/assets/books/PlantUML_Language_Reference_Guide_zh.pdf">PlantUML-Language</a></p>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[PlantUML 语法字典]]></summary></entry><entry><title type="html">RtcDataChannel(sctp) protocol optimize</title><link href="https://gbcpp.github.io/sctp-optimize.html" rel="alternate" type="text/html" title="RtcDataChannel(sctp) protocol optimize" /><published>2023-09-30T00:00:00+00:00</published><updated>2023-09-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/sctp-optimize</id><content type="html" xml:base="https://gbcpp.github.io/sctp-optimize.html"><![CDATA[<h1 id="datachannel-实现">DataChannel 实现</h1>
<p>DataChannel 的实现有两种，webrtc 目前使用自行基于 C++ 开发的 dcsctp，mediasoup 和 libdatachannel 基于 usrsctp，usrsctp 为开源 sctp 协议实现，均遵守 rfc 4960 标准。
RFC：https://tools.ietf.org/html/rfc4960</p>

<h1 id="能力概述">能力概述</h1>
<p>DataChannel (SCTP）支持可靠传输、不可靠传输两种模式，其中不可靠传输有两种方式：一种基于配置包最大生命周期进行配置，另一种是基于最大重传次数进行配置。</p>

<p>如若使用可靠传输只需将Client 端的 reliable 配置为 true 即可，Server 的 usrsctp 中的 <code class="language-plaintext highlighter-rouge">spa.sendv_prinfo.pr_policy</code> 配置为  <code class="language-plaintext highlighter-rouge">SCTP_PR_SCTP_NONE</code> 即可；</p>

<p>如若需要使用不可靠传输模式，则分以下两种方式：基于生存时间和重传次数，二者只能选其一：
基于最大生命周期 <code class="language-plaintext highlighter-rouge">maxRetransTime</code> 为数据报在 sctp 队列中最大存活时间，该参数可以保证发送队列可以快速的情况，尽量降低后续包发送失败的概率，但是存在在网络拥塞的情况下，因 CC 控制导致数据报尚未发送便被清理的问题，即数据包没有经过一次发送便因超时而被清理了。</p>

<p>基于最大重传次数 <code class="language-plaintext highlighter-rouge">maxRetrans</code> 为数据报在发送队列中最多重传的次数，可保证数据至少在网络中发送一次，但如若出现了网络丢包，不会进行重传；注意：在 usrsctp 中，此参数至少要配置为 1 才能保证至少发送一次，与 client 不同。</p>

<h1 id="性能">性能</h1>
<p>两者默认都较弱，不论是其可靠传输，还是不可靠传输，抗弱网能力均较弱，但测试下来 usrsctp 比 dcsctp 要强一些，不过 usrsctp 基于 c 开发，代码缩写、简写严重，难以阅读理解，而 dcsctp 基于 C++ 实现，相对要容易理解一些；</p>

<h1 id="弱网性能">弱网性能</h1>
<p>在可靠传输模式下，30% 的丢包即为上限，整体还不如 tcp，具体数据暂不列了，更高的丢包率测试无法进行下去。</p>

<h2 id="原因分析">原因分析</h2>

<h3 id="发送窗口">发送窗口</h3>

<p>sctp 在拥塞控制算法上与 tcp 类似，分为慢启动、拥塞避免、快速恢复 和快速重传几个阶段。
在出现弱网，即出现 丢包 或者 重传超时的情况时，发送窗口 cwnd 和 慢启动阈值 ssthresh 减半，降低过快，同时其 cwnd 最低值过低，首先从这一点进行入手分析。
以下 Url 是 RFC 中对 CWnd 和 SStreash 的配置策略：
	https://datatracker.ietf.org/doc/html/rfc4960#section-6.3.3
	https://datatracker.ietf.org/doc/html/rfc4960#section-7.2.3
原文如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7.2.3.  Congestion Control

   Upon detection of packet losses from SACK (see Section 7.2.4), an
   endpoint should do the following:

      ssthresh = max(cwnd/2, 4*MTU)
      cwnd = ssthresh
      partial_bytes_acked = 0

   Basically, a packet loss causes cwnd to be cut in half.

   When the T3-rtx timer expires on an address, SCTP should perform slow
   start by:

      ssthresh = max(cwnd/2, 4*MTU)
      cwnd = 1*MTU

   and ensure that no more than one SCTP packet will be in flight for
   that address until the endpoint receives acknowledgement for
   successful delivery of data to that address.
</code></pre></div></div>
<p>大致意思如下：
在检测到丢包时，更新 sstresh 和 cwnd 机制如下：
对原 ssthresh 减半，但最大为 4 个 MTU 大小，这个是致命的，同时将 cwnd 更新为 ssthresh；
当 T3-rtx 重传定时器超时时：
对原 ssthresh 减半，但最大为 4 个 MTU 大小，但对 cwnd 更新为仅 1 个 MTU。
通过上述两种机制，可以看到，在高丢包率的弱网环境中，很容易进入到上述两种 case 中，结合 flighting 的数据大小，导致 sctp 协议可发送数据量奇小 （cwnd 过小），同时因为重传包的优先级高于新生成的数据包，导致协议唯一的一个发送窗口一直在重传旧包，新包很难获取发送机会，这就导致了明显的队头阻塞现象。
解决方案：目标只是为了不使 CWnd 的大小降低的过快，即在检测到丢包和 T3-rtx 超时时，不要立即对 ssthresh 减半，而是更加平滑的去降低，并且提高最小值的上限，通过这两种策略的优化，可以保证 sctp 协议有很高的带宽抢占能力，因为发送窗口越大，带宽抢占能力就越高。</p>

<h3 id="清空队列">清空队列</h3>

<p>通过上述策略优化发送窗口后，可以大幅度提高 sctp 在弱网（双向各30%丢包率）下的带宽传输能力，但是在更极端的网损（40%丢包，甚至更高）场景下，依然会出现队头阻塞现象，发送端不再主动发送新插入的数据，而是优先发送旧包（未收到 Ack），在实际应用场景中，我们希望不论是否收到对端的确认，都不应该阻塞新包的发送，和旧包的清理，以保证发送队列有一个快速的清理速度，且保证所有的数据均有机会被快速的发送到网络中去。
如果双方均为开源的实现，我们可以随意修改 sctp，可快速解决上述问题，但是当一端为浏览器时，我们只能考虑修改 Server 侧的协议实现，以期可以间接的影响到对端（浏览器），让对端（浏览器）最为发送端时，可以快速的清空发送队列，避免队头阻塞，答案就在 SACK 包中，首先看下 SACK 包的协议定义：
https://datatracker.ietf.org/doc/html/rfc4960#section-3.3.4</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.3.4.  Selective Acknowledgement (SACK) (3)

   This chunk is sent to the peer endpoint to acknowledge received DATA
   chunks and to inform the peer endpoint of gaps in the received
   subsequences of DATA chunks as represented by their TSNs.

   The SACK MUST contain the Cumulative TSN Ack, Advertised Receiver
   Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of
   Duplicate TSNs fields.

   By definition, the value of the Cumulative TSN Ack parameter is the
   last TSN received before a break in the sequence of received TSNs
   occurs; the next TSN value following this one has not yet been
   received at the endpoint sending the SACK.  This parameter therefore
   acknowledges receipt of all TSNs less than or equal to its value.

   The handling of a_rwnd by the receiver of the SACK is discussed in
   detail in Section 6.2.1.

   The SACK also contains zero or more Gap Ack Blocks.  Each Gap Ack
   Block acknowledges a subsequence of TSNs received following a break
   in the sequence of received TSNs.  By definition, all TSNs
   acknowledged by Gap Ack Blocks are greater than the value of the
   Cumulative TSN Ack.


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 3    |Chunk  Flags   |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Cumulative TSN Ack                       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Advertised Receiver Window Credit (a_rwnd)           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN 1                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN X                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Chunk Flags: 8 bits

      Set to all '0's on transmit and ignored on receipt.

   Cumulative TSN Ack: 32 bits (unsigned integer)

      This parameter contains the TSN of the last DATA chunk received in
      sequence before a gap.  In the case where no DATA chunk has been
      received, this value is set to the peer's Initial TSN minus one.

   Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned
   integer)

      This field indicates the updated receive buffer space in bytes of
      the sender of this SACK; see Section 6.2.1 for details.

   Number of Gap Ack Blocks: 16 bits (unsigned integer)

      Indicates the number of Gap Ack Blocks included in this SACK.

   

   Number of Duplicate TSNs: 16 bit

      This field contains the number of duplicate TSNs the endpoint has
      received.  Each duplicate TSN is listed following the Gap Ack
      Block list.

   Gap Ack Blocks:

      These fields contain the Gap Ack Blocks.  They are repeated for
      each Gap Ack Block up to the number of Gap Ack Blocks defined in
      the Number of Gap Ack Blocks field.  All DATA chunks with TSNs
      greater than or equal to (Cumulative TSN Ack + Gap Ack Block
      Start) and less than or equal to (Cumulative TSN Ack + Gap Ack
      Block End) of each Gap Ack Block are assumed to have been received
      correctly.

   Gap Ack Block Start: 16 bits (unsigned integer)

      Indicates the Start offset TSN for this Gap Ack Block.  To
      calculate the actual TSN number the Cumulative TSN Ack is added to
      this offset number.  This calculated TSN identifies the first TSN
      in this Gap Ack Block that has been received.

   Gap Ack Block End: 16 bits (unsigned integer)

      Indicates the End offset TSN for this Gap Ack Block.  To calculate
      the actual TSN number, the Cumulative TSN Ack is added to this
      offset number.  This calculated TSN identifies the TSN of the last
      DATA chunk received in this Gap Ack Block.
</code></pre></div></div>

<p>每一个 SACK 包中，均包括一个字段：<code class="language-plaintext highlighter-rouge">Cumulative TSN</code>，该字段标识接收端已确认（通知给 Application）的最大包序号（TSN），通过此字段告诉发送端，不要再发送小于此 TSN 的包，并清空所有队列中，小于等于此 TSN 的数据包，其它的字段均不是最重要的，可以自行决定是否调整。
只有当发送端不断的接收到接收端发来的 SACK 包后，通过其携带的强制前移的 <code class="language-plaintext highlighter-rouge">Cumulative TSN</code> 来清理本地的发送队列，可以保证自己的发送队列一直处于一个较小的 Cache，这样，新插入的数据包便可以被快速的发送出去，避免了因旧包未被 Ack 而导致的队头阻塞问题，更加的贴近 UDP 的行为。</p>

<p>Ok，那么回溯下这个问题的上一步：为什么发送端无法快速的清空自己的发送队列的呢？我们看下 RFC 的定义便知，https://datatracker.ietf.org/doc/html/rfc4960#section-6.1
原文如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6.1.  Transmission of DATA Chunks

   This document is specified as if there is a single retransmission
   timer per destination transport address, but implementations MAY have
   a retransmission timer for each DATA chunk.

   The following general rules MUST be applied by the data sender for
   transmission and/or retransmission of outbound DATA chunks:

   A) At any given time, the data sender MUST NOT transmit new data to
      any destination transport address if its peer's rwnd indicates
      that the peer has no buffer space (i.e., rwnd is 0; see Section
      6.2.1).  However, regardless of the value of rwnd (including if it
      is 0), the data sender can always have one DATA chunk in flight to
      the receiver if allowed by cwnd (see rule B, below).  This rule
      allows the sender to probe for a change in rwnd that the sender
      missed due to the SACK's having been lost in transit from the data
      receiver to the data sender.

      When the receiver's advertised window is zero, this probe is
      called a zero window probe.  Note that a zero window probe SHOULD
      only be sent when all outstanding DATA chunks have been
      cumulatively acknowledged and no DATA chunks are in flight.  Zero
      window probing MUST be supported.

      If the sender continues to receive new packets from the receiver
      while doing zero window probing, the unacknowledged window probes
      should not increment the error counter for the association or any
      destination transport address.  This is because the receiver MAY
      keep its window closed for an indefinite time.  Refer to Section
      6.2 on the receiver behavior when it advertises a zero window.
      The sender SHOULD send the first zero window probe after 1 RTO
      when it detects that the receiver has closed its window and SHOULD
      increase the probe interval exponentially afterwards.  Also note
      that the cwnd SHOULD be adjusted according to Section 7.2.1.  Zero
      window probing does not affect the calculation of cwnd.

      The sender MUST also have an algorithm for sending new DATA chunks
      to avoid silly window syndrome (SWS) as described in [RFC0813].
      The algorithm can be similar to the one described in Section
      4.2.3.4 of [RFC1122].

      However, regardless of the value of rwnd (including if it is 0),
      the data sender can always have one DATA chunk in flight to the
      receiver if allowed by cwnd (see rule B below).  This rule allows
      the sender to probe for a change in rwnd that the sender missed
      due to the SACK having been lost in transit from the data receiver
      to the data sender.

   B) At any given time, the sender MUST NOT transmit new data to a
      given transport address if it has cwnd or more bytes of data
      outstanding to that transport address.

   C) When the time comes for the sender to transmit, before sending new
      DATA chunks, the sender MUST first transmit any outstanding DATA
      chunks that are marked for retransmission (limited by the current
      cwnd).

   D) When the time comes for the sender to transmit new DATA chunks,
      the protocol parameter Max.Burst SHOULD be used to limit the
      number of packets sent.  The limit MAY be applied by adjusting
      cwnd as follows:

      if((flightsize + Max.Burst*MTU) &lt; cwnd) cwnd = flightsize +
      Max.Burst*MTU

      Or it MAY be applied by strictly limiting the number of packets
      emitted by the output routine.

   E) Then, the sender can send out as many new DATA chunks as rule A
      and rule B allow.

   Multiple DATA chunks committed for transmission MAY be bundled in a
   single packet.  Furthermore, DATA chunks being retransmitted MAY be
   bundled with new DATA chunks, as long as the resulting packet size
   does not exceed the path MTU.  A ULP may request that no bundling is
   performed, but this should only turn off any delays that an SCTP
   implementation may be using to increase bundling efficiency.  It does
   not in itself stop all bundling from occurring (i.e., in case of
   congestion or retransmission).

   Before an endpoint transmits a DATA chunk, if any received DATA
   chunks have not been acknowledged (e.g., due to delayed ack), the
   sender should create a SACK and bundle it with the outbound DATA
   chunk, as long as the size of the final SCTP packet does not exceed
   the current MTU.  See Section 6.2.

   IMPLEMENTATION NOTE: When the window is full (i.e., transmission is
   disallowed by rule A and/or rule B), the sender MAY still accept send
   requests from its upper layer, but MUST transmit no more DATA chunks
   until some or all of the outstanding DATA chunks are acknowledged and
   transmission is allowed by rule A and rule B again.

   Whenever a transmission or retransmission is made to any address, if
   the T3-rtx timer of that address is not currently running, the sender
   MUST start that timer.  If the timer for that address is already
   running, the sender MUST restart the timer if the earliest (i.e.,
   lowest TSN) outstanding DATA chunk sent to that address is being
   retransmitted.  Otherwise, the data sender MUST NOT restart the
   timer.

   When starting or restarting the T3-rtx timer, the timer value must be
   adjusted according to the timer rules defined in Sections 6.3.2 and
   6.3.3.

   Note: The data sender SHOULD NOT use a TSN that is more than 2**31 -
   1 above the beginning TSN of the current send window.
</code></pre></div></div>

<p>根据上述定义，再结合上面 CWND 的更新策略，可以推测出，在高丢包的弱网情况下，Sender 很容易 Trigger 因连续未收到 Receiver 的 Ack，同时自己的 Inflighting 数据量较多，导致自己可发送的数据量非常小（最小为 1 个 MTU），甚至发送 0 Bytes 的探测包代替，从而出现严重的对头阻塞问题。</p>

<blockquote>
  <p>但是按照上述方案通过接收端强制偏移 TSN，以达到发送端快速清空发送队列的目标时，DataChannel/SCTP 的可靠传输能力便丧失了。</p>
</blockquote>

<h3 id="sack-chunk-源码">SACK Chunk 源码</h3>

<p>首先整理下 sctp 协议内接收端组装sack 的数据结构 （https://tools.ietf.org/html/rfc4960#section-3.3.4），在 dcsctp 的代码中比较易懂，定义如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SackChunk</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Chunk</span><span class="p">,</span> <span class="k">public</span> <span class="n">TLVTrait</span><span class="o">&lt;</span><span class="n">SackChunkConfig</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">kType</span> <span class="o">=</span> <span class="n">SackChunkConfig</span><span class="o">::</span><span class="n">kType</span><span class="p">;</span>

  <span class="c1">// 可以看出包序号使用的是 uint16_t，只需两个字节  </span>
  <span class="k">struct</span> <span class="nc">GapAckBlock</span> <span class="p">{</span>
    <span class="n">GapAckBlock</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">end</span><span class="p">)</span> <span class="o">:</span> <span class="n">start</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">uint16_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">end</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">GapAckBlock</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">start</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">SackChunk</span><span class="p">(</span><span class="n">TSN</span> <span class="n">cumulative_tsn_ack</span><span class="p">,</span>
            <span class="kt">uint32_t</span> <span class="n">a_rwnd</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;</span> <span class="n">duplicate_tsns</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">cumulative_tsn_ack_</span><span class="p">(</span><span class="n">cumulative_tsn_ack</span><span class="p">),</span>
        <span class="n">a_rwnd_</span><span class="p">(</span><span class="n">a_rwnd</span><span class="p">),</span>
        <span class="n">gap_ack_blocks_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">gap_ack_blocks</span><span class="p">)),</span>
        <span class="n">duplicate_tsns_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">duplicate_tsns</span><span class="p">))</span> <span class="p">{}</span>
  <span class="k">static</span> <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">SackChunk</span><span class="o">&gt;</span> <span class="n">Parse</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">SerializeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ToString</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">TSN</span> <span class="n">cumulative_tsn_ack</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cumulative_tsn_ack_</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">uint32_t</span> <span class="n">a_rwnd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a_rwnd_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">gap_ack_blocks_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;&amp;</span> <span class="n">duplicate_tsns</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">duplicate_tsns_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kGapAckBlockSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kDupTsnBlockSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">TSN</span> <span class="n">cumulative_tsn_ack_</span><span class="p">;</span>             <span class="c1">// 最大已确认包序号，TSN 即为内部传输块的序号</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">a_rwnd_</span><span class="p">;</span>                    <span class="c1">// 接收窗口的大小</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GapAckBlock</span><span class="o">&gt;</span> <span class="n">gap_ack_blocks_</span><span class="p">;</span>  <span class="c1">// GAP 包序号范围，一次聚合多个</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TSN</span><span class="o">&gt;</span> <span class="n">duplicate_tsns_</span><span class="p">;</span>             <span class="c1">// 收到的已确认的包序号</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这里，可能有些疑问，每次打包的 SACK 中，其 gap_ack_blocks_ 和 duplicate_tsns_ 是否有最大个数/长度限制，因为它们两个毕竟是要全部一个个的序列化到网络包中的，答案是：有的。
两者 gap_ack_blocks_ 和 duplicate_tsns_ 单次限制上限为 20 个，kMaxGapAckBlocksReported 和 kMazhimaxDuplicateTsnReported 均定义为 constexpr 值：20，声明在代码文件：data_tracker.h中。</p>

<h3 id="sack-发包时机">SACK 发包时机</h3>

<p>在 dcsctp 的实现中，sack 的发送时机是动态的。在没有数据包丢失时，每秒钟发送一次，当监测到丢包时，针对每个数据包发送一次 sack；当不直接发送 SACKS 时，将使用 timer 控制 sack 的延迟发送，比如 min(RTO/2，200ms)。</p>

<p>发送端接收到对端回应的 SACK 后，判断如果其 cumulative tsn 比本地记录的最大的 last cumulative tsn 要大（即没有回退），则重启 ts_rtx_ 定时器。</p>

<h1 id="遗留问题">遗留问题</h1>

<h2 id="rtt-计算">RTT 计算</h2>

<p>有明显问题，如下两种：
在 dcsctp 中看到 RTT 的计算是有漏洞的，其在 sack 中没有 gap_ack_blocks 时，通过 cumulative tsn 计算其 rtt，存在两种风险:</p>
<ul>
  <li>这个 sack 整体是有延迟的，其计算 rtt 时，是直接通过 sendts - current ts，明显没有考虑 delay ack time；</li>
  <li>其只有在没有 gap_ack_blocks 时，即没有出现丢包时才统计其 RTT，这样在丢包严重时，可能会出现长时间无法更新 rtt，或者在 rtt 和 loss 突然增大时，出现长时间无法更新 rtt 的情况，一直以旧的 rtt 为准。</li>
</ul>]]></content><author><name>Mr Chen</name></author><category term="协议" /><summary type="html"><![CDATA[DataChannel 实现 DataChannel 的实现有两种，webrtc 目前使用自行基于 C++ 开发的 dcsctp，mediasoup 和 libdatachannel 基于 usrsctp，usrsctp 为开源 sctp 协议实现，均遵守 rfc 4960 标准。 RFC：https://tools.ietf.org/html/rfc4960]]></summary></entry><entry><title type="html">后台服务绑定 CPU 核</title><link href="https://gbcpp.github.io/service-bind-cpu.html" rel="alternate" type="text/html" title="后台服务绑定 CPU 核" /><published>2023-09-30T00:00:00+00:00</published><updated>2023-09-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/service-bind-cpu</id><content type="html" xml:base="https://gbcpp.github.io/service-bind-cpu.html"><![CDATA[<blockquote>
  <p>一个 Prod 用的服务启动升级脚本，检查了 CPU 核心数，并按照指定顺序绑定 CPU 核心，以提升性能。</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">SERVICENAME</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">VERSION</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">BINPATH</span><span class="o">=</span>/home/devops/<span class="nv">$SERVICENAME</span>/bin/
<span class="nv">PACKAGE</span><span class="o">=</span>/home/devops/<span class="nv">$SERVICENAME</span>/package/

<span class="c"># xxx 进程名|进程文件名</span>
<span class="nv">PROCESS</span><span class="o">=</span><span class="nv">$SERVICENAME</span>.exe
<span class="nv">LOCK_FILE</span><span class="o">=</span><span class="s2">"/</span><span class="nv">$BINPATH</span><span class="s2">/.xxxxx.</span><span class="nv">$PROCESS</span><span class="s2">.lock"</span>

<span class="c"># we think cpu binding means will enable cpu perception</span>
<span class="nv">USE_CPU_TOPOLOGY_SERVER_TYPE</span><span class="o">=</span><span class="s2">"server"</span>
<span class="nv">USE_CPU_TOPOLOGY_TAG</span><span class="o">=</span><span class="s2">"vm_use_cpu_topology:true vm_bind_cpu:true"</span>
<span class="nv">USE_CPU_TOPOLOGY_PROVIDER</span><span class="o">=</span><span class="s2">"aws"</span>
<span class="nv">USE_CPU_TOPOLOGY_IDC</span><span class="o">=</span><span class="s2">""</span>

<span class="nv">USE_CPU_TOPOLOGY</span><span class="o">=</span>

<span class="c"># control bind core and xdp in hybrid deployment machine</span>
<span class="nv">is_hybrid</span><span class="o">=</span>0

<span class="k">function </span>CheckDir<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="nv">$BINPATH</span> <span class="o">]</span><span class="p">;</span> <span class="k">then </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> <span class="nv">$BINPATH</span><span class="p">;</span> <span class="k">fi</span>
<span class="o">}</span>

<span class="k">function </span>CheckHybridDeploy<span class="o">()</span> <span class="o">{</span>
    <span class="nv">get_message</span><span class="o">=</span><span class="sb">`</span>curl <span class="nt">-4</span> https://meta.xxxxx.co/latest/meta-data/tag <span class="nt">--max-time</span> 10<span class="sb">`</span>
    <span class="nv">match</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="k">${</span><span class="nv">get_message</span><span class="k">}</span> | <span class="nb">grep</span> <span class="nt">-a</span> <span class="s2">"servicevosmixed:1"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="sb">`</span>
    <span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">match</span><span class="k">}</span> <span class="nt">-gt</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">is_hybrid</span><span class="o">=</span>1
    <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">"Is hybrid : </span><span class="k">${</span><span class="nv">is_hybrid</span><span class="k">}</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 排他锁，防止相同时间内进行其它操作，比如操作时，防止zabbix触发自动拉起</span>
<span class="k">function </span>Lock<span class="o">()</span> <span class="o">{</span>
    <span class="nb">ls</span> <span class="s2">"</span><span class="nv">$LOCK_FILE</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">sudo touch</span> <span class="s2">"</span><span class="nv">$LOCK_FILE</span><span class="s2">"</span>
    <span class="k">else
        </span><span class="nv">lockTime</span><span class="o">=</span><span class="si">$(</span><span class="nb">stat</span> <span class="nt">-t</span> <span class="s2">"</span><span class="nv">$LOCK_FILE</span><span class="s2">"</span> | <span class="nb">awk</span> <span class="s1">'{print $12}'</span><span class="si">)</span>
        <span class="nv">currentTime</span><span class="o">=</span><span class="si">$(</span><span class="nb">date</span> +%s<span class="si">)</span>
        <span class="nv">duration</span><span class="o">=</span><span class="k">$((</span>currentTime <span class="o">-</span> lockTime<span class="k">))</span>
        <span class="nb">echo</span> <span class="nv">$duration</span>
        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$duration</span> <span class="nt">-gt</span> 20 <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">sudo touch</span> <span class="s2">"</span><span class="nv">$LOCK_FILE</span><span class="s2">"</span>
        <span class="k">else
            </span><span class="nb">echo</span> <span class="s2">"Less than 20 seconds since last operation"</span>
            <span class="nb">exit </span>1
        <span class="k">fi
    fi</span>
<span class="o">}</span>

<span class="k">function </span>Unlock<span class="o">()</span> <span class="o">{</span>
    <span class="nb">sudo rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$LOCK_FILE</span><span class="s2">"</span>
<span class="o">}</span>

<span class="k">function </span>NeedUseCPUTopology<span class="o">()</span> <span class="o">{</span> <span class="c"># not zero mean need bind cpu</span>

    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY</span><span class="k">}</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        return</span> <span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY</span><span class="k">}</span>
    <span class="k">fi</span>
    
    <span class="c"># check is vm</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY_SERVER_TYPE</span><span class="k">}</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span><span class="s2">"</span><span class="si">$(</span>hostnamectl | <span class="nb">grep </span>Chassis | <span class="nb">cut</span> <span class="nt">-d</span> <span class="s1">':'</span> <span class="nt">-f2</span> | xargs<span class="si">)</span><span class="s2">"</span><span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">USE_CPU_TOPOLOGY</span><span class="o">=</span>1
        <span class="k">return</span> <span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY</span><span class="k">}</span>
    <span class="k">fi</span>
    
    <span class="c"># get machine tag</span>
    <span class="k">for </span>machine_tag <span class="k">in</span> <span class="si">$(</span><span class="nb">timeout </span>10 curl https://meta.xxxxx.co/2022-09-13/meta-data/tag 2&gt;/dev/null<span class="si">)</span><span class="p">;</span> <span class="k">do
        if</span> <span class="o">[[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY_TAG</span><span class="k">}</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span><span class="s2">"</span><span class="k">${</span><span class="nv">machine_tag</span><span class="k">}</span><span class="s2">"</span><span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">USE_CPU_TOPOLOGY</span><span class="o">=</span>1
            <span class="k">return</span> <span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY</span><span class="k">}</span>
        <span class="k">fi
    done</span>
    
    <span class="c"># # get cluster name</span>
    <span class="c"># if [[ "${USE_CPU_TOPOLOGY_IDC}" == *"$(curl https://meta.xxxxx.co/2022-09-13/meta-data/cluster 2&gt;/dev/null)"* ]]; then</span>
    <span class="c">#     USE_CPU_TOPOLOGY=1;</span>
    <span class="c">#     return ${USE_CPU_TOPOLOGY}</span>
    <span class="c"># fi</span>
    
    <span class="c"># get provider</span>
    <span class="c"># if [[ "${USE_CPU_TOPOLOGY_PROVIDER}" == *"$(curl https://meta.xxxxx.co/2022-09-13/meta-data/provider 2&gt;/dev/null)"* ]]; then</span>
    <span class="c">#     USE_CPU_TOPOLOGY=1;</span>
    <span class="c">#     return ${USE_CPU_TOPOLOGY}</span>
    <span class="c"># fi</span>
    
    <span class="nv">USE_CPU_TOPOLOGY</span><span class="o">=</span>0
    <span class="k">return</span> <span class="k">${</span><span class="nv">USE_CPU_TOPOLOGY</span><span class="k">}</span>

<span class="o">}</span>

<span class="c"># 获取当前机器物理核心数</span>
<span class="k">function </span>GetCpuNumber<span class="o">()</span> <span class="o">{</span>
    <span class="c"># if not use topology, we will presume machine have open HT, and just return all process count / 2</span>
    NeedUseCPUTopology <span class="o">&amp;&amp;</span> <span class="o">{</span> <span class="nb">echo</span> <span class="k">$((</span><span class="si">$(</span><span class="nb">grep</span> <span class="nt">-c</span> processor /proc/cpuinfo<span class="si">)</span> <span class="o">/</span> <span class="m">2</span><span class="k">))</span> <span class="o">&amp;&amp;</span> <span class="k">return </span>0<span class="p">;</span> <span class="o">}</span>
    
    <span class="nv">CORE</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep</span> <span class="s2">"core id"</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    <span class="nv">PHYSICAL</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep</span> <span class="s2">"physical id"</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    <span class="nv">LOGIC</span><span class="o">=</span><span class="k">$((</span>CORE <span class="o">*</span> PHYSICAL<span class="k">))</span>
    <span class="nb">echo</span> <span class="nv">$LOGIC</span>
<span class="o">}</span>

<span class="k">function </span>GetMemTotalSize<span class="o">()</span> <span class="o">{</span>
    <span class="nv">memTotalSize</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> /proc/meminfo | <span class="nb">grep </span>MemTotal | <span class="nb">awk</span> <span class="s1">'{print $2}'</span><span class="si">)</span>
    <span class="nb">echo</span> <span class="nv">$memTotalSize</span>
<span class="o">}</span>

<span class="c"># 设置进程数</span>
<span class="k">function </span>GetProcessNumber<span class="o">()</span> <span class="o">{</span>
    <span class="nb">local </span><span class="nv">processNumber</span><span class="o">=</span>1
    <span class="nv">cpuNumber</span><span class="o">=</span><span class="si">$(</span>GetCpuNumber<span class="si">)</span>
    <span class="nv">memTotalSize</span><span class="o">=</span><span class="si">$(</span>GetMemTotalSize<span class="si">)</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$cpuNumber</span> <span class="nt">-ge</span> 10 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">processNumber_tmp</span><span class="o">=</span><span class="k">$((</span>cpuNumber <span class="o">-</span> <span class="m">2</span><span class="k">))</span>
        <span class="c"># 内存总容量足够的机器按满配起</span>
        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$memTotalSize</span> <span class="nt">-ge</span> <span class="k">$((</span>processNumber_tmp <span class="o">*</span> <span class="m">2359296</span><span class="k">))</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">processNumber_pre</span><span class="o">=</span><span class="nv">$processNumber_tmp</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="nv">$approuter_running</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
                </span><span class="nv">processNumber</span><span class="o">=</span><span class="k">$((</span>processNumber_pre <span class="o">-</span> <span class="m">4</span><span class="k">))</span>
            <span class="k">else
                </span><span class="nv">processNumber</span><span class="o">=</span><span class="nv">$processNumber_pre</span>
            <span class="k">fi</span>
        <span class="c"># 内存总容量不够的机器计算实际要起的进程数</span>
        <span class="k">else
            </span><span class="nv">processNumber_pre</span><span class="o">=</span><span class="k">$((</span>memTotalSize <span class="o">/</span> <span class="m">2359296</span><span class="k">))</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="nv">$approuter_running</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
                </span><span class="nv">processNumber</span><span class="o">=</span><span class="k">$((</span>processNumber_pre <span class="o">-</span> <span class="m">4</span><span class="k">))</span>
            <span class="k">else
                </span><span class="nv">processNumber</span><span class="o">=</span><span class="nv">$processNumber_pre</span>
            <span class="k">fi
        fi
    elif</span> <span class="o">[[</span> <span class="nv">$cpuNumber</span> <span class="nt">-gt</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">processNumber_pre</span><span class="o">=</span><span class="k">$((</span>cpuNumber <span class="o">-</span> <span class="m">1</span><span class="k">))</span>
        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$approuter_running</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">processNumber</span><span class="o">=</span><span class="k">$((</span>processNumber_pre <span class="o">-</span> <span class="m">4</span><span class="k">))</span>
        <span class="k">else
            </span><span class="nv">processNumber</span><span class="o">=</span><span class="nv">$processNumber_pre</span>
        <span class="k">fi
    elif</span> <span class="o">[[</span> <span class="nv">$cpuNumber</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">processNumber</span><span class="o">=</span>1
    <span class="k">fi
    if</span> <span class="o">[</span> <span class="nv">$processNumber</span> <span class="nt">-gt</span> 30 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">processNumber</span><span class="o">=</span>30
    <span class="k">fi
    </span><span class="nb">echo</span> <span class="nv">$processNumber</span>
<span class="o">}</span>

<span class="k">function </span>CheckApprouterProcessRunningStaus<span class="o">()</span> <span class="o">{</span>
    <span class="nv">approuterNumber</span><span class="o">=</span><span class="si">$(</span>ps aux | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"reuseport.exe"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$approuterNumber</span> <span class="nt">-gt</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">approuter_running</span><span class="o">=</span>1
    <span class="k">else
        </span><span class="nv">approuter_running</span><span class="o">=</span>0
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 检查当前进程数</span>
<span class="k">function </span>CheckProcessNumber<span class="o">()</span> <span class="o">{</span>
    <span class="nv">processNumber</span><span class="o">=</span><span class="si">$(</span>GetProcessNumber<span class="si">)</span>
    <span class="nv">currentNumber</span><span class="o">=</span><span class="si">$(</span>ps aux | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"./</span><span class="nv">$PROCESS</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'gzip'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nv">$0</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"appRestart</span><span class="se">\|</span><span class="s2">appStart</span><span class="se">\|</span><span class="s2">appStop</span><span class="se">\|</span><span class="s2">appUpgrade"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$currentNumber</span> <span class="nt">-ne</span> <span class="nv">$processNumber</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"current process number: </span><span class="nv">$currentNumber</span><span class="s2">, need process number: </span><span class="nv">$processNumber</span><span class="s2">"</span>
        Unlock
        <span class="nb">exit </span>1
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 检查当前进程数</span>
<span class="k">function </span>CheckNoProcess<span class="o">()</span> <span class="o">{</span>
    <span class="nv">currentNumber</span><span class="o">=</span><span class="si">$(</span>ps aux | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"./</span><span class="nv">$PROCESS</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'gzip'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nv">$0</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"appRestart</span><span class="se">\|</span><span class="s2">appStart</span><span class="se">\|</span><span class="s2">appStop</span><span class="se">\|</span><span class="s2">appUpgrade"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>

    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$currentNumber</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"current process number: </span><span class="nv">$currentNumber</span><span class="s2">, should be 0"</span>
        Unlock
        <span class="nb">exit </span>1
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 停止进程</span>
<span class="k">function </span>Stop<span class="o">()</span> <span class="o">{</span>
    <span class="nb">sudo </span>killall <span class="nt">-q</span> <span class="s2">"</span><span class="nv">$PROCESS</span><span class="s2">"</span>
    <span class="nb">sleep </span>30
    <span class="nb">echo</span> <span class="s2">"Stop Process finished"</span>
    CheckNoProcess
<span class="o">}</span>

<span class="c"># 升级程序</span>
<span class="k">function </span>Upgrade<span class="o">()</span> <span class="o">{</span>
    <span class="c">#检查文件是否存在</span>
    <span class="k">if </span><span class="nb">test</span> <span class="o">!</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$PACKAGE</span><span class="s2">/</span><span class="nv">$SERVICENAME</span><span class="s2">.exe"</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"upgrade package not exist"</span>
        <span class="nb">exit </span>1
    <span class="k">fi</span>
    
    <span class="c">#检查程序及版本</span>
    <span class="nb">local </span><span class="nv">exeVersion</span><span class="o">=</span><span class="si">$(</span><span class="s2">"</span><span class="nv">$PACKAGE</span><span class="s2">/</span><span class="nv">$SERVICENAME</span><span class="s2">.exe"</span> <span class="nt">-v</span> | <span class="nb">awk</span> <span class="s1">'{sub(/^[\t ]*/, "");print}'</span><span class="si">)</span>
    <span class="nb">local </span><span class="nv">upVersion</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PROCESS</span><span class="s2">"</span>_<span class="s2">"</span><span class="nv">$exeVersion</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$upVersion</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"</span><span class="nv">$VERSION</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"version mismatch, package version: </span><span class="nv">$upVersion</span><span class="s2">, need version: </span><span class="nv">$VERSION</span><span class="s2">"</span>
        Unlock
        <span class="nb">exit </span>1
    <span class="k">fi
    
    if </span><span class="nb">test</span> <span class="o">!</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$BINPATH</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$BINPATH</span><span class="s2">"</span>
    <span class="k">fi</span>
    
    <span class="c"># copy程序到bin下</span>
    <span class="nb">sudo cp</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PACKAGE</span><span class="s2">/</span><span class="nv">$SERVICENAME</span><span class="s2">.exe"</span> <span class="s2">"</span><span class="nv">$BINPATH</span><span class="s2">/</span><span class="nv">$PROCESS</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 启动进程</span>
<span class="k">function </span>Start<span class="o">()</span> <span class="o">{</span>
    <span class="nb">cd</span> <span class="s2">"</span><span class="nv">$BINPATH</span><span class="s2">"</span>
    <span class="nb">sudo </span>bash <span class="nt">-c</span> <span class="s2">"echo 3 &gt; /proc/sys/vm/drop_caches"</span>
    <span class="nb">sleep </span>10
    
    <span class="nv">processNumber</span><span class="o">=</span><span class="si">$(</span>GetProcessNumber<span class="si">)</span>
    <span class="nv">currentNumber</span><span class="o">=</span><span class="si">$(</span>ps aux | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"./</span><span class="nv">$PROCESS</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'gzip'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nv">$0</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"appRestart</span><span class="se">\|</span><span class="s2">appStart</span><span class="se">\|</span><span class="s2">appStop</span><span class="se">\|</span><span class="s2">appUpgrade"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    
    <span class="nb">echo</span> <span class="s2">"Need: </span><span class="nv">$processNumber</span><span class="s2">, Current: </span><span class="nv">$currentNumber</span><span class="s2">"</span>
    <span class="nv">run_process_command</span><span class="o">=</span><span class="k">${</span><span class="nv">PROCESS</span><span class="k">}</span>
    <span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">is_hybrid</span><span class="k">}</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">run_process_command</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">run_process_command</span><span class="k">}</span><span class="s2"> --disable_xdp=true"</span>
    <span class="k">fi
    for</span> <span class="o">((</span>i <span class="o">=</span> currentNumber<span class="p">;</span> i &lt; <span class="s2">"</span><span class="nv">$processNumber</span><span class="s2">"</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">sudo</span> ./<span class="nv">$run_process_command</span>
        <span class="nb">sleep </span>3
    <span class="k">done</span>
<span class="o">}</span>

<span class="c"># 绑定核心</span>
<span class="k">function </span>BindingProcesstoPhysicalCores<span class="o">()</span> <span class="o">{</span>

    NeedUseCPUTopology <span class="o">&amp;&amp;</span> <span class="k">return </span>0

    <span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">is_hybrid</span><span class="k">}</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then
        return </span>0
    <span class="k">fi
    
    </span><span class="nv">TOTAL_CPU</span><span class="o">=</span><span class="si">$(</span><span class="nb">grep</span> <span class="nt">-c</span> processor /proc/cpuinfo<span class="si">)</span>
    <span class="nv">CORE</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep</span> <span class="s2">"core id"</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    <span class="nv">PHYSICAL</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep</span> <span class="s2">"physical id"</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>
    <span class="nv">LOGIC</span><span class="o">=</span><span class="k">$((</span>CORE <span class="o">*</span> PHYSICAL<span class="k">))</span>
    <span class="nv">PIDS</span><span class="o">=</span><span class="si">$(</span>ps aux | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"./</span><span class="nv">$PROCESS</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nv">$0</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"start</span><span class="se">\|</span><span class="s2">ansible"</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span><span class="si">)</span>
    
    <span class="k">if</span> <span class="o">[[</span> <span class="k">$((</span><span class="nv">$TOTAL_CPU</span> <span class="o">/</span> <span class="m">2</span><span class="k">))</span> <span class="nt">-eq</span> <span class="nv">$LOGIC</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        if</span> <span class="o">[[</span> <span class="si">$(</span><span class="nb">cat</span> /sys/devices/system/cpu/cpu0/topology/thread_siblings_list | <span class="nb">grep</span> - | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">cpu_thread_seq</span><span class="o">=</span><span class="s2">"continuous"</span> <span class="c">#CPU-No. vs Core ID Like CPU0-Core0_Thread0,CPU1-Core0_Thread1,CPU2-Core1_Thread0,CPU3-Core1_Thread1...</span>
        <span class="k">else
            </span><span class="nv">cpu_thread_seq</span><span class="o">=</span><span class="s2">"discontinuous"</span> <span class="c">#CPU-No. vs Core ID Like CPU0-Core0_Thread0,CPU1-Core1_Thread0,..,CPU10-Core0_Thread1,CPU1-Core0_Thread1...</span>
        <span class="k">fi
    elif</span> <span class="o">[[</span> <span class="nv">$TOTAL_CPU</span> <span class="nt">-eq</span> <span class="nv">$LOGIC</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">cpu_thread_seq</span><span class="o">=</span><span class="s2">"na"</span> <span class="c"># CPU do not enable or not support Hyper-Threading</span>
    <span class="k">fi
    
    if</span> <span class="o">[[</span> <span class="nv">$cpu_thread_seq</span> <span class="o">=</span> <span class="s2">"discontinuous"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        if</span> <span class="o">[[</span> <span class="nv">$approuter_running</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="c">#有app_router保留4个核心，从倒数第5个物理核开始使用</span>
            <span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$LOGIC</span> <span class="o">-</span> <span class="m">5</span><span class="k">))</span>
        <span class="k">else
            </span><span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$LOGIC</span> <span class="o">-</span> <span class="m">1</span><span class="k">))</span> <span class="c">#没有app_router正常从最后1个物理核开始使用</span>
        <span class="k">fi
    
        for </span>pid <span class="k">in</span> <span class="k">${</span><span class="nv">PIDS</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
            </span><span class="nb">sudo </span>taskset <span class="nt">-p</span> <span class="nt">--cpu-list</span> <span class="nv">$cpu</span> <span class="nv">$pid</span>
            <span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$cpu</span> <span class="o">-</span> <span class="m">1</span><span class="k">))</span>
        <span class="k">done
    elif</span> <span class="o">[[</span> <span class="nv">$cpu_thread_seq</span> <span class="o">=</span> <span class="s2">"continuous"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        if</span> <span class="o">[[</span> <span class="nv">$approuter_running</span> <span class="nt">-eq</span> 1 <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="c">#有app_router保留4个核心即8个逻辑核，从倒数第10个逻辑核开始使用</span>
            <span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$TOTAL_CPU</span> <span class="o">-</span> <span class="m">10</span><span class="k">))</span>
        <span class="k">else
            </span><span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$TOTAL_CPU</span> <span class="o">-</span> <span class="m">2</span><span class="k">))</span> <span class="c">#没有app_router正常从倒数第2个逻辑核开始用</span>
        <span class="k">fi
    
        for </span>pid <span class="k">in</span> <span class="k">${</span><span class="nv">PIDS</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
            </span><span class="nb">sudo </span>taskset <span class="nt">-p</span> <span class="nt">--cpu-list</span> <span class="nv">$cpu</span> <span class="nv">$pid</span>
            <span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span><span class="nv">$cpu</span> <span class="o">-</span> <span class="m">2</span><span class="k">))</span>
        <span class="k">done
    elif</span> <span class="o">[[</span> <span class="nv">$cpu_thread_seq</span> <span class="o">=</span> <span class="s2">"na"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        for </span>pid <span class="k">in</span> <span class="k">${</span><span class="nv">PIDS</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
            </span><span class="nb">sudo </span>taskset <span class="nt">-p</span> 0xFFFF <span class="nv">$pid</span>
        <span class="k">done
    fi</span>

<span class="o">}</span>

CheckApprouterProcessRunningStaus <span class="o">&amp;&amp;</span>
    CheckDir <span class="o">&amp;&amp;</span>
    CheckHybridDeploy <span class="o">&amp;&amp;</span>
    Lock <span class="o">&amp;&amp;</span>
    Stop <span class="o">&amp;&amp;</span>
    Upgrade <span class="o">&amp;&amp;</span>
    Start <span class="o">&amp;&amp;</span>
    BindingProcesstoPhysicalCores <span class="o">&amp;&amp;</span>
    CheckProcessNumber
Unlock
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="后台" /><summary type="html"><![CDATA[一个 Prod 用的服务启动升级脚本，检查了 CPU 核心数，并按照指定顺序绑定 CPU 核心，以提升性能。]]></summary></entry><entry><title type="html">网络包序号回绕</title><link href="https://gbcpp.github.io/packet_number.html" rel="alternate" type="text/html" title="网络包序号回绕" /><published>2023-04-18T00:00:00+00:00</published><updated>2023-04-18T00:00:00+00:00</updated><id>https://gbcpp.github.io/packet_number</id><content type="html" xml:base="https://gbcpp.github.io/packet_number.html"><![CDATA[<blockquote>
  <p>Transform your plain text into static websites and blogs.</p>
</blockquote>

<h2 id="需求">需求</h2>

<p>在实现一套基于 UDP/DataChannel 自定义可靠传输算法时，自定义的协议头中肯定也是要用到 sequence Id 来标记包序号，用于重传，计算 RTT 等需求。</p>

<h2 id="方案">方案</h2>

<p>一般情况下我们都是使用 32字节的 UINT 记录 sequence id，通过不断的递增包序号总是会达到最大值 UINT_MAX，然后回绕到 0 的，此时需要判断新的 sequence id （比如 1， 2，3， xxx），是要 “大于” 旧的 sequence id （4294967293， 4294967294， 4294967295）的，如果直接通过关系运算符  &gt;  &lt; 等进行判断的话，就会得到错误的结果，回绕后的新包序号 sequence id 要排到旧的包序号 sequence id 之前了，针对此种情况，需要一种特殊的 “关系运算符” 比较，在此提供如下比较方法。</p>

<h3 id="方案一">方案一</h3>

<p>通过比较两个包序号之间差值与 kPacketNumberMask 与运算后的结果，与 UINT_MAX / 4 之间的关系来判断。</p>

<p>此种判断方法的前提是认定递增的包序号，在队列中不可能出现最新和最旧的包序号差值能够达到 (kPacketNumberMask » 1)，即 UINT_MAX / 4 如此之大的，否则说明包序号设计非常的不合理。</p>

<p>有了正确的判断包序号大小的方法，再配合 std::map 可自定义的 key_compare 便可实现对产生回绕的包序号自动排序能力，完整的 Example：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 定义 UINT_MAX 的一半</span>
<span class="c1">// BIN: 01111111111111111111111111111111; HEX:7FFFFFFF; DEC:2147483647</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">kPacketNumberMask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> 

<span class="c1">// 当用 UINT 的较小的数 减去 较大的数不够减时，得到的结果会产生回绕：</span>
<span class="c1">// 如：3 - UINT_MAX = 4， 4 用 二进制表示为：100b</span>
<span class="c1">// 用 kPacketNumberMask &amp; 100b = 100b， 100b 是小于 (kPacketNumberMask &gt;&gt; 1) 的，结果为 true；</span>


<span class="c1">// &gt;</span>
<span class="kt">bool</span> <span class="nf">greaterThan</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">kPacketNumberMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">kPacketNumberMask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// &lt;</span>
<span class="kt">bool</span> <span class="nf">lessThan</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">greaterThan</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// &lt;=</span>
<span class="kt">bool</span> <span class="nf">lessEqual</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">kPacketNumberMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">kPacketNumberMask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>Example:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">kPacketNumberMask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">greaterThan</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">kPacketNumberMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">kPacketNumberMask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">lessThan</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">greaterThan</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">lessEqual</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">kPacketNumberMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">kPacketNumberMask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">CompareUint</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">uint32_t</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// return !greaterThan(lhs, rhs);</span>
    <span class="k">return</span> <span class="n">lessEqual</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">CompareUint</span><span class="o">&gt;</span> <span class="n">pkt_map</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="n">UINT_MAX</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"UINT_MAX - 3"</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="n">UINT_MAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"UINT_MAX - 2"</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="n">UINT_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"UINT_MAX - 1"</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="n">UINT_MAX</span> <span class="o">-</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"UINT_MAX - 0"</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"1"</span><span class="p">;</span>
  <span class="n">pkt_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"2"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-------------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"UINT_MAX: "</span> <span class="o">&lt;&lt;</span> <span class="n">UINT_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">", +1 = "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">UINT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"3 - UINT_MAX = "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span><span class="n">UINT_MAX</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"0 - UINT_MAX = "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span><span class="n">UINT_MAX</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">itor</span> <span class="o">:</span> <span class="n">pkt_map</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"key: "</span> <span class="o">&lt;&lt;</span> <span class="n">itor</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", value: "</span> <span class="o">&lt;&lt;</span> <span class="n">itor</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>运行结果：</p>

    <blockquote>
      <p>编译：g++  main.cpp -std=c++17  -o main.exe</p>
    </blockquote>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-------------------------------------------------</span>
UINT_MAX: 4294967295, +1 <span class="o">=</span> 0
3 - UINT_MAX <span class="o">=</span> 4
0 - UINT_MAX <span class="o">=</span> 1
key: 4294967292, value: UINT_MAX - 3
key: 4294967293, value: UINT_MAX - 2
key: 4294967294, value: UINT_MAX - 1
key: 4294967295, value: UINT_MAX - 0
key: 1, value: 1
key: 2, value: 2
</code></pre></div></div>

<h3 id="方案二">方案二</h3>
<p>内核中使用的方法：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">before</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">seq1</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">seq2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">seq1</span><span class="o">-</span><span class="n">seq2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define after(seq2, seq1)   before(seq1, seq2)
</span></code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="协议" /><summary type="html"><![CDATA[Transform your plain text into static websites and blogs.]]></summary></entry><entry><title type="html">H2O-ac theme for Jekyll</title><link href="https://gbcpp.github.io/tech/new-theme-h2o-ac.html" rel="alternate" type="text/html" title="H2O-ac theme for Jekyll" /><published>2021-12-22T11:50:00+00:00</published><updated>2021-12-22T11:50:00+00:00</updated><id>https://gbcpp.github.io/tech/new-theme-h2o-ac</id><content type="html" xml:base="https://gbcpp.github.io/tech/new-theme-h2o-ac.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  正如大家所知，Jekyll 是一款高可定制的、非常流行的静态博客生成工具。围绕着 Jekyll 也衍生出了很多优秀的 Jekyll 主题， 由 <a href="https://github.com/kaeyleo">廖柯宇</a> 开发的 <a href="https://github.com/kaeyleo/jekyll-theme-H2O">H2O</a> 主题就是其中之一。极简主义、风格扁平化、卡片式布局、Medium 及知乎专栏的视觉风格等等特点，为我们带来了或许是迄今为止最漂亮的 Jekyll 主题。</p>

<p>  诞生之初，H2O 主题就在 Github 平台上以 MIT 许可证协议开放了源代码。这吸引了很多小伙伴纷纷转投 Jekyll 和 H2O 主题的阵营，本人也是其中之一。随着使用者越来越多，不少的小伙伴在使用过程中发现了一些小问题并主动修复，最后贡献到了 H2O 的主项目，这让 H2O 主题变得更好。本人在使用过程中也的确是发现了一些与自己实际需求不大一致的地方，并且在原 H2O 主题的基础上做了一些改动。考虑到这些改动可能并不是大多数人的需求，直接向原 H2O 主题提交 pull 请求合并的必要性不大，因此决定将原项目 fork 并改名为 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">zhonger/jekyll-theme-H2O-ac</a>。现正式将源代码以与 H2O 主题相同的 MIT 许可证协议在 Github 平台上公开。</p>

<p>  在此，非常感谢廖柯宇及其他小伙伴对于 H2O-ac 主题的基础主题 H2O 的代码开发和开放共享。</p>

<h2 id="新特性">新特性</h2>

<h3 id="更适合学术人和运维程序员的页面结构">更适合学术人和运维程序员的页面结构</h3>

<p>  H2O 主题其实在很大程度上已经满足了大部分人的需求，只是对于学术研究人员和运维程序员来说，个人觉得页面结构还是有点不够合适。学术研究人员比较重视在首页直接展示个人信息和研究情况，能够让人很快地了解到所需的信息，这其实是将 About me 这样一个平常的辅助页面当成了主页面来用。另外，运维程序员比较重视能一览所有文章的标题以迅速找到感兴趣的文章。虽然搜索功能、标签页、卡片展示页都能够列出所有的文章，但个人觉得还是不够简洁、方便。而像 Hexo 静态生成工具自带的 Archive 归档页面比较能满足这样的需求。除此之外，整个博客的系统日志变迁记录对于运维程序员来说也非常重要，毕竟如果通过发布一篇文章来描述变迁过程并不适合联系起来完整了解。如果有系统日志页，就可以按照年份、月份、事件的先后进行简要的描述，并且一览无遗。</p>

<p>  因此，在 H2O-ac 主题中，从原来 H2O 的主页中抽出框架做成了页面模板。根据实际页面的内容需求，增加了<strong>学术首页</strong>、<strong>归档页</strong>和<strong>系统日志页</strong>。</p>

<h4 id="学术首页">学术首页</h4>

<p>  学术首页如下图所示，并将原来 H2O 中的卡片首页移动到 blog 子目录下了。如果读者想要看到文章卡片展示页，还是可以点击顶部的导航栏中的 BLOG 直接访问。</p>

<p><img src="https://i.lisz.top/blog/XyT038.webp" alt="首页 Home" /></p>

<h4 id="归档页">归档页</h4>

<p>  归档页设置为由 Jekyll 按照模板自动生成，以年份、日期、文章标题分级列表展示，简洁清晰。</p>

<p><img src="https://i.lisz.top/blog/lj4vUP.webp" alt="归档页 Archives" /></p>

<h4 id="系统日志页">系统日志页</h4>

<p>  系统日志页其实也不是经常更新的，只有在博客整体作出设置或改进的才加以说明。另外，也可以将一些固定的站点信息放置在系统日志页，比如站点的多点部署信息，读者可以根据此信息访问最快、最合适的节点。</p>

<p><img src="https://i.lisz.top/blog/7QLEc6.webp" alt="系统日志 Log" /></p>

<h3 id="使用体验提升">使用体验提升</h3>

<p>  廖柯宇也在 H2O 主题的默认页面中写道，目前 H2O 主题还有一些可优化的内容，比如夜间模式、查看大图等。这里，根据个人的一些实际需求和了解，在 H2O-ac 主题中做了调整。</p>

<h4 id="社交图标扩展">社交图标扩展</h4>

<p>  H2O 原有的社交图标其实已经比较广泛，只是还有些领域局限性，比如学术研究人员可能更希望展示谷歌学术、ResearchGate、ORCID 等社交图标及链接，而运维开发人员可能更希望展示 SegmentFault、CSDN、博客园等社交图标及链接。这里在 H2O 提供的社交图标类型基础上做了这些平台图标的扩充，同时尝试了 Symbol 引用的方式来实现社交图标鼠标悬停的效果，从而简化代码（H2O 采用的是字体图标的方式，需要为每一个社交图标定义不同的主题色）。</p>

<p><img src="https://i.lisz.top/blog/UpnQdk.webp" alt="社交图标 SNS" /></p>

<h4 id="查看大图">查看大图</h4>

<p>  查看大图功能的确对于读者的阅读体验来说有很大的提升。就像我们阅读文献一样，可能首先会只看文章附图来大致掌握文章的核心点。博文的查看大图功能也可能有这样的异曲同工之妙。这里是采用的 <a href="https://fancyapps.com/docs/ui/fancybox">Fancybox</a> 插件实现的。H2O-ac 主题中只使用了最简单的配置，用户可以根据需求查看文档做出更多的修改。</p>

<p><img src="https://i.lisz.top/blog/BzfBoz.webp" alt="查看大图 Fancybox" /></p>

<p>(2022年4月30日更新)</p>

<p>  ，由于 fancybox 库作者对原使用的 v3.5.7 版本不再进行维护和更新，现将版本更新至新的 v4.0 版本，即 <a href="https://github.com/fancyapps/ui">fancyapps/ui</a>。另，新增将 alt 内容作为图片的描述显示在 fancybox 中。</p>

<h4 id="深色模式切换按钮">深色模式切换按钮</h4>

<p>(2022年4月30日更新)</p>

<p>  原来 H2O 主题的深色模式切换需要在 _config.yml 文件中配置开启，并且只能在固定时间段使用。此次更新在页面右上角提供了深色/浅色模式一键切换按钮，如下图所示。由于更新了深色模式采用 cookie 的方式来确定，此深色模式切换按钮可以与原来的深色模式配置共存。</p>

<p><img src="https://i.lisz.top/blog/EPhFN9.webp" alt="浅色模式 Day mode" /></p>

<p><img src="https://i.lisz.top/blog/BD7BqC.webp" alt="深色模式 Night mode" /></p>

<h4 id="提示框">提示框</h4>

<p>(2022年4月30日更新)</p>

<p>  通过引入 <a href="https://github.com/lazee/premonition">lazee/premonition</a> 库新增五种提示框：笔记、提示、警告、错误、引用，完全兼容原生 Markdown 语法，并对样式进行了主题适应。以下为五种提示框的实际效果。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Note </div> </div> <div class="content"> <p>The body of the note goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>The body of the info goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> Warning </div> </div> <div class="content"> <p>The body of the warning goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition error"> <div class="header"> <svg class="icon error" aria-hidden="true"> <use xlink:href="#icon-error"></use> </svg> <div class="title"> Error </div> </div> <div class="content"> <p>The body of the error goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>To be or not to be is a question.</p>



 </div> <div class="ref"> ------ 莎士比亚 </div> </div>
<h4 id="代码高亮优化">代码高亮优化</h4>

<p>  本人使用 H2O 主题的时候代码高亮功能还是沿用的 Jekyll 自带的，后来 H2O 主题也开始采用了 <a href="https://prismjs.com/">Prism.js</a>。不过由于使用的是 <code class="language-plaintext highlighter-rouge">OKAIDIA</code> 高亮主题，所以有些段落中的格式化字段显示上有些问题。这里，仍然采用默认主题，并且扩增到 Prism.js 支持的所有编程语言类型。效果可以从前一句的 OKAIDIA 字段和下面即将出现的代码片段看出。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@font-face</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="s2">'Merriweather'</span><span class="p">;</span>
  <span class="nl">src</span><span class="p">:</span> <span class="n">local</span><span class="p">(</span><span class="s2">'Merriweather'</span><span class="p">),</span> <span class="sx">url(https://fonts.gstatic.com/...)</span> <span class="n">format</span><span class="p">(</span><span class="s2">'woff2'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(2022年5月14日更新)</p>

<p>  更换 Prism 库加载方式，采用按需自动加载代码类型，尽可能减少因 Prism 造成的阻塞。修复了某些样式问题。增加显示行数支持、官方主题选择支持。如下所示可以进行设置，具体主题风格样式可以访问 <a href="https://prismjs.com/">Prism 官网</a> 了解更多。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Prism</span>
<span class="na">prism</span><span class="pi">:</span>
  <span class="na">theme</span><span class="pi">:</span> <span class="s">tomorrow</span>
  <span class="na">line_numbers</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<h4 id="代码复制">代码复制</h4>

<p>(2022年5月1日更新)</p>

<p>  由于主题设置有复制自动添加版权保护文字，导致复制代码或无法直接使用。但是如果直接去掉版权保护又不大合适，于是新增代码复制功能。当使用如下所示代码片段右上角的复制按钮时，代码会被复制到粘贴板，且不包含版权保护文字，可以放心直接使用。</p>

<p>(2022年5月14日更新)</p>

<p>  调整复制按钮位置，自动识别代码块的代码类型并显示。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- Target --&gt;</span>
<span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"foo"</span> <span class="na">value=</span><span class="s">"https://github.com/zenorocha/clipboard.js.git"</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- Trigger --&gt;</span>
<span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"btn"</span> <span class="na">data-clipboard-target=</span><span class="s">"#foo"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"assets/clippy.svg"</span> <span class="na">alt=</span><span class="s">"Copy to clipboard"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<h4 id="字数统计及阅读时间估计">字数统计及阅读时间估计</h4>

<p>  字数统计及阅读时间估计这个小功能其实以前在用 WordPress 的时候比较常见。虽然说统计和估计的结果不一定完全准确，但是还是起到了一定的辅助阅读的作用。效果可以查看本页标题下的基本信息区域。</p>

<h4 id="时间本地化与最近更新时间">时间本地化与最近更新时间</h4>

<p>(2022年5月22日更新)</p>

<p>  为了支持来自不同时区的读者直接可以看到文章发布对应的本地时间，现已利用 dayjs 新增<strong>时间本地化</strong>功能。并利用 Github API 查询页面的最近一次 commit 更新时间作为文章<strong>最近更新时间</strong>。效果如下图所示。</p>

<p><img src="https://i.lisz.top/blog/Anb4xH.webp" alt="构建位置时区 Jekyll deployment timezone" />
<img src="https://i.lisz.top/blog/NMPXmQ.webp" alt="读者时区 Reader timezone" /></p>

<p>  如需使用<strong>最近更新时间</strong>功能，务必在 _config.yml 文件中添加以下配置项：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Github</span>
<span class="na">github</span><span class="pi">:</span>
  <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">owner</span><span class="pi">:</span> <span class="s">github_username</span>
  <span class="na">repository</span><span class="pi">:</span> <span class="s">github_project_name</span>
</code></pre></div></div>

<p>  如未正确进行以上配置，默认会将最近更新时间与发布时间保持一致。</p>

<h4 id="版权显式声明">版权显式声明</h4>

<p>(2022年5月18日更新)</p>

<p>  之前的版本只会在页面底部的信息栏中显示一个 CC 4.0 的小图标，不是很醒目。根据调研其他静态网站主题，发现一般都会在文章的末尾自动生成一个比较醒目的版权声明。另外，在版权声明中也将根据最近更新时间来判断内容是否可能过时。如果最近更新时间距离当前时间大于 365 天，则会显示具体日期并提醒有内容过时的可能。效果如下所示。</p>

<p><img src="https://i.lisz.top/blog/scNRyd.webp" alt="版权显式声明 Copyright" />
<img src="https://i.lisz.top/blog/C8RWtL.webp" alt="内容可能过时提醒 Long time ago notification" /></p>

<h4 id="文章侧边索引导航">文章侧边索引导航</h4>

<p>(2022年1月9日更新)</p>

<p>  在一些基于 Bootstrap 前端框架的 Jekyll 主题中，这个功能比较常见。由于本主题未使用 Bootstrap 前端框架，所以添加起来稍微有些麻烦，现已增加此功能。在浏览器窗口超过 1050 px 的情况下，在文章页面可以正常看到右侧的文章侧边索引导航。当窗口滑动时，侧边索引导航也会跟着滑动。在浏览器窗口不足 1050 px 的情况下，侧边索引导航自动隐藏。在 _config.yml 配置文件中，可以通过设置 <code class="language-plaintext highlighter-rouge">toc: false</code> 来全局禁用此功能。</p>

<p>(2022年4月30日更新)</p>

<p>  在原来的基础上增加了跟随左侧内容滑动高亮。当左侧内容向上或向下滑动时，右侧索引导航将会使对应的对应一级标题高亮。</p>

<p>(2022年5月14日更新)</p>

<p>  为文章的移动端页面添加了索引导航按钮。鉴于单页面的内容有限及侧边位置空间有限，暂未对单页面进行支持。</p>

<h4 id="支持-waline-评论系统">支持 Waline 评论系统</h4>

<p>  目前已支持基于 Valine 衍生的简洁、安全的评论系统。可以根据官方提供的 <a href="https://waline.js.org/guide/get-started.html">快速上手</a> 进行配置，以下为 _config.yml 中需要配置的内容：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># _config.yml</span>

<span class="na">comments</span><span class="pi">:</span>
  <span class="na">waline</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">waline_url</span><span class="pi">:</span> <span class="s">https://xxxxxx.vercel.app</span>
</code></pre></div></div>

<p>  <del>目前未对多评论系统同时支持进行优化，所以如果 Disqus 和 Waline 同时开启时，Disqus 在前 Waline 在后同时出现。如果用户环境无法访问 Disqus 即只能看到 Waline。</del></p>

<p>(2022年5月22日更新)</p>

<p>  新增多评论切换按钮：当同时使用 Disqus 和 Waline 时，会在评论区域的右上角看到一个左右滑动切换按钮。如下所示，从左往右滑动即可从 Disqus 切换到 Waline。</p>

<p>  同时修复了手动切换深色模式时 Disqus 不会自动切换模式而造成的显示问题。目前在模式切换时 Disqus 会主动进行重新加载以适应当前模式。</p>

<p><img src="https://i.lisz.top/blog/WBgbUB.webp" alt="Disqus 评论系统 Disqus comment" />
<img src="https://i.lisz.top/blog/45JQ9H.webp" alt="Waline 评论系统 Waline comments" /></p>

<h4 id="支持-pwa">支持 PWA</h4>

<p>(2022年5月11日更新)</p>

<p>  全面支持 PWA，访问速度得到较大提升。移动端访问可以像原生 APP 那样使用。如果访问过全站一遍之后，则可以完全离线使用。如下所示，可以配置 PWA 的主题色和短名称。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PWA</span>
<span class="na">pwa</span><span class="pi">:</span>
  <span class="na">color</span><span class="pi">:</span> <span class="s1">'</span><span class="s">#81BBFF'</span>
  <span class="na">short_name</span><span class="pi">:</span> <span class="s1">'</span><span class="s">lisz'</span>
</code></pre></div></div>

<h4 id="配置项">配置项</h4>

<p>  配置项中新增了<strong>友情链接</strong>和<strong>备案号</strong>功能，可以直接在 _config.yml 文件的对应配置项下设置即可，如下所示。友情链接主要是方便跟其他博主交换友链，备案号主要是为了方便部署在国内需备案的 vps 或虚拟主机上。此处，二者都可以置空。</p>

<p>(2022年4月30日更新)</p>

<p>  新增<strong>全站一键灰度化功能</strong>、<strong>时间格式</strong>配置。在国家公祭日等需要灰度化以示哀悼的时候可以将灰度化配置设置为 true，平常使用默认配置 false。时间格式这里一共提供了 3 种：第一种中英文站点使用皆宜，第二种适用于英文站点，第三种适用于中文站点。默认时间格式为第一种。</p>

<p>(2022年5月14日更新)</p>

<p>  新增 <a href="https://busuanzi.ibruce.info/"><strong>不蒜子</strong></a> 统计方式，可以显示全站访问次数、全站访问用户数、文章页面阅读量。如下设置可以开启。</p>

<p>(2022年5月16日更新)</p>

<p>  新增 <a href="https://github.com/mikecao/umami"><strong>umami</strong></a> 统计方式，需要自行先搭建 umami 然后接入。接入配置只需要如下所示配置跟踪 id 和 JS 脚本地址。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Links 友情链接</span>
<span class="na">links</span><span class="pi">:</span>
  <span class="s1">'</span><span class="s">Mr</span><span class="nv"> </span><span class="s">Li'</span><span class="err">:</span> <span class="s1">'</span><span class="s">https://lisz.me'</span>

<span class="c1"># Beian 备案号</span>
<span class="na">beian</span><span class="pi">:</span> <span class="s1">'</span><span class="s">沪ICP备xxxxxxxx号'</span>

<span class="c1"># Gray 灰度化</span>
<span class="na">gray</span><span class="pi">:</span> <span class="kc">true</span>

<span class="c1"># Time format 时间格式 </span>
<span class="c1"># 0 -- 2022-04-29    1 -- 29 Apr 2022   2 -- 2022年4月29日</span>
<span class="na">formats</span><span class="pi">:</span>
  <span class="na">time</span><span class="pi">:</span> <span class="s">0</span> 

<span class="c1"># Busuanzi Analytics</span>
<span class="na">busuanzi</span><span class="pi">:</span> <span class="kc">true</span>

<span class="c1"># Umami Analytics</span>
<span class="na">umami</span><span class="pi">:</span>
  <span class="na">status</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">id</span><span class="pi">:</span> <span class="s">xxxxxxxxxxxxx</span>
  <span class="na">js</span><span class="pi">:</span> <span class="s">https://umami.example.com/umami.js</span>
</code></pre></div></div>

<h4 id="前端自动构建工作流优化">前端自动构建工作流优化</h4>

<p>  H2O 主题中使用了 Gulp + <del>Node-Sass</del> Sass 的方案来自动化前端构建工作流。不得不说，这个方案还是很不错的，只是随着 Gulp 和 <del>Node-Sass</del> Sass 版本的更新，对 NodeJS 环境及其他依赖库都有一些要求。这里，H2O-ac 主题在 package.json 文件中将所有库都更新到目前最新，对应版本列表如下所示。另外，为了减少一些第三方 CSS 样式的请求数，利用自动构建工作流将固定的第三方 CSS 样式文件合并并压缩为 plugins.min.css 文件。app.min.css 仍为多个自编写 CSS 样式文件的合并压缩。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">运行环境或依赖库</th>
      <th style="text-align: center">版本号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">NodeJS</td>
      <td style="text-align: center">v17.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp</td>
      <td style="text-align: center">v4.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-clean-css</td>
      <td style="text-align: center">v4.3.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-rename</td>
      <td style="text-align: center">v20.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-sass</td>
      <td style="text-align: center">v5.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-uglify</td>
      <td style="text-align: center">v3.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-concat</td>
      <td style="text-align: center">v2.6.1</td>
    </tr>
    <tr>
      <td style="text-align: center"><del>node-sass</del></td>
      <td style="text-align: center"><del>v7.0.0</del></td>
    </tr>
    <tr>
      <td style="text-align: center">sass</td>
      <td style="text-align: center">v1.51.0</td>
    </tr>
  </tbody>
</table>

<h2 id="使用方法">使用方法</h2>

<h3 id="初始化">初始化</h3>

<h4 id="方式一从模板新建博客">方式一：从模板新建博客</h4>

<p>  为了方便用户使用 H2O-ac 主题，特别提供了 Github 的模板功能。如下图所示，访问 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">H2O-ac</a> 可以看到如下的 Use this template 按钮，点击该按钮即可用 H2O-ac 主题创建自己的博客代码仓库。想要了解更多步骤，可以访问 Github 官方文档之 <a href="https://docs.github.com/cn/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template">从模板创建仓库</a>。</p>

<p><img src="https://i.lisz.top/blog/oHHZZh.webp" alt="从模板新建 Start the blog from the template" /></p>

<h4 id="方式二已有博客迁移">方式二：已有博客迁移</h4>

<p>  <del>暂时无法支持 gem 直接切换主题，后续将更新此方式。目前只能使用方式一创建仓库后，将文章的 markdown 文件复制到 _posts 目录下应用 H2O-ac 主题。</del></p>

<p>(2021年12月26日更新)</p>

<p>  现已支持使用 gem 直接切换主题 <code class="language-plaintext highlighter-rouge">jekyll-theme-h2o-ac</code>。同时，也推出了一键式构建工具 <a href="https://github.com/zhonger/easy-to-h2o-ac">easy-to-h2o-ac</a>，详细可以见项目主页。</p>

<h3 id="本地测试">本地测试</h3>

<p>  在进行本地测试时，如果需要修改一些样式，则需要先执行 <code class="language-plaintext highlighter-rouge">npm install</code> 来完成前端自动构建工作流依赖库的安装。注意，这里设定的可用 NodeJS 版本为 v17.0.0，使用老版本会报错。其次，务必使用 <code class="language-plaintext highlighter-rouge">bundle install</code> 安装主题所需的所有 Ruby 依赖库。最后执行 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve --livereload</code> 命令即可在本地实时同步预览。只要不修改 _config.yml 文件，不必中断后再启动。然后就是在 <code class="language-plaintext highlighter-rouge">_posts</code> 目录下写 markdown 文章即可。</p>

<h3 id="发布部署">发布部署</h3>

<p>  由于 Github 提供 Jekyll 静态生成器的静态页面托管，只要打开仓库的 Pages 功能，当推送更新到 Github 时即会自动部署。此处值得注意的是，如果代码仓库的名字不是 <code class="language-plaintext highlighter-rouge">username.github.io</code>，而也没有为该仓库的 Pages 提供自定义域名，那么这个仓库将会被部署到子目录，因此此时必须在 _config.yml 文件中设置 base_url，从而生成正常的静态页面。</p>

<h2 id="结束语">结束语</h2>

<p>  再次感谢廖柯宇及其他小伙伴们对 H2O 主题的付出，没有 H2O 主题就没有 H2O-ac 主题！H2O-ac 主题后续也将继续更新，欢迎小伙伴们使用和 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">Star</a>，也欢迎大家一起来贡献代码。</p>

<p>（Ps: <del>由于沿用了 H2O 的 Logo，可能会侵犯廖柯宇的版权。如果的确如此，后续将会设计一个新的 Logo。</del> 已采用新 Logo。）
（2022年1月10日更新）</p>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="jekyll" /><category term="theme" /><category term="blog" /><category term="ac" /><category term="develop" /><category term="主题" /><category term="前端开发" /><category term="学术" /><category term="运维" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">经典算法题</title><link href="https://gbcpp.github.io/algorithm.html" rel="alternate" type="text/html" title="经典算法题" /><published>2019-06-11T00:00:00+00:00</published><updated>2019-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/algorithm</id><content type="html" xml:base="https://gbcpp.github.io/algorithm.html"><![CDATA[<h2 id="二叉树遍历">二叉树遍历</h2>

<ul>
  <li>
    <p>前序遍历
  根结点 —&gt; 左子树 —&gt; 右子树</p>
  </li>
  <li>
    <p>中序遍历
  左子树—&gt; 根结点 —&gt; 右子树</p>
  </li>
  <li>
    <p>后序遍历
  左子树 —&gt; 右子树 —&gt; 根结点</p>
  </li>
  <li>
    <p>层次遍历
  只需按层次遍历即可</p>
  </li>
</ul>

<!--more-->

<p>二叉树数据结构：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">TreeNode</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="前序遍历">前序遍历</h3>

<ul>
  <li>递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">PreTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="n">PreOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">PreOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>非递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">PreTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack_list</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack_list</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">stack_list</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp_root</span><span class="p">);</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack_list</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="中序遍历">中序遍历</h3>

<ul>
  <li>递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MiddleTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">MiddleOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="n">MiddleOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>非递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MiddleTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack_list</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack_list</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp_root</span><span class="p">);</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">stack_list</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="后序遍历">后序遍历</h3>

<ul>
  <li>递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MiddleTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">MiddleOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">MiddleOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>非递归遍历</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MiddleTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack_list</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack_list</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp_root</span><span class="p">);</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">stack_list</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">tmp_root</span> <span class="o">=</span> <span class="n">tmp_root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="广度优先层次遍历">广度优先/层次遍历</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ret_vec</span><span class="p">;</span>
        
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack_node</span><span class="p">;</span>
        <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stack_node</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stack_node</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp_vec</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack_node</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">stack_node</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="n">tmp_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="p">}</span>                  
            <span class="p">}</span>   
            <span class="n">ret_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp_vec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret_vec</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="深度优先遍历">深度优先遍历</h2>

<p>递归遍历</p>

<h2 id="求二叉树最大宽度">求二叉树最大宽度</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">widthOfBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack_node</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="kt">int</span> <span class="nf">max_width</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pNode</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pNode</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stack_node</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_width</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_width</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack_node</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">stack_node</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
                    <span class="n">stack_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">max_width</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="判断二叉树是否对称">判断二叉树是否对称</h2>

<ul>
  <li>递归判断</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">IsMirror</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span> <span class="o">||</span> <span class="o">!</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> 
                <span class="o">&amp;&amp;</span> <span class="n">IsMirror</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> 
                <span class="o">&amp;&amp;</span> <span class="n">IsMirror</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span> 
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsMirror</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">IsMirror</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>非递归/迭代法判断</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">IsMirror</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">queue_node</span><span class="p">;</span>
    <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">queue_node</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">queue_node</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">queue_node</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t1</span> <span class="o">||</span> <span class="o">!</span><span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
        <span class="n">queue_node</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="大数相乘">大数相乘</h2>

<p>是指那些相乘结果或是乘数本身用long long类型都会溢出的数字，通常这些数字都通过string类型进行表示，借助于可动态调整大小的数据结构（vector,string,deque）模拟实现数字的乘法操作。对于普通的乘法，我们知道m位数和n位数相乘，最后的结果位数在区间内[m+n-1,m+n]。例如34*56，我们通常这么计算： 
将3，4分别于6相乘，记录低位的进位，然后将3，4对5进行相同的操作，知道第二个乘数的最高位乘完，算法结束。 
所以我们可以保存每个位数的相乘结果，最后统一进位转换。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">BigNumMultiply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//记录最终结果</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="c1">//使用deque是因为出现进位时可以在队列前插入数据，效率比vector高，大小设为最小</span>
    <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span><span class="c1">//记录相乘结果</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 进位处理</span>
    <span class="kt">int</span> <span class="n">addflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 倒序遍历，是因为最左边的值为最高位，最右边的值在最低位，进位运算要从低位开始</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">addflag</span><span class="p">;</span><span class="c1">//当前值加上进位值</span>
        <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//当前值</span>
        <span class="n">addflag</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//进位值</span>
    <span class="p">}</span>
    <span class="c1">//如果有进位，将进位加到队列头部</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">addflag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">addflag</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">addflag</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 转换为字符串</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="反转链表">反转链表</h2>

<p>反转一个单链表。</p>

<p>解决方案</p>
<h3 id="迭代">迭代</h3>

<blockquote>
  <p>假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。</p>
</blockquote>

<p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">ReverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span> <span class="o">||</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>复杂度分析</p>

<ul>
  <li>
    <p>时间复杂度：O(n)O(n) 。 假设 nn 是列表的长度，时间复杂度是 O(n)O(n)。</p>
  </li>
  <li>
    <p>空间复杂度：O(1)O(1) 。</p>
  </li>
</ul>

<h3 id="递归">递归</h3>

<p>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n1 → … → nk-1 → nk → nk+1 → … → nm → Ø</p>

<p>若从节点 nk+1 到 nm 已经被反转，而我们正处于 nk。</p>

<blockquote>
  <p>n1 → … → nk-1 → nk → nk+1 ← … ← nm</p>
</blockquote>

<p>我们希望 nk+1 的下一个节点指向 nk。</p>

<p>所以，</p>

<blockquote>
  <p>nk.next.next = nk;</p>
</blockquote>

<p>要小心的是 n1 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">ReverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span> <span class="o">||</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp_node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>复杂度分析</p>

<ul>
  <li>
    <p>时间复杂度：O(n)O(n) 。 假设 nn 是列表的长度，那么时间复杂度为 O(n)O(n)。</p>
  </li>
  <li>
    <p>空间复杂度：O(n)O(n) 。 由于使用递归，将会使用隐式栈空间。递归深度可能会达到 nn 层。</p>
  </li>
</ul>

<h2 id="二叉树转换为双向链表">二叉树转换为双向链表</h2>

<p>题目：输入一棵二叉搜索树（二叉查找树），将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>

<p>思路： 这道题目关键在于不能创建新的节点，如不然，我们可以直接将二叉排序树中序遍历保存到一个数组中，而后再建立一个双性链表，将数据保存到双向链表里。
    这里不能创建新节点，我们只能改变节点的指向左右子树的节点，让其变为指向二叉链表中的前后节点，很明显这里同样用的是中序遍历，因此这道题目依然是中序遍历的变种，中序递归构造实现即可，每次递归都保存一个指向已构造好的双向链表的尾节点的指针，将其与下一个节点连接起来。</p>

<p>代码实现（递归）：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span> 
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">BSTNode</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">BSTNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">BSTNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span><span class="n">BSTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BSTree</span><span class="p">;</span>
 
<span class="cm">/*
根据题目要求的格式创建二叉排序树
*/</span>
<span class="kt">void</span> <span class="nf">CreateBST</span><span class="p">(</span><span class="n">BSTree</span> <span class="o">*</span><span class="n">pRoot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pRoot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="o">*</span><span class="n">pRoot</span> <span class="o">=</span> <span class="p">(</span><span class="n">BSTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BSTNode</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pRoot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pRoot</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pRoot</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pRoot</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">CreateBST</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">pRoot</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">));</span>
		<span class="n">CreateBST</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">pRoot</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
 
<span class="cm">/*
采用中序遍历的方式将二叉树转化为双向链表，
*pLas指向双向链表的最后一个节点
*/</span>
<span class="kt">void</span> <span class="nf">ConvertNode</span><span class="p">(</span><span class="n">BSTree</span> <span class="n">pRoot</span><span class="p">,</span><span class="n">BSTree</span> <span class="o">*</span><span class="n">pLast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pRoot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="c1">//先转化左子树</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ConvertNode</span><span class="p">(</span><span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="n">pLast</span><span class="p">);</span>
 
	<span class="c1">//将双向链表的最后一个节点与根节点连接在一起</span>
	<span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="o">*</span><span class="n">pLast</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pLast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pLast</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">pRoot</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pLast</span> <span class="o">=</span> <span class="n">pRoot</span><span class="p">;</span>
 
	<span class="c1">//转换右子树</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ConvertNode</span><span class="p">(</span><span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="n">pLast</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="cm">/*
返回双向链表的头结点
*/</span>
<span class="n">BSTree</span> <span class="nf">Convert</span><span class="p">(</span><span class="n">BSTree</span> <span class="n">pRoot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pRoot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pRoot</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pRoot</span><span class="p">;</span>
 
	<span class="n">BSTree</span> <span class="n">pLast</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ConvertNode</span><span class="p">(</span><span class="n">pRoot</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pLast</span><span class="p">);</span>
	
	<span class="c1">//依次从 last 返回 first 头结点</span>
	<span class="n">BSTree</span> <span class="n">pHead</span> <span class="o">=</span> <span class="n">pLast</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">pHead</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pHead</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
 
	<span class="k">return</span> <span class="n">pHead</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BSTree</span> <span class="n">pRoot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">CreateBST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pRoot</span><span class="p">);</span>
			<span class="n">BSTree</span> <span class="n">pHead</span> <span class="o">=</span> <span class="n">Convert</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="n">pHead</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">pHead</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">pHead</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
			<span class="p">}</span>
 
			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="n">free</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
			<span class="n">pRoot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="反序链表求和">反序链表求和</h2>

<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8</p>

<p>思路：
首先要理解题目，输入的两个链表都是反序存储的。也就是链表首位代表数字的个位，第二位代表数字百位。接下来就和一般求和的题目一样了，维护当前求和结果和进位即可。注意最后要判断，是否还有进位，如果有，还需要再生成一位。</p>

<p>代码实现：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">vul</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">vul</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 注意返回值需要手动释放</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="nf">AddTwoListNumbers</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">list1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">list2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">list1</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">list2</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">dest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp_dest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 记录进位</span>
    <span class="k">while</span><span class="p">(</span><span class="n">l1</span> <span class="o">||</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tmp_dest</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">tmp_dest</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">tmp_dest</span> <span class="o">=</span> <span class="n">tmp_dest</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp_dest</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">carry</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>时间复杂度：O(n)</p>

<h2 id="查找字符串中字典序最大的序列">查找字符串中字典序最大的序列</h2>

<p>题目描述：给一个字符串，得到它字典序最大的子序列，即：删除一些字符，使得剩下的字符构成的字符串字典序是最大的</p>

<p>代码实现：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">GetMaxString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">src_str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">src_str</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">dest</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dest_str</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src_str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">dest</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">src_str</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">src_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">top</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">dest</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">dest</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">src_str</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">dest_str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dest_str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dest</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">dest</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dest_str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="算法" /><category term="c++" /><summary type="html"><![CDATA[二叉树遍历]]></summary></entry><entry><title type="html">C++算法大全</title><link href="https://gbcpp.github.io/c-algorithm-notes.html" rel="alternate" type="text/html" title="C++算法大全" /><published>2019-05-28T00:00:00+00:00</published><updated>2019-05-28T00:00:00+00:00</updated><id>https://gbcpp.github.io/c-algorithm-notes</id><content type="html" xml:base="https://gbcpp.github.io/c-algorithm-notes.html"><![CDATA[<blockquote>
  <p>以内内容为互联网收集，非原创。</p>
</blockquote>

<h2 id="算法分类">算法分类</h2>

<p>常见的排序算法分为两类：</p>

<ul>
  <li>
    <p><strong>比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p>
  </li>
  <li>
    <p><strong>非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>
  </li>
</ul>

<!--more-->

<p><img src="/assets/img/old_blog/algorithm/算法分类.png" alt="算法分类" /></p>

<h2 id="算法复杂度">算法复杂度</h2>

<p><img src="/assets/img/old_blog/algorithm/算法复杂度.png" alt="算法复杂度" /></p>

<ul>
  <li><strong>时间复杂度：</strong>对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
  <li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ul>

<h2 id="经典排序">经典排序</h2>

<h3 id="冒泡排序">冒泡排序</h3>

<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>

<h4 id="算法描述">算法描述</h4>
<ul>
  <li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
  <li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
  <li>针对所有的元素重复以上的步骤，除了最后一个；</li>
  <li>重复步骤1~3，直到排序完成。</li>
</ul>

<h4 id="动图演示">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/冒泡排序.gif" alt="插入排序" /></p>

<h4 id="代码实现">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">src</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="选择排序selection-sort">选择排序（Selection Sort）</h3>

<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>

<h4 id="算法描述-1">算法描述</h4>

<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>

<ul>
  <li>初始状态：无序区为R[1..n]，有序区为空；</li>
  <li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分- 别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
  <li>n-1趟结束，数组有序化了。</li>
</ul>

<h4 id="动图演示-1">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/选择排序.gif" alt="插入排序" /></p>

<h4 id="代码实现-1">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">min_num</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">min_value</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">min_num</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_num</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">min_num</span><span class="p">];</span>
            <span class="n">src</span><span class="p">[</span><span class="n">min_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="插入排序">插入排序</h3>

<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>

<h4 id="算法描述-2">算法描述</h4>

<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>

<ul>
  <li>从第一个元素开始，该元素可以认为已经被排序；</li>
  <li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
  <li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
  <li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
  <li>将新元素插入到该位置后；</li>
  <li>重复步骤2~5。</li>
</ul>

<h4 id="动图演示-2">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/插入排序.gif" alt="插入排序" /></p>

<h4 id="代码实现-2">代码实现</h4>

<pre><code class="language-C">void InsertSort(int *src, int count)
{
    if(!src || count &lt;= 1) {
        return;
    }
    int pre_index(0), cur_value(0);
    for (int i(1); i &lt; count; ++i) {
        pre_index = i - 1;
        cur_value = src[i];
        while (pre_index &gt;= 0 &amp;&amp; src[pre_index] &gt; cur_value) {
            src[pre_index + 1] = src[pre_index];
            --pre_index;
        }
        src[pre_index + 1] = cur_value;
    }
}
</code></pre>

<h3 id="希尔排序insertion-sort">希尔排序（Insertion Sort）</h3>

<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>

<h4 id="算法描述-3">算法描述</h4>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>

<ul>
  <li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
  <li>按增量序列个数k，对序列进行k 趟排序；</li>
  <li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>

<h4 id="动图演示-3">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/希尔排序.gif" alt="插入排序" /></p>

<h4 id="代码实现-3">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">group</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">group</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span><span class="c1">//增量序列为n/2,n/4....直到1</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">group</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">group</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//对每个分组进行插入排序</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">group</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">group</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">src</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">src</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
                        <span class="n">k</span> <span class="o">-=</span> <span class="n">group</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">src</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="归并排序merge-sort">归并排序（Merge Sort）</h3>

<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>

<h4 id="算法描述-4">算法描述</h4>

<p>把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。</p>

<h4 id="动图演示-4">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/归并排序.gif" alt="插入排序" /></p>

<h4 id="代码实现-4">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left_count</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">src_right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right_count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">left_index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">right_index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left_index</span> <span class="o">&lt;</span> <span class="n">left_count</span> <span class="o">&amp;&amp;</span> <span class="n">right_index</span> <span class="o">&lt;</span> <span class="n">right_count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">src_left</span><span class="p">[</span><span class="n">left_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">src_right</span><span class="p">[</span><span class="n">right_index</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_left</span><span class="p">[</span><span class="n">left_index</span><span class="p">];</span>
            <span class="o">++</span><span class="n">left_index</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_right</span><span class="p">[</span><span class="n">right_index</span><span class="p">];</span>
            <span class="o">++</span><span class="n">right_index</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left_index</span> <span class="o">&lt;</span> <span class="n">left_count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dest</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_left</span><span class="p">[</span><span class="n">left_index</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right_index</span> <span class="o">&lt;</span> <span class="n">right_count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dest</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_right</span><span class="p">[</span><span class="n">right_index</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 首先拆分成 2 个数组</span>
    <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left_count</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">middle</span><span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span><span class="n">src_left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">left_count</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">src_right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">right_count</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">src_left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">src_right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">middle</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 递归 归并排序</span>
    <span class="n">MergeSort</span><span class="p">(</span><span class="n">src_left</span><span class="p">,</span> <span class="n">left_count</span><span class="p">);</span>
    <span class="n">MergeSort</span><span class="p">(</span><span class="n">src_right</span><span class="p">,</span> <span class="n">right_count</span><span class="p">);</span>

    <span class="n">Merge</span><span class="p">(</span><span class="n">src_left</span><span class="p">,</span> <span class="n">left_count</span><span class="p">,</span> <span class="n">src_right</span><span class="p">,</span> <span class="n">right_count</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

    <span class="k">delete</span><span class="p">[]</span><span class="n">src_left</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span><span class="n">src_right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法分析">算法分析</h4>

<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>

<h3 id="快速排序">快速排序</h3>

<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>

<h4 id="算法描述-5">算法描述</h4>

<ul>
  <li>先从数列中取出一个数作为key值；</li>
  <li>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</li>
  <li>对左右两个小数列重复第二步，直至各区间只有1个数；</li>
</ul>

<h4 id="动图演示-5">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/快速排序.gif" alt="快速排序" /></p>

<h4 id="代码实现-5">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">QuikSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span> <span class="o">||</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">j</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 从右至左查找第一个小于 key 的值</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 从左至右查找第一个大于 key 的值</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">QuikSort</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">QuikSort</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="堆排序">堆排序</h3>

<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>

<h4 id="算法描述-6">算法描述</h4>

<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>

<h4 id="动图演示-6">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/堆排序.gif" alt="堆排序" /></p>

<h4 id="代码实现-6">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 构建大顶堆</span>
<span class="kt">void</span> <span class="nf">HeapBuild</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">max_num</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// 先默认左节点为最大值的下标</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">src</span><span class="p">[</span><span class="n">max_num</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">max_num</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">[</span><span class="n">max_num</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// 交换比父节点大的最大子节点</span>
            <span class="kt">int</span> <span class="n">tmp_val</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>
            <span class="n">src</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">max_num</span><span class="p">];</span>
            <span class="n">src</span><span class="p">[</span><span class="n">max_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_val</span><span class="p">;</span>
            <span class="c1">// 从此次最大子节点的那个位置开始递归建堆</span>
            <span class="n">HeapBuild</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从最后一个非叶子节点的父节点开始建堆，这样才能保证顺序</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HeapBuild</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 将已经建好的大顶堆进行排序，1、将最前和最后两个元素对调；2、重新建堆；3、重复第一步</span>
    <span class="c1">// j 表示数组此时的长度，因为 count 长度已经建过了</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">j</span><span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 交换首尾元素，将最大值交换到数组的最后位置</span>
        <span class="kt">int</span> <span class="n">tmp_val</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_val</span><span class="p">;</span>
        <span class="c1">// 去除最后元素重新建堆</span>
        <span class="n">HeapBuild</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="计数排序">计数排序</h3>

<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>

<h4 id="算法描述-7">算法描述</h4>

<ul>
  <li>找出待排序的数组中最大和最小的元素；</li>
  <li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
  <li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
  <li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>

<h4 id="动图演示-7">动图演示</h4>

<p><img src="/assets/img/old_blog/algorithm/计数排序.gif" alt="计数排序" /></p>

<h4 id="代码实现-7">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">CountSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">src_vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">src_vec</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 新建一个数组</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">src_vec</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">val</span> <span class="o">:</span> <span class="n">src_vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_val</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">src_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">src_vec</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">count</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法分析-1">算法分析</h4>

<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>

<h3 id="桶排序">桶排序</h3>

<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>

<h4 id="算法描述-8">算法描述</h4>

<ul>
  <li>设置一个定量的数组当作空桶；</li>
  <li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
  <li>对每个不是空的桶进行排序；</li>
  <li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>

<h4 id="图片演示">图片演示</h4>

<p><img src="/assets/img/old_blog/algorithm/桶排序.png" alt="桶排序" /></p>

<h4 id="算法分析-2">算法分析</h4>

<p>现在假设我有一堆蛋，包括麻雀蛋、鸡蛋、恐龙蛋，现在我要将这几种蛋排序下序；
有点常识就知道，这三种类别的蛋大小是不一样的,而且每一类蛋的大小也是有区别的，现在我对这三种蛋进行排序，我是这样排的：
准备三个桶，把同一类别的蛋放到同一个桶中，然后对每一个桶内的蛋进行排序，然后按顺序从三个桶中取出相应蛋排序；
即，从放有麻雀蛋的桶里取出所有麻雀蛋，因为已经有序，直接取出即可，然后再将鸡蛋取出，最后取出恐龙蛋，排序完成；
桶排序即先将大小相近的蛋（或“同一类蛋”）放入到同一个桶中，然后对桶内的蛋进行排序，由于每个桶内蛋的数量比较有限，所以排序效率较高</p>

<p>桶排序是一种时间复杂度为O（n）的排序方法，但并不意味着它有多优秀，上帝打开一扇门的同时也会关上一扇窗
桶排序的局限如下：
1）桶排序耗用较大的辅助空间，所需要的辅助空间一般与被排序的数列的最大值与最小值有关；
2）听到“桶”，很容易联想到哈希表，因为哈希表的冲突解决方法之一开链法也相当于一个个桶,事实上，这两种桶的原理是基本相同的；
3）并非所有数列都适合桶排序,桶排序适合分布比较均匀的数列，如1，2，3，6，4，像0，999，558，10000这种就不太适合
4）桶排序是一种稳定的排序算法
5）桶排序需要维护一个链表，但也有一类简单的桶排序算例如下，所有不同键值是放在不同的桶当中的，所以不用维护链表，当然，下面这种方法也不再稳定</p>

<h4 id="代码实现-8">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">BucketSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">buckets</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//准备一堆桶，容器的下标即待排序数组的键值或键值经过转化后的值</span>
                                   <span class="c1">//此时每个桶中都是没有放蛋的，所以都是0</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buckets</span><span class="p">[</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span><span class="c1">//把每个蛋放入到对应的桶中</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//把蛋取出，空桶则直接跳过</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="基数排序">基数排序</h3>

<p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。 
具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>

<h4 id="图文说明">图文说明</h4>

<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}，它的示意图如下：</p>

<p><img src="/assets/img/old_blog/algorithm/基数排序.png" alt="基数排序" /></p>

<p>在上图中，首先将所有待比较树脂统一为统一位数长度，接着从最低位开始，依次进行排序。</p>
<ol>
  <li>按照个位数进行排序。</li>
  <li>按照十位数进行排序。</li>
  <li>按照百位数进行排序。 
排序后，数列就变成了一个有序序列。</li>
</ol>

<p>为什么要从个数开始比较，低位是有序的，高位中如果有相同的值，则只需在保持稳定的前提下对高位进行排序，结果自然有序</p>

<h4 id="代码实现-9">代码实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//radix sort</span>
<span class="c1">//基数排序也是基于一种假设，假设所有数都是非负的整数</span>
<span class="c1">//基数排序的基本思路是从低位至高位依次比较每个数的对应位，并排序；对应位的比较采用计数排序也可以采用桶排序；</span>
<span class="c1">//基数排序是一种稳定的排序方法，不稳定的话也没法排序，因为某一位相同并不代表两个数相同； </span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">countSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">exp</span><span class="p">)</span>
<span class="p">{</span>   <span class="c1">//计数排序</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
 
	<span class="kt">int</span> <span class="n">length</span><span class="o">=</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmpVec</span><span class="p">(</span><span class="n">length</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
 
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">range</span><span class="p">[(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">exp</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">range</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">range</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span><span class="c1">//统计本应该出现的位置</span>
	<span class="p">}</span>
 
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">tmpVec</span><span class="p">[</span><span class="n">range</span><span class="p">[(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">exp</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">range</span><span class="p">[(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">exp</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vec</span><span class="o">=</span><span class="n">tmpVec</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">radixSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span><span class="o">=</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">max</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="c1">//提取出最大值</span>
		<span class="k">if</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">max</span><span class="p">)</span>
			<span class="n">max</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="c1">//提取每一位并进行比较，位数不足的高位补0</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">exp</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">max</span><span class="o">/</span><span class="n">exp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">exp</span><span class="o">*=</span><span class="mi">10</span><span class="p">)</span>
		<span class="n">countSort</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">exp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="algorithm" /><summary type="html"><![CDATA[以内内容为互联网收集，非原创。]]></summary></entry><entry><title type="html">mediasoup 公网环境部署</title><link href="https://gbcpp.github.io/meidasoup-demo-build.html" rel="alternate" type="text/html" title="mediasoup 公网环境部署" /><published>2019-04-01T00:00:00+00:00</published><updated>2019-04-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/meidasoup-demo-build</id><content type="html" xml:base="https://gbcpp.github.io/meidasoup-demo-build.html"><![CDATA[<p>最近以来一直基于 mediasoup 开发 rtc 相关产品，一直想基于 mediasoup 搭建自己的一套基础的 rtc 环境，用于自己练习 golang、rust 的开发、学习和测试，内网下搭建 mediasoup 比较简单，参照官网的文档一步步来很容易就能搞定，不过如果要在公网下搭建一套环境，相对来说略微麻烦些，需要云主机、nginx 配置、https 配置，通过这篇文章记录上述环境搭建的关键步骤。</p>

<!--more-->

<blockquote>
  <p>以下操作均在 Ubuntu 18.04 Server 系统上操作。</p>
</blockquote>

<h1 id="准备云主机">准备云主机</h1>

<p>公网环境的搭建还是需要一台拥有公网 IP 的主机的，当然如果你能薅公司的羊毛就更好了 。。本人的是阿里云主机 Ubuntu 系统 16.04 upgrade to 18.04，双11 时买的最便宜的机型，同时安装 ssh、 git、nodejs、npm，开启远程登录。</p>

<h1 id="域名准备">域名准备</h1>

<p>通过浏览器打开音视频设备因为有安全方面的限制，不能通过 IP 进行访问，必须通过 https://domain 的 url 打开，所以我们还需要准备一个域名并解析到我们自己的公网 IP 地址，域名也可以通过阿里云进行购买，因为不需要 seo，所以选一个最便宜的后缀即可，我选择了 <code class="language-plaintext highlighter-rouge">gobert.top</code>，第一年只有 9 元，后面还需要域名备案，否则域名将被重定向到指定地址，所以域名需要提前准备。</p>

<blockquote>
  <p>首次域名备案相对来说比较麻烦，需要准备居住证（来沪外来人员）等证件，各种审核需要耗时两三天吧。</p>
</blockquote>

<h1 id="安装-mediasoup">安装 mediasoup</h1>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ ssh gobert@47.100.110.xxx
gobert@47.100.110.xxx<span class="s1">'s password:
Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-38-generic x86_64)

Last login: Mon Apr  1 17:28:34 2019 from 116.236.177.xxx
$ mkdir develop
$ cd develop
$ git clone git@github.com:versatica/mediasoup-demo.git
</span></code></pre></div></div>

<p>后续 npm 的安装需参照 <code class="language-plaintext highlighter-rouge">https://github.com/versatica/mediasoup-demo/</code> 文档进行。</p>

<h1 id="nginx-配置">nginx 配置</h1>

<blockquote>
  <p>这一步默认域名购买、解析、备案已完成。</p>
</blockquote>

<h2 id="在线安装-nginx">在线安装 nginx</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>nginx
</code></pre></div></div>

<h2 id="部署-mediasoup-到-nginx">部署 mediasoup 到 nginx</h2>

<blockquote>
  <p>将 mediasoup 中的 server 目录拷贝到 nginx 根目录下。</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/www/mediasoup
<span class="nv">$ </span><span class="nb">sudo cp</span> <span class="nt">-r</span> medissoup-demo/server/ /var/www/mediasoup/
</code></pre></div></div>

<p>配置 nginx 解析到以上目录，编辑 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 配置文件，将 server 根路径下的 root 属性修改为 <code class="language-plaintext highlighter-rouge">/var/www/mediasoup/server/public;</code>,即：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c"># 以上省略</span>
 <span class="c">#root /var/www/html;</span>
 root /var/www/mediasoup/server/public<span class="p">;</span>

 <span class="c"># Add index.php to the list if you are using PHP</span>
 index index.html index.htm index.nginx-debian.html<span class="p">;</span>
 <span class="c"># 以下省略</span>
</code></pre></div></div>

<h2 id="配置-https-服务">配置 https 服务</h2>

<p>通过浏览器打开设备需要 https 安全 url，nginx 必须开启 https 服务，通过 letsencrypt 进行 https 的自动化配置，省去了自己很多的麻烦，不用再去申请证书、审核、验证部署等繁琐的操作了，通过 <code class="language-plaintext highlighter-rouge">https://certbot.eff.org/lets-encrypt/ubuntubionic-nginx</code> 下的命令按步执行即可。</p>

<p><img src="/images/letsencrypt.png" alt="rtc::Thread UML 类图" /></p>

<blockquote>
  <p>letsencrpt 安装的 ssl 证书只有三个月的有效期，所以为了防止证书过期，建议添加系统定时任务，定期执行脚本命令更新证书：</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>su -
<span class="nv">$ </span>certbot renew <span class="nt">--dry-run</span>
</code></pre></div></div>

<p>正常情况下，你的 nginx 已经开启了 https 服务, ssl 证书及秘钥存放位置记录在 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 配置文件中，打开 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 文件，发现 letsencrpty 自动在脚本末尾增加了一项 server 配置，将 <code class="language-plaintext highlighter-rouge">root</code> 路径配置为以上 <code class="language-plaintext highlighter-rouge">/var/www/mediasoup/server/public;</code> 目录，同时记录下其 ssl_certificate 目录，后面 nginx 配置中需要指定：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen <span class="o">[</span>::]:443 ssl <span class="nv">ipv6only</span><span class="o">=</span>on<span class="p">;</span> <span class="c"># managed by Certbot</span>
listen 443 ssl<span class="p">;</span> <span class="c"># managed by Certbot</span>
ssl_certificate /etc/letsencrypt/live/www.gobert.top/fullchain.pem<span class="p">;</span> <span class="c"># managed by Certbot</span>
ssl_certificate_key /etc/letsencrypt/live/www.gobert.top/privkey.pem<span class="p">;</span> <span class="c"># managed by Certbot</span>
include /etc/letsencrypt/options-ssl-nginx.conf<span class="p">;</span> <span class="c"># managed by Certbot</span>
ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem<span class="p">;</span> <span class="c"># managed by Certbot</span>
</code></pre></div></div>

<h2 id="配置-nginx-开启-gzip">配置 nginx 开启 gzip</h2>

<p>mediasoup 中 <code class="language-plaintext highlighter-rouge">mediasoup-demo-app.js</code> 有 12MB 大小，如果 server 带宽比较低的话，用户首次拉取会比较慢，由于 nginx 默认配置是不开启 gzip 压缩的，所以需要我们手动开启 gzip 压缩，修改 nginx 的配置文件（全站配置）<code class="language-plaintext highlighter-rouge">/etc/nginx/nginx.conf</code>，将以下内容的注释全部取消：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gzip on;

gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
</code></pre></div></div>

<p>然后重启 nginx 服务即可：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> /etc/init.d/nginx reload
</code></pre></div></div>

<h2 id="配置-mediasoup-server">配置 mediasoup server</h2>

<ul>
  <li>配置自定义脚本：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>copy config.example.js config.js
</code></pre></div></div>

<p>打开 config.js 文件，在 tls 路径中，将上面记录的 letsencrypt 证书路径拷贝到相应的 item 中，同时修改 <code class="language-plaintext highlighter-rouge">rtcAnnouncedIPv4</code> 为云主机公网 IP 地址，完整的 config.js 的文件为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports =
{
        // Listening hostname for `gulp live|open`.
        domain : 'localhost',
        tls    :
        {
                cert : `/etc/letsencrypt/live/www.gobert.top/fullchain.pem`, // letsencrypt 证书
                key  : `/etc/letsencrypt/live/www.gobert.top/privkey.pem`    // letsencrypt 秘钥
        },
        mediasoup :
        {
                // mediasoup Server settings.
                logLevel : 'warn',
                logTags  :
                [
                        'info',
                        'ice',
                        'dtls',
                        'rtp',
                        'srtp',
                        'rtcp',
                        // 'rbe',
                        // 'rtx'
                ],
                numWorkers       : null, // Use number of CPUs.
                rtcIPv4          : true,
                rtcIPv6          : true,
                rtcAnnouncedIPv4 : '47.100.110.192', // 云主机公网地址
                rtcAnnouncedIPv6 : null,  // 根据需要，自主填写
                rtcMinPort       : 40000, // udp 最小端口，需要云主机安全组中配置
                rtcMaxPort       : 49999, // dup 最大端口，需要云主机安全组中配置
                // mediasoup Room codecs.
                mediaCodecs      :
                [
                        {
                                kind       : 'audio',
                                name       : 'opus',
                                mimeType   : 'audio/opus',
                                clockRate  : 48000,
                                channels   : 2,
                                parameters :
                                {
                                        useinbandfec : 1
                                }
                        },
                        {
                                kind       : 'video',
                                name       : 'VP8',
                                mimeType   : 'video/VP8',
                                clockRate  : 90000,
                                parameters :
                                {
                                        'x-google-start-bitrate': 1500
                                }
                        },
                        {
                                kind       : 'video',
                                name       : 'h264',
                                mimeType   : 'video/h264',
                                clockRate  : 90000,
                                parameters :
                                {
                                        'packetization-mode'      : 1,
                                        'profile-level-id'        : '42e01f',
                                        'level-asymmetry-allowed' : 1
                                }
                        }
                ],
                // mediasoup per Peer max sending bitrate (in bps).
                maxBitrate : 500000
        }
};
</code></pre></div></div>

<ul>
  <li>修改 Server 监听端口</li>
</ul>

<blockquote>
  <p>此处修改 server 的监听端口其实没什么意义，可以忽略。</p>
</blockquote>

<p>编辑 <code class="language-plaintext highlighter-rouge">server.js</code> 配置文件，将默认端口 <code class="language-plaintext highlighter-rouge">httpsServer.listen(3443, '0.0.0.0', () =&gt;</code> 替换为 <code class="language-plaintext highlighter-rouge">httpsServer.listen(5678, '0.0.0.0', () =&gt;</code>。</p>

<ul>
  <li>配置 Client 访问 Server WSS 地址</li>
</ul>

<p>打开 ` public/mediasoup-demo-app.js<code class="language-plaintext highlighter-rouge"> 将 </code>getProtooUrl<code class="language-plaintext highlighter-rouge"> 方法中的 URL 地址端口改为自定义的 </code>5678` 端口：</p>

<blockquote>
  <p>如果上一步中没有修改 server 的监听端口的话，这一步也可忽略。</p>
</blockquote>

<pre><code class="language-node.js">function getProtooUrl(peerName, roomId, forceH264) {
  var hostname = window.location.hostname;
  var url = "wss://".concat(hostname, ":5678/?peerName=").concat(peerName, "&amp;roomId=").concat(roomId);
  if (forceH264) url = "".concat(url, "&amp;forceH264=true");
  return url;
}
</code></pre>

<h2 id="启动-mediasoup-server">启动 mediasoup server</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> /var/www/mediasoup/server
<span class="nv">$ </span><span class="nb">sudo </span><span class="nv">DEBUG</span><span class="o">=</span><span class="s2">"*mediasoup* *ERROR* *WARN*"</span> <span class="nv">INTERACTIVE</span><span class="o">=</span><span class="s2">"true"</span> node server.js
</code></pre></div></div>

<h2 id="重启-nginx">重启 nginx</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>nginx <span class="nt">-s</span> reload
</code></pre></div></div>
<h1 id="在线体验">在线体验</h1>

<blockquote>
  <p>此主机带宽比较低，初次打开比较慢，需耐心等待加载完成，后面缓冲后速度会变化，音视频延迟不受影响。</p>
</blockquote>

<p>在两个终端浏览器（支持 Chrome、Firefox、Safari）中均打开 <code class="language-plaintext highlighter-rouge">https://www.gobert.top/?roomId=123456</code> 即可体验，RoomId 可自定义。</p>]]></content><author><name>Mr Chen</name></author><category term="开源" /><category term="WebRTC" /><category term="mediasoup" /><summary type="html"><![CDATA[最近以来一直基于 mediasoup 开发 rtc 相关产品，一直想基于 mediasoup 搭建自己的一套基础的 rtc 环境，用于自己练习 golang、rust 的开发、学习和测试，内网下搭建 mediasoup 比较简单，参照官网的文档一步步来很容易就能搞定，不过如果要在公网下搭建一套环境，相对来说略微麻烦些，需要云主机、nginx 配置、https 配置，通过这篇文章记录上述环境搭建的关键步骤。]]></summary></entry></feed>