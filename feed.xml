<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2025-04-02T07:54:29+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">Mac Env Fix</title><link href="https://gbcpp.github.io/mac-env-fix.html" rel="alternate" type="text/html" title="Mac Env Fix" /><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/mac-env-fix</id><content type="html" xml:base="https://gbcpp.github.io/mac-env-fix.html"><![CDATA[<!--
 * @Author: Eddie gbao1987@163.com
 * @Date: 2025-04-02 15:38:32
 * @LastEditors: Eddie gbao1987@163.com
 * @LastEditTime: 2025-04-02 15:52:59
 * @FilePath: /gbcpp.github.io/_posts/notes/2020-01-01-blog-templete copy.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<hr />
<p>layout: post
title: ‘Mac 系统环境配置异常记录’
subtitle: 
date: 2025-04-02
author: Mr Chen
cover: ‘/assets/img/shan.jpg’
categories: Notes
tags:</p>
<ul>
  <li>
    <h2 id="life">Life</h2>
  </li>
</ul>

<blockquote>
  <p>整理记录 Mac 下开发、学习环境中遇到的疑难杂症及其解决过程和方案。</p>
</blockquote>

<h1 id="mac-下-vscode-和-cursor-ide-的-vim-插件长按键不生效">Mac 下 VSCode 和 Cursor IDE 的 vim 插件长按键不生效</h1>

<ul>
  <li>VSCode</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 标准版 VSCode</span>
defaults write com.microsoft.VSCode ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VSCode Insider 版</span>
defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VS Codium</span>
defaults write com.vscodium ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># VS Codium Exploration 用户</span>
defaults write com.microsoft.VSCodeExploration ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>

<span class="c"># 全局设置（慎用）</span>
defaults delete <span class="nt">-g</span> ApplePressAndHoldEnabled
</code></pre></div></div>

<ul>
  <li>Cursor</li>
</ul>

<p>虽然 Cursor 也是基于 VSCode，但是需要额外的配置才行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults write <span class="s2">"</span><span class="si">$(</span>osascript <span class="nt">-e</span> <span class="s1">'id of app "Cursor"'</span><span class="si">)</span><span class="s2">"</span> ApplePressAndHoldEnabled <span class="nt">-bool</span> <span class="nb">false</span>
</code></pre></div></div>

<blockquote>
  <p>上述命令执行完后，均需要重启 IDE。</p>
</blockquote>]]></content><author><name>Mr Chen</name></author><summary type="html"><![CDATA[layout: post title: ‘Mac 系统环境配置异常记录’ subtitle: date: 2025-04-02 author: Mr Chen cover: ‘/assets/img/shan.jpg’ categories: Notes tags: Life]]></summary></entry><entry><title type="html">HTTP3/QUIC 在部分iPhone设备下卡顿问题排查</title><link href="https://gbcpp.github.io/notes/quic-stuck-on-iphone.html" rel="alternate" type="text/html" title="HTTP3/QUIC 在部分iPhone设备下卡顿问题排查" /><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/quic-stuck-on-iphone</id><content type="html" xml:base="https://gbcpp.github.io/notes/quic-stuck-on-iphone.html"><![CDATA[<blockquote>
  <p>  直播的边缘服务器开启 HTTP3 以后，出现 iPhone 的部分机型明显卡顿的问题，而 HTTP2 确不会，明显不符合预期。正常应该是使用了 QUIC 的 HTTP3 的传输效果优于 TCP 才对，这才是大部分机型的表现。</p>
</blockquote>

<h2 id="排查过程">排查过程</h2>

<h3 id="协议对比">协议对比</h3>

<p>在指定的 iPhone 设备上通过后台控制、确认播放端使用的 HTTP 版本，明确在正常的网络环境下使用 TCP 的播放效果要明显优于基于 UDP 的 HTTP3，明显问题现象。</p>

<h3 id="mtu-问题">MTU 问题</h3>

<p>通过打开 quic-go 中的 debug log，看到播放端在出现卡顿时，出现大概率的 <code class="language-plaintext highlighter-rouge">lost packet</code>，怀疑是 quic-go 的 MTU 探测问题，探测到错误的 max packet size 导致发送了过大的数据包触发的 IP 分片导致的丢失。</p>

<p>  。。。。。。   此处省略一万字，debug 排查 guic-go 中的 MTU 探测模块代码逻辑简单、清晰，没有代码问题。</p>

<p>那么如果将 quic-go 中的 MTU 探测关闭，让其一直固定使用 initial 的 max packet size：1252，会有问题吗？</p>

<p>通过 quic-go 的配置 <code class="language-plaintext highlighter-rouge">DisablePathMTUDiscovery</code> 将其置为 <code class="language-plaintext highlighter-rouge">true</code>, 其默认为 <code class="language-plaintext highlighter-rouge">false</code>，进行测试验证后，发现卡顿现象消失了，可以明确问题就是 MTU 的问题了，链路上发送了超过实际 MTU 大小的数据，触发的 IP 分片导致大量的丢包，从而出现的卡顿。</p>

<h3 id="抓包验证">抓包验证</h3>

<p>依然开启 quic-go 的 MTU-Discorver 功能: <code class="language-plaintext highlighter-rouge">DisablePathMTUDiscovery</code> 将其置为 <code class="language-plaintext highlighter-rouge">false</code>。</p>

<ul>
  <li>Server 测抓包</li>
</ul>

<p>Server 测通过 <code class="language-plaintext highlighter-rouge">tcpdump</code> 抓包即可，命令： <code class="language-plaintext highlighter-rouge">tcpdump -i any -s 1500 udp src port 4443 -v</code> 抓取自己从 HTTP3 端口 4443 发送方向的数据包，重点是查看数据包的大小是否有在本地发送时出现切包的情况。</p>

<ul>
  <li>iPhone 设备测抓包</li>
</ul>

<p>通过 <code class="language-plaintext highlighter-rouge">xcode</code> 工具集中的 <code class="language-plaintext highlighter-rouge">rvictl</code> 结合 <code class="language-plaintext highlighter-rouge">wireshark</code> 进行抓包。</p>

<p>首先 Mac 上需要安装 <code class="language-plaintext highlighter-rouge">xcode</code> 开发工具，将 iPhone 连接 Mac 后，通过 xcode 查看该 iPhone 设备的 Identifier ID，在 <code class="language-plaintext highlighter-rouge">xcode</code> 的 <code class="language-plaintext highlighter-rouge">window</code> 菜单 ==<code class="language-plaintext highlighter-rouge">》Device</code> 选项 进行查看：</p>

<p><img src="/assets/img/blog/xcode-identifier.png" alt="获取 iPhone ID" /></p>

<p><strong>启动虚拟网卡：</strong></p>

<p>Terminal 中命令启动：<code class="language-plaintext highlighter-rouge">rvictl -s 00008130-00012C163EC2001C </code>，如果失败，会有 <code class="language-plaintext highlighter-rouge">FAILED</code> 的输出提示。</p>

<p><strong>启动 WireShark：</strong></p>

<p>需要 <code class="language-plaintext highlighter-rouge">root </code>权限，从 Terminal 中进行启动： <code class="language-plaintext highlighter-rouge">sudo wireshark</code>，选择网卡 <strong>rvi</strong> 网卡进行抓取，可以添加过滤条件，如：<code class="language-plaintext highlighter-rouge">udp.port == 4443</code></p>

<ul>
  <li>复现抓包</li>
</ul>

<p>手机测通过 HTTP3 拉流复现后，分别查看 Server 和 iPhone 测的抓包结果进行分析：</p>

<p>下图可以看到server 在发送 1400+ 的数据包的时候，是未分片且带有 <code class="language-plaintext highlighter-rouge">DF</code> flag 的，<strong>server 发送的所有数据包均是如此</strong>：</p>

<p><img src="/assets/img/blog/server-quic-capture0.png" alt="Server 抓包截图（未切片）" /></p>

<p>iPhone 测抓包可以看到首先收到的 1400+ 的 数据包是带有 <code class="language-plaintext highlighter-rouge">DF</code> flag 的，同时也没有进行切片，如下图：</p>

<p><img src="/assets/img/blog/client-quic-capture.png" alt="iPhone 抓包1（首先无分片）" /></p>

<p>但是在后面很快就出现了 IP 分片，且去除了 DF flag 的数据包，iPhone 测只能接收到一半的数据包：</p>

<p><img src="/assets/img/blog/client-quic-capture2.png" alt="iPhone 抓包2（被分片）" /></p>

<blockquote>
  <p>注意：该问题在仅在我司的 Wifi 网络环境下存在，4G/5G 网络条件下不存在。</p>
</blockquote>

<h2 id="结论">结论</h2>

<p>   通过上述抓包可以看到是因为链路中某个路由设备对 MTU 大于 1400 的数据包进行了强行切片，分成了 2 片进行发送，这里存在两个问题：</p>

<p>1、该路由设备放行了前面一小部分大于 1400 的数据包，接收端接收并 Ack 给了发送端，导致发送端的 Mtu 探测模块爬升到了更高的值，但是后面该路由设备又对 1400+ 的数据包改变了策略，不允许通过，而 quic-go 中的 mtu 探测模块又没有向下探测 mtu 的能力，导致业务遇到该场景必死无疑。</p>

<p>2、发送端发送的数据包已经明确设置了 <code class="language-plaintext highlighter-rouge">DF</code> 即 <code class="language-plaintext highlighter-rouge">Don't fragment</code> 的 flag，路由设备在收到超过自己 MTU 设备时应该直接丢掉，而非先进行放行，然后强行忽略 DF flag 进行切片转发，让接收端产生误判。</p>

<p>   对比抓取其它使用 HTTP3/QUIC 协议的 APP 数据包，比如油管的短视频和直播，可以看到其并未向上探测 MTU，使用的是固定的 1250 这样的一个 MTU 大小。</p>

<p>   使用 1300 以内的 MTU 大小是网络兼容性最好选择，但是会牺牲一定的服务器网络数据包处理的性能，像 Google 这样的 APP 亦是如此。如果需要追求极致性能，还有一个解决方案，那就是为 MTU 探测模块增加向下探测的能力，比如这种场景，已经探测到了 1400 的大小，但是后续路由器开启切片导致大量的丢包，协议内部开始向下探测 MTU 大小，或者重新从 1000/1200 开始探测即可。</p>

<h2 id="后续">后续</h2>

<p>   无</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Protocol" /><summary type="html"><![CDATA[  直播的边缘服务器开启 HTTP3 以后，出现 iPhone 的部分机型明显卡顿的问题，而 HTTP2 确不会，明显不符合预期。正常应该是使用了 QUIC 的 HTTP3 的传输效果优于 TCP 才对，这才是大部分机型的表现。]]></summary></entry><entry><title type="html">golang 问题记录</title><link href="https://gbcpp.github.io/notes/golang-issues.html" rel="alternate" type="text/html" title="golang 问题记录" /><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/golang-issues</id><content type="html" xml:base="https://gbcpp.github.io/notes/golang-issues.html"><![CDATA[<p>  </p>
<blockquote>
  <p>记录 Golang 学习、开发过程中的一些疑难杂症。</p>
</blockquote>

<h1 id="环境问题">环境问题</h1>

<h2 id="missing-gosum-entry-for-module">missing go.sum entry for module</h2>

<p>曾经编译过的代码出现类似如下的错误 <code class="language-plaintext highlighter-rouge">missing go.sum entry for module</code>，各种依赖缺失的 mod，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base/file.go:10:2: missing go.sum entry for module providing package github.com/astaxie/beego/logs; to add:
	go mod download github.com/astaxie/beego
base/name_generate.go:6:2: missing go.sum entry for module providing package github.com/google/uuid (imported by ben/base); to add:
	go get ben/base
helpers/data_analysis/base/bar_base.go:6:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/charts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/metrics.go:9:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/components (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
helpers/data_analysis/base/bar_base.go:7:2: missing go.sum entry for module providing package github.com/go-echarts/go-echarts/v2/opts (imported by ben/helpers/data_analysis/base); to add:
	go get ben/helpers/data_analysis/base
</code></pre></div></div>

<p><strong>解决办法</strong></p>

<p>使用 <code class="language-plaintext highlighter-rouge">go mod tidy</code> 来整理依赖，该命令有如下作用：</p>

<ul>
  <li>删除不需要的依赖包</li>
  <li>下载新的依赖包</li>
  <li>更新 <code class="language-plaintext highlighter-rouge">go.sum</code></li>
</ul>

<p>重新执行 <code class="language-plaintext highlighter-rouge">go run</code> <code class="language-plaintext highlighter-rouge">go build</code> 问题解决。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[   记录 Golang 学习、开发过程中的一些疑难杂症。]]></summary></entry><entry><title type="html">直播回源优化</title><link href="https://gbcpp.github.io/notes/optimize-back-to-source.html" rel="alternate" type="text/html" title="直播回源优化" /><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/optimize-back-to-source</id><content type="html" xml:base="https://gbcpp.github.io/notes/optimize-back-to-source.html"><![CDATA[<blockquote>
  <p>该文档主要考虑的是针对需要回源时秒开的优化。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>  当前 streamd server 在收到拉流请求时，若需要回源，在回源后 streamd 下发给 Player 数据时使用的是帧级别的下发，特别是在接收首个关键帧时，只有接收到完整的视频帧以后，方才开始下发给 Player，这样无形中增加了一定的数据接收+组帧的耗时，通过当前 superset 的数据分析，在需要回源的 case 中， streamd 等待接收首个视频关键帧的时长几乎全部超过 100ms 以上，这便为该次播放请求增加了固定时间的延迟，优化空间明显。</p>

<h1 id="优化内容">优化内容</h1>

<p>  针对当前数据转发的模式，将帧级别的转发模式优化为 Slice 级别的转发模式。</p>

<h2 id="流程图">流程图</h2>

<p><img src="/assets/img/blog/streamd-optimize.png" alt="数据转发流程图" /></p>

<h2 id="优点">优点</h2>

<ul>
  <li>加快秒开速度，减少回源阶段 Block 等待时间，初步估计对回源 case 的秒开优化在百毫秒以上。</li>
  <li>Streamd 下发数据时基于 Slice 进行下发，数据发送更加平滑，减少 Frame 级别的下发带来的网络拥塞，有益于卡顿率的降低。</li>
</ul>

<h2 id="缺点">缺点</h2>

<p>  Streamd 服务在各协议的封装性上需要结构性的调整，数据流程改动较大，需要考虑不同 Protocol/Muxer/Demuxer 之间的兼容性，可能难以实现所有 Protocol/Muxer/Demuxer 之间的分片转发，但依然有很大的优化场景需求。
最理想的情况为：源站提供 FLV 的数据拉流协议，而 Streamd 也是用 FLV 的回源拉流协议，Streamd 在接收端最多需要处理 FLV Header Tag 的部分信息，不阻塞 Slice 的下发。</p>

<h2 id="flv-格式">FLV 格式</h2>

<p><a href="https://blog.ibaoger.com/2017/06/04/flv-file-format/">Reference URL</a></p>

<p><img src="/assets/img/blog/flv-format.png" alt="FLV format" /></p>

<h1 id="srs-现状">SRS 现状</h1>

<p>  那么问题来了， srs 是否已经考虑到这一点的优化空间呢？</p>

<p>  对比查看 srs 是否使用的这种透明转发模式，还是帧转发模式？
这里记录的为使用 HTTP-FLV 回源协议的代码流程。</p>

<p>srs 需要回源时建议优先使用 Edge 模式，回源时，内部首先创建一个 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream</code> 实例，用于向源站发起连接，并用于实时的接收、处理数据，代码文件：<code class="language-plaintext highlighter-rouge">srs_app_edge.cpp</code>。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">connect</code> ==&gt; <code class="language-plaintext highlighter-rouge">do_connect</code> 发起向源站的连接请求，判定 http response status code 非 404、非 302 后，开始接收、处理媒体数据。</p>

<p>事件轮询在 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::ingest()</code> 中，同步模式不断循环执行 <code class="language-plaintext highlighter-rouge">SrsEdgeFlvUpstream::recv_message()</code> 接收完整的数据，而后通过 <code class="language-plaintext highlighter-rouge">SrsEdgeIngester::process_publish_message</code> 将数据流转到后序处理的模块，比如 Source、Consumer 等，但在这之前重点是确认在 recv_message 中是否会 block 等待完整的一个 tag data。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsEdgeFlvUpstream</span><span class="o">::</span><span class="n">recv_message</span><span class="p">(</span><span class="n">SrsCommonMessage</span><span class="o">**</span> <span class="n">pmsg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">time</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag header"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_tag_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">srs_freepa</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read tag data"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">pps</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">decoder_</span><span class="o">-&gt;</span><span class="n">read_previous_tag_size</span><span class="p">(</span><span class="n">pps</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read pts"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">stream_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SrsCommonMessage</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">srs_rtmp_create_msg</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"create message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">pmsg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到首先读取 tag_header，然后从header 中获取 tag size 开始读取指定size 的tag data，<code class="language-plaintext highlighter-rouge">SrsFlvDecoder::read_tag_data()</code> ==» <code class="language-plaintext highlighter-rouge">SrsHttpFileReader:read()</code></p>

<p>可以看到在 <code class="language-plaintext highlighter-rouge">SrsHttpFileReader::read(void* buf, size_t count, ssize_t* pnread)</code> 中其会持续的尝试去接收指定 size 大小的数据，直到接收完整，或者 io 报错，源码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">srs_error_t</span> <span class="n">SrsHttpFileReader</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="o">*</span> <span class="n">pnread</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srs_error_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">srs_success</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">http</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">total_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total_read</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">ssize_t</span> <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">http</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">total_read</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">count</span> <span class="o">-</span> <span class="n">total_read</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nread</span><span class="p">))</span> <span class="o">!=</span> <span class="n">srs_success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">srs_error_wrap</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"read"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">srs_error_new</span><span class="p">(</span><span class="n">ERROR_HTTP_REQUEST_EOF</span><span class="p">,</span> <span class="s">"EOF"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">srs_assert</span><span class="p">(</span><span class="n">nread</span><span class="p">);</span>
        <span class="n">total_read</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pnread</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pnread</span> <span class="o">=</span> <span class="n">total_read</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>结论：</strong> 当前 srs 使用的是帧级别的转发模式，没有实现分片的透明转发。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[该文档主要考虑的是针对需要回源时秒开的优化。]]></summary></entry><entry><title type="html">直播场景TCP秒开优化</title><link href="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html" rel="alternate" type="text/html" title="直播场景TCP秒开优化" /><published>2025-01-10T00:00:00+00:00</published><updated>2025-01-10T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/tcp-optimize-livestream-scene</id><content type="html" xml:base="https://gbcpp.github.io/notes/tcp-optimize-livestream-scene.html"><![CDATA[<blockquote>
  <p>当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。</p>
</blockquote>

<h1 id="现状">现状</h1>

<p>公司使用静态节点和动态节点作为边缘以节省成本，且多种业务集中进行混布，其中动态节点质量较差，但成本较低，也是导致问题的关键所在，在对Linux 内核的升级和参数调整操作上一定要慎重。</p>

<p><strong>当前动态节点版本及相关配置：</strong></p>

<ul>
  <li>内核版本：5.4.119-19-0006</li>
  <li>见下面章节</li>
</ul>

<h1 id="优化验证">优化验证</h1>

<h2 id="环境准备">环境准备</h2>

<h3 id="tc-配置">TC 配置</h3>

<p>首先安装 tc 工具，系统默认不安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> iproute2

tc <span class="nt">--version</span>
</code></pre></div></div>

<p><strong>启动配置网损:</strong></p>

<p>比如配置 <code class="language-plaintext highlighter-rouge">lo</code> 网卡 50～150ms 左右的延迟，且包含 0～15% 的一个随机丢包，配置如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>su
<span class="nv">$ </span>tc qdisc add dev lo root netem delay 50ms 25ms distribution normal loss random 0% 15%

<span class="c"># 查看配置是否生效</span>
<span class="nv">$ </span>tc qdisc show dev lo
  qdisc netem 8002: root refcnt 2 limit 1000 delay 50ms  25ms
</code></pre></div></div>

<p><strong>验证：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ping 127.0.0.1 <span class="nt">-i</span> 0.2
PING 127.0.0.1 <span class="o">(</span>127.0.0.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>102 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>115 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>175 ms
64 bytes from 127.0.0.1: <span class="nv">icmp_seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>80.4 ms
<span class="nt">---</span> 127.0.0.1 ping statistics <span class="nt">---</span>
21 packets transmitted, 20 received, 4.7619% packet loss, <span class="nb">time </span>4016ms
rtt min/avg/max/mdev <span class="o">=</span> 48.201/113.013/207.390/42.338 ms, pipe 2
</code></pre></div></div>

<p><strong>恢复：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 删除配置</span>
<span class="nv">$ </span>tc qdisc del dev lo root
</code></pre></div></div>

<p><strong>注意：</strong> 不要无脑 copy 别人的 tc 配置命令，使用了 <code class="language-plaintext highlighter-rouge">channge</code> 而非 <code class="language-plaintext highlighter-rouge">add</code>，导致 <code class="language-plaintext highlighter-rouge">Error: Qdisc not found. To create specify NLM_F_CREATE flag.</code> 报错，还以为内核缺少 sch_netem 模块，差点重新安装完整内核。
可以通过命令：<code class="language-plaintext highlighter-rouge">modinfo sch_netem</code> 查看系统是否已经安装有 <code class="language-plaintext highlighter-rouge">sche_netem</code> 模块，如果没有就会报错，有的话会有模块信息输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename:       /lib/modules/6.8.0-51-generic/kernel/net/sched/sch_netem.ko.zst
description:    Network characteristics emulator qdisc
license:        GPL
srcversion:     7631AD62974660130A36DCA
depends:
retpoline:      Y
intree:         Y
name:           sch_netem
vermagic:       6.8.0-51-generic SMP preempt mod_unload modversions
sig_id:         PKCS#7
signer:         Build <span class="nb">time </span>autogenerated kernel key
sig_key:        29:0D:80:5A:E0:B3:D6:D4:D4:D3:D0:EF:AB:48:F3:DB:73:58:2F:63
sig_hashalgo:   sha512
signature:      03:A4:1E:0E:CA:01:0F:58:3E:93:93:A7:25:97:FC:82:3E:4F:60:CA:
                00:84:75:DF:A3:20:F7:1B:92:9D:B1:58:6D:E2:47:92:84:83:00:FD:
                ...
</code></pre></div></div>

<h3 id="netperf">NetPerf</h3>

<ul>
  <li>启动 netserver</li>
</ul>

<p>启动 <code class="language-plaintext highlighter-rouge">netserver</code>, <code class="language-plaintext highlighter-rouge">netserver</code> 与 <code class="language-plaintext highlighter-rouge">netperf</code> 是同一套 Tools，只是 server 测启动命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netserver <span class="nt">-h</span>

Usage: netserver <span class="o">[</span>options]

Options:
    <span class="nt">-h</span>                Display this text
    <span class="nt">-D</span>                Do not daemonize
    <span class="nt">-d</span>                Increase debugging output
    <span class="nt">-f</span>                Do not spawn chilren <span class="k">for </span>each <span class="nb">test</span>, run serially
    <span class="nt">-L</span> name,family    Use name to pick listen address and family <span class="k">for </span>family
    <span class="nt">-N</span>                No debugging output, even <span class="k">if </span>netperf asks
    <span class="nt">-p</span> portnum        Listen <span class="k">for </span>connect requests on portnum.
    <span class="nt">-4</span>                Do IPv4
    <span class="nt">-6</span>                Do IPv6
    <span class="nt">-v</span> verbosity      Specify the verbosity level
    <span class="nt">-V</span>                Display version information and <span class="nb">exit</span>
    <span class="nt">-Z</span> passphrase     Expect passphrase as the first thing received


<span class="c"># 启动命令</span>
<span class="nv">$ </span>~<span class="nv">$ </span><span class="nb">sudo </span>netserver <span class="nt">-p</span> 1234 <span class="nt">-D</span> <span class="nt">-4</span>
check_if_inetd: enter
setup_listens: enter
create_listens: called with host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span> family AF_INET<span class="o">(</span>2<span class="o">)</span>
getaddrinfo returned the following <span class="k">for </span>host <span class="s1">'0.0.0.0'</span> port <span class="s1">'1234'</span>  family AF_INET
        cannonical name: <span class="s1">'(nil)'</span>
        flags: 1 family: AF_INET: socktype: SOCK_STREAM protocol IPPROTO_TCP addrlen 16
        sa_family: AF_INET sadata: 4 210 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Starting netserver with host <span class="s1">'IN(6)ADDR_ANY'</span> port <span class="s1">'1234'</span> and family AF_INET
accept_connections: enter
set_fdset: enter list 0x5f3130ac4740 fd_set 0x7fff92fb9450
setting 3 <span class="k">in </span>fdset

</code></pre></div></div>

<p>使 <code class="language-plaintext highlighter-rouge">netserver</code> 监听在 1234 端口上，并指定 IPv4 协议，-D 表示不在后台运行。</p>

<ul>
  <li>启动 Client</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 10  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 100,3000000
</code></pre></div></div>

<p>参数说明：
-H： 指定 server 的 IP 地址
-p： 指定 server 的 port
-l： 指定测试运行多长时间，单位：秒
-t： 运行模式，我们使用 <code class="language-plaintext highlighter-rouge">TCP_CRR</code> 来模拟 client 请求与 server 建连以后，由server 下发一定的数据量以后，关闭连接的这种 request/response 模式
-r： 分别指定 request 和 response 的字节数大小</p>

<h2 id="默认配置benchmark">默认配置Benchmark</h2>

<p>记录下当前内核参数中与 tcp 相关的配置，并获取当前配置的 Benchmark 数据，用以在后续的优化中进行对比。
首先直接用 <code class="language-plaintext highlighter-rouge">netperf</code> 执行 20分钟的测试数据获取：</p>

<p>首先获取下当前测试流的关键帧的大小用以模拟尽量贴近实际业务场景的模拟：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 首先 dump 到本地</span>
ffmpeg <span class="nt">-i</span> http://xxxx/yyyyy/zzzzzzz.flv <span class="nt">-c</span> copy  1.flv

<span class="c"># 然后获取该片段的的首个关键帧的大小</span>
ffmpeg <span class="nt">-i</span> 1.flv <span class="nt">-frames</span>:v 1 <span class="nt">-f</span> image2pipe <span class="nt">-vcodec</span> mjpeg - | <span class="nb">wc</span> <span class="nt">-c</span>

<span class="c"># 可以看到最后输出的为：117118，即 114KB 左右。</span>
</code></pre></div></div>

<p>netperf 模拟 Player 请求下发直播数据，这里设置让 server 一次性下发 300KB 的数据，同时假设 Client 的 request 默认为 1KB,
测试 20分钟，命令如下：</p>

<p><strong>测试数据：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 1200  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

16384  131072 100      3000000  100.01      0.79
16384  131072
</code></pre></div></div>

<blockquote>
  <p>上述测试数据输出的 <code class="language-plaintext highlighter-rouge">Local /Remote</code> 可以看到在下面多出一行，分别表示的是 local 和 remote 的 socket send and recv buffer’s bytes。
最后一列 <code class="language-plaintext highlighter-rouge">Trans</code> 表示的便是在测试的这段时间内平均每秒钟可以执行了多少次请求，即 0.79 次，相当于 Qps，越大说明效率越高。</p>
</blockquote>

<h1 id="tcp-内核参数优化">TCP 内核参数优化：</h1>

<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数说明</a></p>

<h2 id="内核参数配置">内核参数配置</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@XXXLink64 ~]# sysctl <span class="nt">-a</span> | <span class="nb">grep</span> <span class="s2">"net</span><span class="se">\.</span><span class="s2">ipv4</span><span class="se">\.</span><span class="s2">tcp"</span>

<span class="c"># 下面 4 个参数不区分协议</span>
<span class="c"># 默认的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 接收窗口大小 （bytes）</span>
net.core.rmem_max <span class="o">=</span> 327680
<span class="c"># 默认的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_default <span class="o">=</span> 327680
<span class="c"># 最大的 socket 发送窗口大小 （bytes）</span>
net.core.wmem_max <span class="o">=</span> 3276800

<span class="c"># 在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，默认值是 1000</span>
net.core.netdev_max_backlog <span class="o">=</span> 3000

<span class="c"># 定义了系统中每一个端口最大的监听队列的长度，是个全局的参数</span>
net.core.somaxconn <span class="o">=</span> 2048

<span class="c"># 表示每个套接字所允许的最大缓冲区的大小</span>
net.core.optmem_max <span class="o">=</span> 81920

<span class="c"># 自动调整 tcp recv buffer</span>
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0

<span class="c"># 用于控制当服务器的监听队列（listen 队列）溢出时，是否向客户端发送 TCP 重置（RST）信号以终止连接</span>
net.ipv4.tcp_abort_on_overflow <span class="o">=</span> 0

<span class="c"># 内核中与 TCP 窗口大小相关的一个参数，它影响接收窗口的大小调整行为</span>
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1

net.ipv4.tcp_allowed_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_app_win <span class="o">=</span> 31

<span class="c"># 尽量合并包一起发送，减少发包数量。enable 了会增加延迟，建议关闭</span>
net.ipv4.kcp_autocorking <span class="o">=</span> 1

net.ipv4.tcp_available_congestion_control <span class="o">=</span> reno cubic bbr
net.ipv4.tcp_available_ulp <span class="o">=</span> 
net.ipv4.tcp_base_mss <span class="o">=</span> 1024
net.ipv4.tcp_challenge_ack_limit <span class="o">=</span> 1000
net.ipv4.tcp_comp_sack_delay_ns <span class="o">=</span> 1000000
net.ipv4.tcp_comp_sack_nr <span class="o">=</span> 44
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr
net.ipv4.tcp_dsack <span class="o">=</span> 1
net.ipv4.tcp_early_demux <span class="o">=</span> 1
net.ipv4.tcp_early_retrans <span class="o">=</span> 3
net.ipv4.tcp_ecn <span class="o">=</span> 2
net.ipv4.tcp_ecn_fallback <span class="o">=</span> 1
net.ipv4.tcp_fack <span class="o">=</span> 0
net.ipv4.tcp_fastopen <span class="o">=</span> 1
net.ipv4.tcp_fastopen_blackhole_timeout_sec <span class="o">=</span> 3600
net.ipv4.tcp_fastopen_key <span class="o">=</span> 5b1b3bb0-e9881f5a-8bf3fda0-1c410b36
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30
net.ipv4.tcp_frto <span class="o">=</span> 2
net.ipv4.tcp_fwmark_accept <span class="o">=</span> 0
net.ipv4.tcp_inherit_buffsize <span class="o">=</span> 1
net.ipv4.tcp_init_cwnd <span class="o">=</span> 15
net.ipv4.tcp_init_rto <span class="o">=</span> 1000
net.ipv4.tcp_invalid_ratelimit <span class="o">=</span> 500

<span class="c"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效</span>
net.ipv4.tcp_keepalive_time <span class="o">=</span> 7200
<span class="c"># 探测消息未获得响应时，重发该消息的间隔时间（秒）</span>
net.ipv4.tcp_keepalive_intvl <span class="o">=</span> 75
<span class="c"># 在认定TCP连接失效之前，最多发送多少个keepalive探测消息</span>
net.ipv4.tcp_keepalive_probes <span class="o">=</span> 9

net.ipv4.tcp_l3mdev_accept <span class="o">=</span> 0
net.ipv4.tcp_limit_output_bytes <span class="o">=</span> 1048576
net.ipv4.tcp_loss_init_cwnd <span class="o">=</span> 10
<span class="c"># 允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用</span>
net.ipv4.tcp_low_latency <span class="o">=</span> 0
net.ipv4.tcp_max_orphans <span class="o">=</span> 524288
net.ipv4.tcp_max_reordering <span class="o">=</span> 300
net.ipv4.tcp_max_syn_backlog <span class="o">=</span> 62144
net.ipv4.tcp_max_tw_buckets <span class="o">=</span> 6000
net.ipv4.tcp_mem <span class="o">=</span> 2621440      3932160 5242880
net.ipv4.tcp_min_rtt_wlen <span class="o">=</span> 300
net.ipv4.tcp_min_snd_mss <span class="o">=</span> 48
net.ipv4.tcp_min_tso_segs <span class="o">=</span> 2
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_mtu_probe_floor <span class="o">=</span> 48
net.ipv4.tcp_mtu_probing <span class="o">=</span> 0
net.ipv4.tcp_no_metrics_save <span class="o">=</span> 1
net.ipv4.tcp_notsent_lowat <span class="o">=</span> 8388608
net.ipv4.tcp_orphan_retries <span class="o">=</span> 0

net.ipv4.tcp_pacing_ca_ratio <span class="o">=</span> 120
net.ipv4.tcp_pacing_ss_ratio <span class="o">=</span> 200
net.ipv4.tcp_probe_interval <span class="o">=</span> 600
net.ipv4.tcp_probe_threshold <span class="o">=</span> 8
net.ipv4.tcp_proc_sched <span class="o">=</span> 1
net.ipv4.tcp_recovery <span class="o">=</span> 1
net.ipv4.tcp_reordering <span class="o">=</span> 5
net.ipv4.tcp_retrans_collapse <span class="o">=</span> 1
net.ipv4.tcp_retries1 <span class="o">=</span> 5
net.ipv4.tcp_retries2 <span class="o">=</span> 15
net.ipv4.tcp_rfc1337 <span class="o">=</span> 0
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 16384000
net.ipv4.tcp_rto_max <span class="o">=</span> 120
net.ipv4.tcp_rto_min <span class="o">=</span> 200
net.ipv4.tcp_rx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_sack <span class="o">=</span> 1
net.ipv4.tcp_slow_start_after_idle <span class="o">=</span> 0
net.ipv4.tcp_stdurg <span class="o">=</span> 0
net.ipv4.tcp_syn_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_retries <span class="o">=</span> 2
net.ipv4.tcp_synack_rto_interval <span class="o">=</span> 200

<span class="c"># 表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载</span>
net.ipv4.tcp_syncookies <span class="o">=</span> 1
net.ipv4.tcp_thin_linear_timeouts <span class="o">=</span> 0

<span class="c"># TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项</span>
net.ipv4.tcp_timestamps <span class="o">=</span> 1
net.ipv4.tcp_tso_win_divisor <span class="o">=</span> 3
net.ipv4.tcp_tw_ignore_syn_tsval_zero <span class="o">=</span> 1

<span class="c"># 表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 </span>
net.ipv4.tcp_tw_reuse <span class="o">=</span> 1
<span class="c"># 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡</span>
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30

<span class="c"># 能够更快地回收TIME-WAIT套接字</span>
net.ipv4.tcp_tw_recycle <span class="o">=</span> 1
net.ipv4.tcp_tw_timeout <span class="o">=</span> 60
net.ipv4.tcp_tx_skb_cache <span class="o">=</span> 0
net.ipv4.tcp_wan_timestamps <span class="o">=</span> 0
net.ipv4.tcp_window_scaling <span class="o">=</span> 1
net.ipv4.tcp_wmem <span class="o">=</span> 4096000     16384000        32768000
net.ipv4.tcp_workaround_signed_windows <span class="o">=</span> 0
</code></pre></div></div>

<h2 id="优化内容">优化内容</h2>

<blockquote>
  <p>以下均为仅优化单边的 Server 测参数。</p>
</blockquote>

<h3 id="bbr">BBR</h3>

<p>编辑 <code class="language-plaintext highlighter-rouge">/etc/sysctl.conf</code>，添加或修改如下参数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置 tcp 拥塞算法为 bbr</span>
net.ipv4.tcp_congestion_control <span class="o">=</span> bbr

</code></pre></div></div>

<p>使参数立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-p</span>
</code></pre></div></div>

<p><strong>测试结果</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~<span class="nv">$ </span>netperf <span class="nt">-H</span> 127.0.0.1  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 300  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,3000000
MIGRATED TCP Connect/Request/Response TEST from 0.0.0.0 <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to 127.0.0.1 <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

436600 87380  100      3000000  300.00      1.06
436600 87380
</code></pre></div></div>

<p>可以看到在开启了 bbr 拥塞算法后，<code class="language-plaintext highlighter-rouge">Trans</code> 由 0.79 升到了 1.06，有了明显的提升。
但是实际优化数据不会这么明显，因为线上环境我们只能开启 server 测的 bbr，而无法控制 client 同时开启。</p>

<h3 id="socketbuffer">SocketBuffer</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sysctl <span class="nt">-a</span> | egrep <span class="s2">"rmem|wmem|adv_win|moderate"</span>
net.core.rmem_default <span class="o">=</span> 327680
net.core.rmem_max <span class="o">=</span> 327680
net.core.wmem_default <span class="o">=</span> 327680
net.core.wmem_max <span class="o">=</span> 3276800
net.ipv4.tcp_adv_win_scale <span class="o">=</span> 1
net.ipv4.tcp_moderate_rcvbuf <span class="o">=</span> 1
net.ipv4.tcp_rmem <span class="o">=</span> 131072      1048576 49152000
net.ipv4.tcp_wmem <span class="o">=</span> 12288000    49152000        98304000
net.ipv4.udp_rmem_min <span class="o">=</span> 4096
net.ipv4.udp_wmem_min <span class="o">=</span> 4096
vm.lowmem_reserve_ratio <span class="o">=</span> 256   256     32      0       0
</code></pre></div></div>

<p><strong>测试结果对比</strong></p>

<ul>
  <li>上述默认配置，无调整 buffer</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.59
16384000 1048576
</code></pre></div></div>

<ul>
  <li>强制64KB buffer</li>
</ul>

<p>配置 net.ipv4.tcp_wmem 为 65536 后的测试结果 <code class="language-plaintext highlighter-rouge">sysctl -w net.ipv4.tcp_wmem="65536 65536 65536"</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>netperf <span class="nt">-H</span> 100.100.57.20  <span class="nt">-p</span> 1234 <span class="nt">-l</span> 600  <span class="nt">-t</span> TCP_CRR <span class="nt">--</span> <span class="nt">-r</span> 1000,300000
MIGRATED TCP Connect/Request/Response TEST from <span class="o">(</span>null<span class="o">)</span> <span class="o">(</span>0.0.0.0<span class="o">)</span> port 0 AF_INET to <span class="o">(</span>null<span class="o">)</span> <span class="o">()</span> port 0 AF_INET : demo
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

131072 131072 1000     300000  599.99      1.16
65535  1048576
</code></pre></div></div>

<p>可以看到之前配置了 64KB 的 send buffer 后，Trans 由 1.59 下降到了 1.16，有明显的下降，但是上述配置是将 min、default、max 均全部强行配置为 64KB，失去了动态伸缩的能力，如果仅配置 default 为 64KB，不限制最大值，则不受影响。</p>

<h3 id="tcp_fastopen">tcp_fastopen</h3>

<p>在上述配置中，tcp_fastopen 配置为 1，即仅开启 Client 的 fastopen，而未开启 server 测的 fastopen，不是最佳配置，需要调整为 3 同时开启 client 和 server 测的 fastopen。
tcp_fastopen 配置项说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tcp_fastopen - INTEGER
	Enable TCP Fast Open (RFC7413) to send and accept data in the opening
	SYN packet.

	The client support is enabled by flag 0x1 (on by default). The client
	then must use sendmsg() or sendto() with the MSG_FASTOPEN flag,
	rather than connect() to send data in SYN.

	The server support is enabled by flag 0x2 (off by default). Then
	either enable for all listeners with another flag (0x400) or
	enable individual listeners via TCP_FASTOPEN socket option with
	the option value being the length of the syn-data backlog.

	The values (bitmap) are

	=====  ======== ======================================================
	  0x1  (client) enables sending data in the opening SYN on the client.
	  0x2  (server) enables the server support, i.e., allowing data in
			a SYN packet to be accepted and passed to the
			application before 3-way handshake finishes.
	  0x4  (client) send data in the opening SYN regardless of cookie
			availability and without a cookie option.
	0x200  (server) accept data-in-SYN w/o any cookie option present.
	0x400  (server) enable all listeners to support Fast Open by
			default without explicit TCP_FASTOPEN socket option.
	=====  ======== ======================================================

</code></pre></div></div>

<h2 id="结论">结论</h2>

<p>在目前环境中的内核配置中，对首开有明显影响的只有三个参数：</p>
<ul>
  <li>1、BBR 的拥塞算法；</li>
  <li>2、TCP 的 send buffer 最大值要足够大；</li>
  <li>3、开启 tcp_fastopen 需要开启 server 测，至少为 2。</li>
</ul>

<h1 id="路由优化记录">路由优化记录</h1>

<p>直播片源选用 3.4Mbps 的码率，播放器选择 ffplay 进行拉取，在发送端（直播服务器）通过 tcpdump 抓包，对比查看发送 1MB 数据所耗费的时间线，这里是局域网环境，所以 lastmile 的带宽不是瓶颈。</p>

<p>Tcp 的 initcwnd 默认值为 10，倘若设置过大会造成对网络的冲击，根据经验选择<code class="language-plaintext highlighter-rouge">默认配置 10</code> 与 <code class="language-plaintext highlighter-rouge">40</code> 两者之间进行对比。</p>

<h2 id="环境准备-1">环境准备</h2>

<p>首先在发送端直播服务器上为指定网卡增加 100ms 的主动延迟，以放大数据影响，方便对比结果。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 增加 100ms 的固定延迟
$ sudo tc qdisc change dev eno1 root netem delay 100ms
  
# ping 验证
$ ping 100.100.32.108
PING 100.100.32.108 (100.100.32.108) 56(84) bytes of data.
64 bytes from 100.100.32.108: icmp_seq=1 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=2 ttl=63 time=103 ms
64 bytes from 100.100.32.108: icmp_seq=3 ttl=63 time=104 ms
64 bytes from 100.100.32.108: icmp_seq=4 ttl=63 time=103 ms
^C
--- 100.100.32.108 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3003ms
rtt min/avg/max/mdev = 102.763/103.307/103.550/0.322 ms
</code></pre></div></div>

<h2 id="case1">Case1</h2>

<blockquote>
  <p>未修改 tcp initcwnd 的测试场景。</p>
</blockquote>

<ul>
  <li>在发送端（直播服务器）测抓包：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_10cwnd_100msdelay.pcap
</code></pre></div>    </div>
  </li>
  <li>在远端进行拉流（100.100.32.108）：</li>
</ul>

<p>  拉取播放 10秒左右即可。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffplay http://100.100.57.20:8080/ztest/A123.flv\?domain\=h3.xxx.com
</code></pre></div></div>

<ul>
  <li>Wireshark 分析：</li>
</ul>

<p>  可以看到如下截图，接收 1 * 10^6 即1MB的数据时大约耗时在 900ms。
<img src="/assets/img/blog/tcp_10cwnd_100ms.png" alt="TCP 10 INITCWND 分析图" /></p>

<h2 id="case2">Case2</h2>

<p>调整 initcwnd 为 40，通过 ip route 进行调整。</p>

<ul>
  <li>首先通过 <code class="language-plaintext highlighter-rouge">sudo ip route show</code> 进行查看：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 10
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 10
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 10
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>然后依次对各 route 进行配置：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip route change 100.100.56.254 dev eno1 scope link initcwnd 40
sudo ip route change via 100.100.56.254 dev eno1  initcwnd 40
sudo ip route change 100.100.56.0/23 dev eno1 proto static scope link  initcwnd 40
</code></pre></div></div>

<ul>
  <li>配置后如下：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ~$ sudo ip route show
default via 100.100.56.254 dev eno1 initcwnd 40
default via 100.100.56.254 dev eno1 proto static metric 100
default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
100.100.56.0/23 dev eno1 proto static scope link initcwnd 40
100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
100.100.56.254 dev eno1 scope link initcwnd 40
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</code></pre></div></div>

<ul>
  <li>在发送端（直播服务器）测抓包</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo tcpdump -i eno1 -s 1500 tcp and host 100.100.32.108 and port 8080 -w tcp_40cwnd_100msdelay.pcap
</code></pre></div></div>

<ul>
  <li>Wireshark 分析</li>
</ul>

<p>  可以看到 init cwnd 为 40 后，在 tcp 的慢启动状态发包变得很激进，接收端接收 1MB 的数据大约为 550ms，节省了大约 350ms，大约 3 个 rtt 的时间。
<img src="/assets/img/blog/tcp_40cwnd_100ms.png" alt="TCP 40 INITCWND 分析图" /></p>

<h2 id="结论-1">结论</h2>

<p>  如上，调整 INITCWND 为 40后，在秒开数据为 1MB 的场景中，大约可为秒开节省 3 个左右的 rtt 时间，下一步可以在线上进行初步的验证，可逐步放开该值为 20、30、40，在数据不断的优化的情况下降低调整风险，逐步实现优化。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><category term="Protocol" /><summary type="html"><![CDATA[当前公司直播项目拨测的秒开指标远未达到预期，经过数据对比和分析，发现在拨测节点 Player 与边缘节点之间的 Lastmile 网络质量上存在比较大的问题，由于目前 Player 的拉流协议使用的是基于 TCP 的标准协议(HTTP-FLV），并且 Player 位于第三方平台，不受控制，所以重点只能通过单边优化公司边缘节点与 Player 之间的 TCP 连接参数，尽量加快 TCP 的建连和数据下发的速度。]]></summary></entry><entry><title type="html">Ubuntu24.04 配置静态 IP</title><link href="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html" rel="alternate" type="text/html" title="Ubuntu24.04 配置静态 IP" /><published>2025-01-08T00:00:00+00:00</published><updated>2025-01-08T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/ubuntu24.04-static-ip</id><content type="html" xml:base="https://gbcpp.github.io/notes/ubuntu24.04-static-ip.html"><![CDATA[<blockquote>
  <p>公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。</p>
</blockquote>

<blockquote>
  <p>如下所有操作均使用 <code class="language-plaintext highlighter-rouge">root</code> 权限。</p>
</blockquote>

<blockquote>
  <p>记录该过程主要是因为想当然的以为网关地址就是同网段的 .1，导致配置后网络不通，通过 <code class="language-plaintext highlighter-rouge">ip route</code> 查询后方可。</p>
</blockquote>

<h1 id="查看当前-ip">查看当前 IP</h1>

<p>系统默认开启 DHCP，自动获取 IP，且查看 IP 不再默认支持<code class="language-plaintext highlighter-rouge">ifconfig</code>命令，需要 <code class="language-plaintext highlighter-rouge">ip addr show</code>进行查看。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 2c:f0:5d:2b:11:31 brd ff:ff:ff:ff:ff:ff
    altname enp0s31f6
    inet 100.100.57.20/23 brd 100.100.57.255 scope global noprefixroute eno1
       valid_lft forever preferred_lft forever
</code></pre></div></div>

<p>可以看到自己的 IP 地址为<code class="language-plaintext highlighter-rouge">100.100.57.20</code>。</p>

<h1 id="配置静态-ip">配置静态 IP</h1>

<p>ubuntu 18 以后版本开始使用<code class="language-plaintext highlighter-rouge">netplan</code>配置网卡信息，查看当前系统目录<code class="language-plaintext highlighter-rouge">/etc/netplan/</code>下具体配置文件名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls /etc/netplan
$ 50-cloud-init.yaml
</code></pre></div></div>

<blockquote>
  <p>编辑前建议先进行备份。</p>
</blockquote>

<p><strong>默认配置：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        eno1:
            dhcp4: true
    version: 2
</code></pre></div></div>

<p><strong>查询路由</strong></p>

<p>通过<code class="language-plaintext highlighter-rouge">ip route</code>获取当前路由地址：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ip route
$ default via 100.100.56.254 dev eno1 proto static metric 100
$ default via 100.100.56.254 dev eno1 proto dhcp src 100.100.57.20 metric 100
$ 100.100.56.0/23 dev eno1 proto kernel scope link src 100.100.57.20 metric 100
</code></pre></div></div>

<p>可以看到默认路由地址为<code class="language-plaintext highlighter-rouge">100.100.56.254</code>。</p>

<p><strong>配置文件</strong></p>

<p><code class="language-plaintext highlighter-rouge">vim /etc/netplan/50-cloud-init.yaml</code>进行编辑,最终内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    version: 2
    ethernets:
        eno1:
            dhcp4: no
            addresses:
             - 100.100.57.20/23
            routes:
              - to: default
                via: 100.100.56.254
            nameservers:
              addresses:
                - 8.8.8.8
                - 8.8.4.4
</code></pre></div></div>

<blockquote>
  <p>注意缩进的格式和位置，不能使用<code class="language-plaintext highlighter-rouge">tab</code>只能用空格进行缩进。</p>
</blockquote>

<p><strong>应用</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netplan apply
</code></pre></div></div>

<p>如果没有格式错误的话，便没有任何输出，否则提示格式错误。
至此配置成功，通过<code class="language-plaintext highlighter-rouge">ip addr show</code>查看确认。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[公司默认给配置的 2016 年的 MBP，实在忍受不了退而求其次申请了一台台式机作为开发机、工作站使用。安装的 Ubuntu24.04 LTS 系统需要配置为静态 IP 远程连接上去进行工作。]]></summary></entry><entry><title type="html">webtransport-go 在直播场景下的优化</title><link href="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html" rel="alternate" type="text/html" title="webtransport-go 在直播场景下的优化" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-01-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream</id><content type="html" xml:base="https://gbcpp.github.io/protocol/webtransport-go-optimze-for-livestream.html"><![CDATA[<h1 id="背景">背景</h1>
<p>公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。</p>

<blockquote>
  <p>本人经历 2024年 11月变动以后，刚来公司不久，周边同事基本都以 golang 语言开发为主，且基本没有协议的优化经验，只能选择开源项目进行优化， B本人进入公司的时机也不好，该项目已经选定该方案，并且开始上线进行灰度测试，无法推翻重来。
且对比 Tcp 来看，webtransport-go 带来的性能消耗是 tcp 的 5 倍以上。</p>
</blockquote>

<h2 id="为什么不直接使用-quic-go">为什么不直接使用 quic-go</h2>

<p>因为 quic 虽然也是可靠传输，但是 quic 暂不支持通过 Url 来携带业务测参数，如：vhost、token 等的。</p>

<h1 id="初始化">初始化</h1>
<h2 id="代码下载">代码下载</h2>

<p><code class="language-plaintext highlighter-rouge">git clone git@github.com:quic-go/webtransport-go.git</code></p>

<p>拉取相关依赖仓库代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 进入代码目录
cd webtransport-go

# 通过 build 触发代码拉取
go build webtransport_test.go
</code></pre></div></div>

<p>Golang 默认将代码存放在<code class="language-plaintext highlighter-rouge">$GOPATH</code>目录下，我的<code class="language-plaintext highlighter-rouge">GOPATH</code>环境变量配置为 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go</code>，那么拉取的依赖仓库 <code class="language-plaintext highlighter-rouge">quic-go</code> 的存放目录就是 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1</code>，为了方便在 VSCode 中查看代码，在 VSCode 的 WorkSpace 空白处通过右键选择：<code class="language-plaintext highlighter-rouge">Add Folder to WorkSpace</code>，选择上述目录，即可一起查看 <code class="language-plaintext highlighter-rouge">quic-go</code> 相关的代码，如下：
<img src="/assets/img/blog/vscode-go.jpg" alt="" /></p>

<h2 id="quic-go">Quic-go</h2>

<p>Quic-go 作为 webtransport-go 的依赖仓库，提供 quic 的基础传输能力，但是其提供的传输配置能力非常有限，特别是作为发送端时，一些基础的 CWnd、Burst、Ack 等参数均不支持配置，接口文件为：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/interface.go</code></p>

<p>quic-go 内部相关参数主要位于：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/protocol.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/params.go</code></p>

<h1 id="优化项">优化项</h1>

<ul>
  <li>初始化发送包数：</li>
</ul>

<p>文件：<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code> 中指定
<code class="language-plaintext highlighter-rouge">const maxBurstSizePackets = 10</code>，在直播场景，I 帧切片后（1200Bytes/pkt）基本都会超过 10 片，建议配置为 20~30，具体视业务场景中首帧的切换大小，但也不宜过高，控制在 30 以内。
该配置项生效后对秒开的影响较小，属于毫秒级别，原来可能受 pacer 控制在几个 timerGraulariry 中将一个关键帧发送完，该配置的理想效果是减少这几个 timerGraulariry 的延迟。</p>

<ul>
  <li>握手超时时间：
应用层建议也是用 2 秒的配置。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const DefaultHandshakeIdleTimeout = 5 * time.Second
// 建议修改为 2 或者 3 秒，业务测可以快速重连，减少等待时间
const DefaultHandshakeIdleTimeout = 2 * time.Second
</code></pre></div></div>

<ul>
  <li>定时器精度</li>
</ul>

<p>最好是从系统中获取自己的定时器精度（一般是4ms），不建议使用 1 ms 这种精度，过于高频，无效的 cpu 消耗。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const TimerGranularity = time.Millisecond
// 建议值：动态获取系统定时器精度，或者 hardcode 为 4ms 或者 10ms
const TimerGranularity = 4 * time.Millisecond
</code></pre></div></div>

<ul>
  <li>转发模式</li>
</ul>

<p>目前业务集成方在回源时，虽然传输协议使用的是流式传输，但是边缘节点在接收到分片数据后并不会立即进行转发，而是在组装成一个完整的帧以后再一次性进行发送，这样做是为了内部各种封装格式的转换，但是也存在明显的弊端，即在没有收到完整的关键帧以前，不会向 Player 发送任何数据，被回源的关键帧阻塞，间接的增加了首开的延迟。</p>

<p>可优化选项：比如回源的协议与 Player 请求的协议相同，即均为 HTTP-FLV，那么便不再需要进行完整帧的转封装，而直接进行分片的透明转发，同时边缘节点也异步的 cache 分片数据进行组帧操作，转封装分发给其它请求的协议。</p>

<h1 id="faq">FAQ</h1>

<h2 id="webtransport-是否是整帧的收发">Webtransport 是否是整帧的收发？</h2>

<p>不是，websocket 在发送大的数据帧时，会通过 FIN 标记位是否为 1 标记为该 Frame 是否结束，而 WebTransport 中是基于流的传输，需要应用层自行组装完整的数据帧。
<a href="https://www.ietf.org/archive/id/draft-ietf-webtrans-overview-05.html#name-conventions-and-definitions-8">ref link</a></p>

<blockquote>
  <p>A stream is a sequence of bytes that is reliably delivered to the receiving application in the same order as it was transmitted by the sender. Streams can be of arbitrary length, and therefore cannot always be buffered entirely in memory. WebTransport protocols and APIs are expected to provide partial stream data to the application before the stream has been entirely received.</p>
</blockquote>

<h2 id="bbr-sender-配置-startup-的较大带宽但是-max-burst-send-packets-number-却较小能将关键帧的几个切片一次性发送出去吗">BBR sender 配置 startup 的较大带宽，但是 max burst send packets number 却较小，能将关键帧的几个切片一次性发送出去吗？</h2>

<p><code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        p := &amp;pacer{
                maxDatagramSize: initialMaxDatagramSize,
                adjustedBandwidth: func() uint64 {
                        // Bandwidth is in bits/s. We need the value in bytes/s.
                        bw := uint64(getBandwidth() / BytesPerSecond)
                        // Use a slightly higher value than the actual measured bandwidth.
                        // RTT variations then won't result in under-utilization of the congestion window.
                        // Ultimately, this will result in sending packets as acknowledgments are received rather than when timers fire,
                        // provided the congestion window is fully utilized and acknowledgments arrive at regular intervals.
                        return bw * 5 / 4
                },
        }
        p.budgetAtLastSent = p.maxBurstSize()
        return p
}
</code></pre></div></div>

<p>而在初始化时，由于没有 smoothedRTT 的有效值，所以初始化为 <code class="language-plaintext highlighter-rouge">infBandwidth</code> (UINT64_MAX)，
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/bbr_sender.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (b *bbrSender) bandwidthEstimate() Bandwidth {
        srtt := b.rttStats.SmoothedRTT()
        if srtt == 0 {
                // If we haven't measured an rtt, the bandwidth estimate is unknown.
                return infBandwidth
        }
        bw := b.maxBandwidth.GetBest()
        if bw == 0 {
                return infBandwidth
        }
        return bw
}
</code></pre></div></div>

<p>虽然初始化的 bandwidth 比较大，但是 pacer 在发送数据时依然会受限于 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 的配置，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *pacer) maxBurstSize() protocol.ByteCount {
        return utils.Max(
                protocol.ByteCount(uint64((protocol.MinPacingDelay+protocol.TimerGranularity).Nanoseconds())*p.adjustedBandwidth())/1e9,
                maxBurstSizePackets*p.maxDatagramSize,
        )
}
</code></pre></div></div>

<p>所以建议将 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 值配置为 20 ～ 30 之间，根据业务场景，尽量让首帧（I Frame）的所有切片能够一次性发送出去，但是也不宜过高，避免数据突发导致网络拥塞丢包。</p>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><summary type="html"><![CDATA[背景 公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。]]></summary></entry><entry><title type="html">移植裁剪 srs 到 ARMv64 系统设备</title><link href="https://gbcpp.github.io/notes/srs-on-arm.html" rel="alternate" type="text/html" title="移植裁剪 srs 到 ARMv64 系统设备" /><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/srs-on-arm</id><content type="html" xml:base="https://gbcpp.github.io/notes/srs-on-arm.html"><![CDATA[<h1 id="srs-版本">SRS 版本</h1>

<p>srs 源码选择较新的 stable 版本：v5.0-r3</p>

<p><strong>代码拉取</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --branch v5.0-r3 https://github.com/ossrs/srs.git
</code></pre></div></div>

<p><strong>编译</strong></p>

<p>已知设备系统：ARMv8 指令集架构的 Debian，此次测试选择在 Debian 系统下部署 srs 服务进行测试。</p>

<p>使用 docker 进行编译，首先保证开发机上有 docker 服务，编译命令会自行拉取 aarch64 专用编译镜像并编译：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd srs/trunk
$ docker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \
    bash -c "./configure --srt=off --rtc=off --ffmpeg-fit=off --static=on \
        --sanitizer=off --sanitizer-static=off --sanitizer-log=off &amp;&amp; make -j4"
 

# 查看 srs 二进制文件
$ ls -sh objs/srs
</code></pre></div></div>

<h1 id="测试环境">测试环境</h1>

<p>基于当前测试条件，此次测试选择将 srs 服务部署在 Debian 系统的小盒子中进行测试。</p>

<p>Debian 系统小盒子性能如下：</p>
<ul>
  <li>CPU：4 核 4 线程，主频 1.5GHz</li>
  <li>Mem：2GB</li>
  <li>Disk：8GB</li>
</ul>

<p>观众端：</p>

<p>Mac 下 Shell 脚本启动 10 路 ffplay 进行播放，启动命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash repeat_command.sh "ffplay https://ossrs.com:8088/live/livestream.flv"  10
</code></pre></div></div>

<p>repeat_command.sh 脚本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
 
if [ $# -lt 2 ]; then
    echo "Usage: $0 &lt;command&gt; &lt;times&gt;"
    exit 1
fi
 
# 获取参数
command=$1
times=$2
 
# 检查 times 是否是数字
if ! [[ $times =~ ^[0-9]+$ ]]; then
    echo "Error: &lt;times&gt; must be a positive integer."
    exit 1
fi
 
# 循环执行命令
for ((i=1; i&lt;=times; i++)); do
    echo "Executing command '$command' in the background: iteration $i"
    eval "$command &amp;"
done
 
echo "All commands have been executed in the background."
</code></pre></div></div>

<h1 id="srs-配置">SRS 配置</h1>

<p>使用了自签名证书 ossrs.com</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen              1935;
max_connections     1000;
daemon              off;
srs_log_tank        console;
 
http_api {
    enabled         on;
    listen          1985;
}
 
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
 
    https {
        enabled on;
        listen 8088;
        key ./ossrs.key;
        cert ./ossrs.crt;
    }
}
vhost __defaultVhost__ {
    http_remux {
        enabled     on;
        mount       [vhost]/[app]/[stream].flv;
    }
    ingest livestream {
        enabled      on;
        input {
            type    stream;
        url     http://100.100.34.14:8080/live/livestream.flv;
        }
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled          off;
            output          rtmp://0.0.0.0:[port]/live/livestream?vhost=[vhost];
        }
    }
}
</code></pre></div></div>

<h1 id="测试结果">测试结果</h1>

<p>测试条件有限，目前仅测试了如下两种场景和数据，仅供参考。</p>

<p>测试场景：为该 SRS 注入一路 stream 做为源，然后远端从该 SRS 通过 HTTPS-FLV 拉取十路该流。</p>

<p><img src="/assets/img/blog/srs_perf.jpg" alt="" /></p>

<h1 id="srs-支持sni和多证书">SRS 支持SNI和多证书</h1>

<p>目前 srs 仅支持单个 HTTPS Server 的部署，需要自行扩展支持 SNI 的读取、选择指定证书下发的实现，TLS 封装代码在 SrsHttpxConn 类中。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[SRS 版本]]></summary></entry><entry><title type="html">C++ 程序输出当前堆栈</title><link href="https://gbcpp.github.io/notes/print_stacktrace.html" rel="alternate" type="text/html" title="C++ 程序输出当前堆栈" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/print_stacktrace</id><content type="html" xml:base="https://gbcpp.github.io/notes/print_stacktrace.html"><![CDATA[<p>将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。
互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。</p>

<h2 id="头文件">头文件</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h2 id="源码">源码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Utils</span><span class="o">::</span><span class="n">PrintStackTrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxFrames</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxPrettyFunctionNameLength</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">[</span><span class="n">kMaxFrames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 获取当前堆栈中的地址</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrlist</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"StackTraces: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// 解析地址为函数名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">symbollist</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

  <span class="c1">// 解析函数名的更多信息</span>
  <span class="kt">size_t</span> <span class="n">funcNameSize</span> <span class="o">=</span> <span class="n">kMaxPrettyFunctionNameLength</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">funcNameSize</span><span class="p">));</span>

  <span class="c1">// 跳过第一个元素（即本身）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 解析符号名称及偏移量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginName</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beginName</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span> <span class="o">&amp;&amp;</span> <span class="n">endOffset</span> <span class="o">&amp;&amp;</span> <span class="n">beginName</span> <span class="o">&lt;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">beginName</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">beginOffset</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

      <span class="c1">// 解码并打印函数名称</span>
      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span>
          <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">beginName</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funcNameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果无法解析，直接输出原始符号信息</span>
      <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">funcName</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">symbollist</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="编译">编译</h2>

<p><code class="language-plaintext highlighter-rouge">ldflags</code> 参数一定要指定 <code class="language-plaintext highlighter-rouge">-ldynamiclib</code> 告诉链接器将所有符号添加到动态符号表中。这使得运行时调试工具（如 GDB）和运行时函数（如 backtrace）可以访问这些符号。
主要用于调试和诊断目的，以便在运行时能够获取更详细的堆栈信息和符号解析。</p>

<p>对性能几乎没有影响，但是由于增加了符号表信息，会增加包体大小。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。 互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。]]></summary></entry><entry><title type="html">温故而知新之-C++</title><link href="https://gbcpp.github.io/notes/learning-cpp-notes.html" rel="alternate" type="text/html" title="温故而知新之-C++" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/learning-cpp-notes</id><content type="html" xml:base="https://gbcpp.github.io/notes/learning-cpp-notes.html"><![CDATA[<h2 id="指针的退化及如何避免">指针的退化及如何避免</h2>

<p>在C++中，”指针退化”是指当数组作为函数参数传递时，它会”退化”为指向第一个元素的指针。这是因为在C++中，数组并不知道它们自己的大小，所以当你把一个数组作为参数传递给一个函数时，函数并不知道这个数组的大小，只知道它的起始地址。</p>

<p>例如，假设你有一个函数<code class="language-plaintext highlighter-rouge">void foo(int arr[])</code>，当你传递一个数组给这个函数时，例如<code class="language-plaintext highlighter-rouge">int arr[10]; foo(arr);</code>，函数<code class="language-plaintext highlighter-rouge">foo</code>实际上看到的是一个指向<code class="language-plaintext highlighter-rouge">arr</code>的第一个元素的指针，而不是整个数组。</p>

<p>要防止指针退化，有几种方法：</p>

<ol>
  <li>
    <p>使用标准库容器，如<code class="language-plaintext highlighter-rouge">std::vector</code>或<code class="language-plaintext highlighter-rouge">std::array</code>。这些容器知道它们自己的大小，因此不会发生指针退化。例如： <code class="language-plaintext highlighter-rouge">void foo(std::vector&lt;int&gt;&amp; arr)</code>。</p>
  </li>
  <li>
    <p>使用模板函数，使函数可以接受数组的引用，并且能够保留数组的大小信息。例如： <code class="language-plaintext highlighter-rouge">template&lt;size_t N&gt; void foo(int (&amp;arr)[N])</code>。</p>
  </li>
  <li>
    <p>传递数组的大小作为另一个参数。例如： <code class="language-plaintext highlighter-rouge">void foo(int* arr, size_t size)</code>。这样，即使数组退化为指针，函数仍然可以知道数组的大小。</p>
  </li>
</ol>

<h2 id="引用与指针的区别">引用与指针的区别</h2>

<p>在C++中，指针和引用都可以用于间接引用其他对象。然而，它们在语法和行为上有一些关键的不同：</p>

<ol>
  <li>
    <p>初始化：引用在创建时需要初始化，并且一旦初始化后就不能改变引用的目标，也就是说它始终引用最初赋给它的对象。而指针可以在任何时间指向任何对象或者NULL。</p>
  </li>
  <li>
    <p>空值：指针可以为NULL，表示它不指向任何对象。而引用必须始终引用一个有效的对象，不能有NULL引用。</p>
  </li>
  <li>
    <p>间接访问：使用指针时，需要使用解引用运算符(*)来访问它指向的对象，而引用则可以像普通变量那样直接使用。</p>
  </li>
  <li>
    <p>支持的操作：指针支持更多的操作，例如指针算术（即增加或减少指针的值，以指向内存中的不同位置）。引用则不能进行这种操作。</p>
  </li>
  <li>
    <p>内存占用：引用实际上并不占用任何内存，它只是一个别名。而指针是一个实际的变量，它占用内存空间并存储一个地址值。</p>
    <blockquote>
      <p>但引用在程序中并不是不占用任何字节，引用本质上就是一个常量指针（constant pointer）。它在内存中占据的空间和指针一样，通常是 4 字节（在 32 位系统）或 8 字节（在 64 位系统）。然而，引用本身并不存储任何值，它只是一个别名，代表它引用的对象。在某些优化的情况下，如果引用没有被用作一个对象的别名（也就是说，它被直接用于访问该对象），编译器可能会优化掉引用，使其不占用任何内存空间。但是，这种优化并不是在所有情况下都会发生。所以，说引用不占用内存空间并不完全准确，实际情况取决于编译器的优化和引用的使用方式。</p>
    </blockquote>
  </li>
</ol>

<p>总的来说，引用在某些情况下可以提供更简洁的语法，而指针则提供了更大的灵活性和控制能力。选择使用哪一个取决于具体的编程需求。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[指针的退化及如何避免]]></summary></entry></feed>