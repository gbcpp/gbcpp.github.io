<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2025-01-01T04:05:23+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">C++ 程序输出当前堆栈</title><link href="https://gbcpp.github.io/print_stacktrace.html" rel="alternate" type="text/html" title="C++ 程序输出当前堆栈" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/print_stacktrace</id><content type="html" xml:base="https://gbcpp.github.io/print_stacktrace.html"><![CDATA[<p>将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。
互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。</p>

<h2 id="头文件">头文件</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h2 id="源码">源码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Utils</span><span class="o">::</span><span class="n">PrintStackTrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxFrames</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxPrettyFunctionNameLength</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">[</span><span class="n">kMaxFrames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 获取当前堆栈中的地址</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrlist</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"StackTraces: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// 解析地址为函数名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">symbollist</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

  <span class="c1">// 解析函数名的更多信息</span>
  <span class="kt">size_t</span> <span class="n">funcNameSize</span> <span class="o">=</span> <span class="n">kMaxPrettyFunctionNameLength</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">funcNameSize</span><span class="p">));</span>

  <span class="c1">// 跳过第一个元素（即本身）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 解析符号名称及偏移量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginName</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beginName</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span> <span class="o">&amp;&amp;</span> <span class="n">endOffset</span> <span class="o">&amp;&amp;</span> <span class="n">beginName</span> <span class="o">&lt;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">beginName</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">beginOffset</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

      <span class="c1">// 解码并打印函数名称</span>
      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span>
          <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">beginName</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funcNameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果无法解析，直接输出原始符号信息</span>
      <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">funcName</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">symbollist</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="编译">编译</h2>

<p><code class="language-plaintext highlighter-rouge">ldflags</code> 参数一定要指定 <code class="language-plaintext highlighter-rouge">-ldynamiclib</code> 告诉链接器将所有符号添加到动态符号表中。这使得运行时调试工具（如 GDB）和运行时函数（如 backtrace）可以访问这些符号。
主要用于调试和诊断目的，以便在运行时能够获取更详细的堆栈信息和符号解析。</p>

<p>对性能几乎没有影响，但是由于增加了符号表信息，会增加包体大小。</p>]]></content><author><name>Mr Chen</name></author><category term="C++" /><summary type="html"><![CDATA[将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。 互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。]]></summary></entry><entry><title type="html">温故而知新之-C++</title><link href="https://gbcpp.github.io/learning-cpp-notes.html" rel="alternate" type="text/html" title="温故而知新之-C++" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://gbcpp.github.io/learning-cpp-notes</id><content type="html" xml:base="https://gbcpp.github.io/learning-cpp-notes.html"><![CDATA[<h2 id="指针的退化及如何避免">指针的退化及如何避免</h2>

<p>在C++中，”指针退化”是指当数组作为函数参数传递时，它会”退化”为指向第一个元素的指针。这是因为在C++中，数组并不知道它们自己的大小，所以当你把一个数组作为参数传递给一个函数时，函数并不知道这个数组的大小，只知道它的起始地址。</p>

<p>例如，假设你有一个函数<code class="language-plaintext highlighter-rouge">void foo(int arr[])</code>，当你传递一个数组给这个函数时，例如<code class="language-plaintext highlighter-rouge">int arr[10]; foo(arr);</code>，函数<code class="language-plaintext highlighter-rouge">foo</code>实际上看到的是一个指向<code class="language-plaintext highlighter-rouge">arr</code>的第一个元素的指针，而不是整个数组。</p>

<p>要防止指针退化，有几种方法：</p>

<ol>
  <li>
    <p>使用标准库容器，如<code class="language-plaintext highlighter-rouge">std::vector</code>或<code class="language-plaintext highlighter-rouge">std::array</code>。这些容器知道它们自己的大小，因此不会发生指针退化。例如： <code class="language-plaintext highlighter-rouge">void foo(std::vector&lt;int&gt;&amp; arr)</code>。</p>
  </li>
  <li>
    <p>使用模板函数，使函数可以接受数组的引用，并且能够保留数组的大小信息。例如： <code class="language-plaintext highlighter-rouge">template&lt;size_t N&gt; void foo(int (&amp;arr)[N])</code>。</p>
  </li>
  <li>
    <p>传递数组的大小作为另一个参数。例如： <code class="language-plaintext highlighter-rouge">void foo(int* arr, size_t size)</code>。这样，即使数组退化为指针，函数仍然可以知道数组的大小。</p>
  </li>
</ol>

<h2 id="引用与指针的区别">引用与指针的区别</h2>

<p>在C++中，指针和引用都可以用于间接引用其他对象。然而，它们在语法和行为上有一些关键的不同：</p>

<ol>
  <li>
    <p>初始化：引用在创建时需要初始化，并且一旦初始化后就不能改变引用的目标，也就是说它始终引用最初赋给它的对象。而指针可以在任何时间指向任何对象或者NULL。</p>
  </li>
  <li>
    <p>空值：指针可以为NULL，表示它不指向任何对象。而引用必须始终引用一个有效的对象，不能有NULL引用。</p>
  </li>
  <li>
    <p>间接访问：使用指针时，需要使用解引用运算符(*)来访问它指向的对象，而引用则可以像普通变量那样直接使用。</p>
  </li>
  <li>
    <p>支持的操作：指针支持更多的操作，例如指针算术（即增加或减少指针的值，以指向内存中的不同位置）。引用则不能进行这种操作。</p>
  </li>
  <li>
    <p>内存占用：引用实际上并不占用任何内存，它只是一个别名。而指针是一个实际的变量，它占用内存空间并存储一个地址值。</p>
    <blockquote>
      <p>但引用在程序中并不是不占用任何字节，引用本质上就是一个常量指针（constant pointer）。它在内存中占据的空间和指针一样，通常是 4 字节（在 32 位系统）或 8 字节（在 64 位系统）。然而，引用本身并不存储任何值，它只是一个别名，代表它引用的对象。在某些优化的情况下，如果引用没有被用作一个对象的别名（也就是说，它被直接用于访问该对象），编译器可能会优化掉引用，使其不占用任何内存空间。但是，这种优化并不是在所有情况下都会发生。所以，说引用不占用内存空间并不完全准确，实际情况取决于编译器的优化和引用的使用方式。</p>
    </blockquote>
  </li>
</ol>

<p>总的来说，引用在某些情况下可以提供更简洁的语法，而指针则提供了更大的灵活性和控制能力。选择使用哪一个取决于具体的编程需求。</p>]]></content><author><name>Mr Chen</name></author><category term="C++" /><summary type="html"><![CDATA[指针的退化及如何避免]]></summary></entry><entry><title type="html">面向学习的三种人</title><link href="https://gbcpp.github.io/learning-oriented.html" rel="alternate" type="text/html" title="面向学习的三种人" /><published>2024-04-02T00:00:00+00:00</published><updated>2024-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/learning-oriented</id><content type="html" xml:base="https://gbcpp.github.io/learning-oriented.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者</p>
</blockquote>

<h2 id="1-犯人">1. 犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="2-过客">2. 过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="3-探索者">3. 探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者]]></summary></entry><entry><title type="html">Blog title</title><link href="https://gbcpp.github.io/learn/blog-templete.html" rel="alternate" type="text/html" title="Blog title" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/learn/blog-templete</id><content type="html" xml:base="https://gbcpp.github.io/learn/blog-templete.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者。</p>
</blockquote>

<h2 id="犯人">犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="过客">过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="探索者">探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="learn" /><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者。]]></summary></entry><entry><title type="html">NeoVim 安装配置记录</title><link href="https://gbcpp.github.io/notes/neovim.html" rel="alternate" type="text/html" title="NeoVim 安装配置记录" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/neovim</id><content type="html" xml:base="https://gbcpp.github.io/notes/neovim.html"><![CDATA[<blockquote>
  <p>安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。</p>
</blockquote>

<h2 id="windows-wsl-ubuntu">Windows WSL Ubuntu</h2>

<p>  WSL 下 Ubuntu 子系统的安装与原生的 Ubuntu 系统安装有所不同，主要是字体的配置方式上有所区别。</p>

<h3 id="install-neovim">Install NeoVim</h3>

<p>  我选择手动下载 NeoVim，这样可以安装官方最新版本，这里选择目前官方的最新版本 0.10.0，依次执行以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/tools
<span class="nb">cd</span> ~/tools
wget https://github.com/neovim/neovim/releases/download/v0.10.0/nvim-linux64.tar.gz
<span class="nb">tar </span>xzf nvim-linux64.tar.gz
</code></pre></div></div>

<p>上面下载的 <code class="language-plaintext highlighter-rouge">nvim-linux64.tar.gz</code> 为 NeoVim 的二进制包，可直接运行，可以将上述解压的 NeoVim 中的 bin 目录添加到系统环境变量 <code class="language-plaintext highlighter-rouge">PATH</code>中，或者为 NeoVim 在 <code class="language-plaintext highlighter-rouge">/usr/bin</code>目录下添加一个软连接：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> ~/tools/nvim-linux64/bin/nvim /usr/bin/nvim

<span class="c"># 可通过执行以下命令进行校验</span>
nvim <span class="nt">--version</span>
</code></pre></div></div>

<h3 id="neovim-configuration">NeoVim Configuration</h3>

<p>  使用 NeoVim 一个很大的门槛就是前期各种 <code class="language-plaintext highlighter-rouge">Plugins</code>的配置，目前有 <code class="language-plaintext highlighter-rouge">lazyVim</code>将很多易用的 <code class="language-plaintext highlighter-rouge">Plugins</code>打包在了一起，做到了开箱即用。</p>

<p>将 <code class="language-plaintext highlighter-rouge">LazyVim</code> 下载并解压到 <code class="language-plaintext highlighter-rouge">NeoVim</code>的配置目录下，启动 <code class="language-plaintext highlighter-rouge">NeoVim</code>便会自动安装了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 直接 clone 代码到 neovim 的配置文件目录下</span>
git clone https://github.com/LazyVim/starter ~/.config/nvim

<span class="c"># 启动 nvim，自动开始安装</span>
nvim
</code></pre></div></div>

<p>安装完成后，使用 nvim 随便打开一个目录可以看到 NeroTree 中的图标全是小方块，即乱码：</p>

<p><img src="/assets/img/blog/nerofont_0.png" alt="NeroFont0" /></p>

<p>继续以下操作，安装所有符号等宽展示的字体。</p>

<h3 id="install-nerd-font">Install Nerd Font</h3>

<p><a href="https://www.nerdfonts.com/"></a></p>

<p>选择下载 <code class="language-plaintext highlighter-rouge">JetBrainsMono Font</code> 字体，在 Windows 中解压缩后，可以看到内部全是后缀为 <code class="language-plaintext highlighter-rouge">.ttf</code> 的文件，选中后，右键 <code class="language-plaintext highlighter-rouge">安装</code> 即安装成功。</p>

<h3 id="windows-terminal-配置-mono-字体">Windows Terminal 配置 Mono 字体</h3>

<p>我的 <code class="language-plaintext highlighter-rouge">windows terminal</code> 版本如下 ：</p>

<p><img src="/assets/img/blog/win_terminal.png" alt="" /></p>

<p>该版本没有 UI 的配置界面，通过 <code class="language-plaintext highlighter-rouge">settings.json</code> 进行配置，在 <code class="language-plaintext highlighter-rouge">profiles</code> 的 <code class="language-plaintext highlighter-rouge">defaults</code> 配置中添加 <code class="language-plaintext highlighter-rouge">fontFace</code> 字段指定字体，如下：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"defaults"</span><span class="p">:</span><span class="w">
</span><span class="p">{</span><span class="w">
   </span><span class="err">//</span><span class="w"> </span><span class="err">Put</span><span class="w"> </span><span class="err">settings</span><span class="w"> </span><span class="err">here</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="err">you</span><span class="w"> </span><span class="err">want</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">apply</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">all</span><span class="w"> </span><span class="err">profiles.</span><span class="w">
   </span><span class="nl">"fontFace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JetBrainsMono Nerd Font Mono"</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">

</span><span class="err">....</span><span class="w">
</span></code></pre></div></div>

<p>配置成功后，重启 <code class="language-plaintext highlighter-rouge">windows terminal</code>，通过 NeoVim 打开上一次的目录，查看图标显示已正常：</p>

<p><img src="/assets/img/blog/nerofont_1.png" alt="" /></p>

<h2 id="mac">Mac</h2>

<h2 id="ubuntu">Ubuntu</h2>

<h2 id="常用功能介绍">常用功能介绍</h2>

<h3 id="窗口管理">窗口管理</h3>

<ul>
  <li>打开内置控制台，执行命令，这是比较常用的场景，不需要切换窗口，快捷键 <code class="language-plaintext highlighter-rouge">Ctrl + L</code>，目录定位在当前路径，不是当前被打开的目录：</li>
</ul>

<p><img src="/assets/img/blog/nvim_console.png" alt="" /></p>

<blockquote>
  <p>关闭亦是使用该快捷键。</p>
</blockquote>

<ul>
  <li>切换光标在 <code class="language-plaintext highlighter-rouge">NeroTree</code> 和代码窗口中，使用 <code class="language-plaintext highlighter-rouge">Ctrl + h|l</code>，<code class="language-plaintext highlighter-rouge">h</code> 和 <code class="language-plaintext highlighter-rouge">l</code> 是 nvim 中移动光标位置的快捷键，加上 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键便是左右切换窗口的快捷键。</li>
</ul>]]></content><author><name>Mr Chen</name></author><category term="notes" /><category term="develop" /><summary type="html"><![CDATA[安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/tech/float-performance-comparation.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/tech/float-performance-comparation</id><content type="html" xml:base="https://gbcpp.github.io/tech/float-performance-comparation.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<p>由于 float 在内存中的存储结构与 int 不同，需要存储指数和尾数，并且 cpu 是不支持直接对 float 进行运算的，需要将 float 各部分进行转换后计算，对结果再次进行反向操作进行存储，所以大部分情况下均不支持直接使用 float 进行运行，建议用 int 进行转换运行结果。</p>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>由于不同的 CPU 和体系架构对 FPU 支持情况的不同，以及不同的运算方法对结果也有很大的影响， 比如 加、减、乘、除，以及系数的不同：大于 1 或者小于 1 等均有不同的结果，上述结论为选择了较为复杂的计算场景，仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="tech" /><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/float-performance.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/float-performance</id><content type="html" xml:base="https://gbcpp.github.io/float-performance.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>以上仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">获取不同 Clock Id 在不同 Linux Kernel 下的精度</title><link href="https://gbcpp.github.io/measure-clock-resolution.html" rel="alternate" type="text/html" title="获取不同 Clock Id 在不同 Linux Kernel 下的精度" /><published>2023-10-25T00:00:00+00:00</published><updated>2023-10-25T00:00:00+00:00</updated><id>https://gbcpp.github.io/measure-clock-resolution</id><content type="html" xml:base="https://gbcpp.github.io/measure-clock-resolution.html"><![CDATA[]]></content><author><name>Mr Chen</name></author><category term="Linux" /><category term="C++" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">GitHub Pages 博客搭建记录</title><link href="https://gbcpp.github.io/blog-building-notes.html" rel="alternate" type="text/html" title="GitHub Pages 博客搭建记录" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/blog-building-notes</id><content type="html" xml:base="https://gbcpp.github.io/blog-building-notes.html"><![CDATA[<h1 id="渊源">渊源</h1>

<p>  国庆放假期间，机缘巧合看到一篇使用了非常漂亮主题的文章，它也是基于 GitHub 的 Pages 进行搭建和部署的，回想起几年前自己搭建的个人博客（因始终不满足自己的审美要求，已废弃），让我一眼便喜欢上了它，立即决定重建我的个人博客。</p>

<h1 id="博客构建框架">博客构建框架</h1>

<p>  搭建个人博客，大部分人都是通过 GitHub 的 Pages 进行白嫖，但是已有的主题都不是非常完美，对于一个从事非前端开发的人来说，优化调整博客主题到自己满意的程度是非常难的，长时间搞不到自己满意的程度，结局大概率都是废弃。
在看到这篇基于<a href="https://blog.lui8.cn/tech/new-theme-h2o-ac.html">H2O-ac 主题</a> 搭建的的博客后，我决定就是它了，瞬间重拾搭建个人博客的兴趣。</p>

<p>  早些时候，我使用的 GitHub blog 是通过 <code class="language-plaintext highlighter-rouge">Hexo</code> 构建的，<code class="language-plaintext highlighter-rouge">Hexo</code> 是基于 <code class="language-plaintext highlighter-rouge">Node.js</code> 驱动的，而上述博客是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 构建，该框架基于 <code class="language-plaintext highlighter-rouge">Ruby</code> 驱动，它们都是开源的，通过 GitHub 的 star 和 fork 数量，可以看到 <code class="language-plaintext highlighter-rouge">Jekyll</code> 的热度要高于 <code class="language-plaintext highlighter-rouge">Hexo</code>，但是不知道当时自己怎么没有注意到这一点，可能是因为当时是摸着别人过的河，没有了自己的思考。</p>

<p>  由于该主题是基于 <code class="language-plaintext highlighter-rouge">Jekyll</code> 框架构建的，所以我们就此切换到 <code class="language-plaintext highlighter-rouge">Jekyll</code>，主题就用 <code class="language-plaintext highlighter-rouge">H2O-ac</code>。</p>

<h1 id="初始化">初始化</h1>

<p>  首先创建一个自己的专门用户博客的 public 仓库，这里建议直接从 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 主题作者的 repo <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">jekyll-theme-H2O-ac</a> 中 fork，在命名新的 repo 时，一定要命名自己的 GitHub <code class="language-plaintext highlighter-rouge">name</code> + ‘.github.io’，比如我自己的：gbcpp.github.io，其中 <code class="language-plaintext highlighter-rouge">gbcpp</code> 便是我的 GitHub name，这样做也是官方建议的，同时 Fork 过去的 repo 才可以直接 Publish，而不用做其它任何链接失效之类的修复，而我因为当初好几年没有再折腾过 GitHub 的博客，早已经忘记了这一点，起了个非此模板的名字：<code class="language-plaintext highlighter-rouge">blog</code>、 <code class="language-plaintext highlighter-rouge">webindex</code> 等，部署上的博客有好几处都是无效的链接，需要自行查找并修改，同时博客的 Url 中也要增加子路径。</p>

<p>Fork 后，在该 repo 的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，找到 <code class="language-plaintext highlighter-rouge">Pages</code>，在 <code class="language-plaintext highlighter-rouge">Build and deployment</code> 中选择 <code class="language-plaintext highlighter-rouge">master</code> 分支进行发布，目录就选择 <code class="language-plaintext highlighter-rouge">/(root)</code>, Save 后等待约 3 分钟，即可通过 <code class="language-plaintext highlighter-rouge">xxx.github.io</code> 进行访问。</p>

<p><img src="/assets/img/github_settings.png" alt="" /></p>

<h1 id="个人信息调整">个人信息调整</h1>

<p>虽然经过上述的简单操作，已经能够访问到自己新搭建的博客，但是还有一些个人信息需要调整，在 <code class="language-plaintext highlighter-rouge">.github/workflow</code> 中，每次提交，均会触发 GitHub Actions Workflow，重新执行 Jekyll build &amp; deploy CI 操作，所以我们要为自己的 repo 增加一个 <code class="language-plaintext highlighter-rouge">GITHUB_TOKEN</code>，否则每次 CI 均会报错。如下图所示：</p>

<p><img src="/assets/img/github_token.png" alt="GitHub Token" /></p>

<p>GitHub 的 CI 每次构建完成后会将生成的 <code class="language-plaintext highlighter-rouge">_site</code> 目录 Push 到 <a href="https://jupyterbook.org/en/stable/publish/gh-pages.html"><code class="language-plaintext highlighter-rouge">gh-pages</code></a> 分支。</p>

<p>在该作者的 repo 中，添加的 GitHub workflow 不止 <code class="language-plaintext highlighter-rouge">GitHub</code> 一个，还有亚马逊等其它家，用于网站加速，不过，我个人并没有使用这种多个 workflow 的方式，我删除了除了 ‘jekyll.yml’ 以外所有的 workflow，网站加速请继续往下看。</p>

<h1 id="部署-cdn">部署 CDN</h1>

<p>博客初步建立后，直接访问是非常慢的，没有任何的 CDN 托管加速，而 <code class="language-plaintext highlighter-rouge">H2O-ac</code> 的作者开通了多家国内外 CDN 厂家的托管，访问速度要比直接 xxx.github.io 快很多。</p>

<p>这里我选择了提供全球节点的 <code class="language-plaintext highlighter-rouge">Cloudflare</code> <a href="https://dash.cloudflare.com/">官网</a> 进行托管，主要是因为它对于个人站点是完全免费的，并且操作简单，易上手。</p>

<h2 id="cloudflare-新建-pages">Cloudflare 新建 Pages</h2>

<p>注册并登陆 Cloudflare，进入到个人 <code class="language-plaintext highlighter-rouge">账户主页</code>，进入 <code class="language-plaintext highlighter-rouge">Worker 和 Pages</code>，选择 <code class="language-plaintext highlighter-rouge">Pages</code> 选项，<strong>注意</strong>我们这里选择 <code class="language-plaintext highlighter-rouge">连接到 Git</code>，选择自己的仓库和分支，自动部署即可，如下图：</p>

<p><a href="/assets/img/Cloudflare_GitPages.png"></a></p>

<p>由于我们仅使用了 <code class="language-plaintext highlighter-rouge">jekyll.yml</code> 一个 GitHub Action，该 CI 完成后，会将 <code class="language-plaintext highlighter-rouge">_site</code> 目录自动 push 到 <code class="language-plaintext highlighter-rouge">gp-pages</code> 分支，所以在 <code class="language-plaintext highlighter-rouge">Cloudflare</code> 的 <code class="language-plaintext highlighter-rouge">Pages</code> 配置中，我们选择 <strong>分支</strong> 为 <code class="language-plaintext highlighter-rouge">gh-pages</code>，同时不要添加任何的构建框架和执行命令，只要选择自动选择更新即可。添加完成后的配置如下，可做参考：
<a href="/assets/img/Cloudflare_GitPages2.png"></a></p>

<h2 id="自定义域名">自定义域名</h2>

<p>上述部署完成，可以生成自己博客在 Cloudflare 的域名，比如：xxx-github-io.pages.dev，执行以下步骤将 xxx.github.io 重定向到 xxx-github-io.pages.dev。</p>

<h3 id="cname">CNAME</h3>
<p>Custom domain 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 
博客仓库中新建 <code class="language-plaintext highlighter-rouge">CNAME</code> 文件，填充 Cloudflare 生成的 ‘xxx-github-io.pages.dev’ 域名，并提交。</p>

<h3 id="pages-自定义域名配置">Pages 自定义域名配置</h3>

<p>回到 GitHub 博客仓库的 <code class="language-plaintext highlighter-rouge">Settings</code> 页面，在 <code class="language-plaintext highlighter-rouge">Pages</code> 子页面的 <code class="language-plaintext highlighter-rouge">Custom domain</code> 中填入 <code class="language-plaintext highlighter-rouge">xxx-github-io.pages.dev</code> 保存。以后每次访问自己的 xxx.github.io 便会自动跳转到 xxx-github-io.pages.dev。</p>

<p>当然这样的白嫖效果也就一般般，访问速度并不能完全达到国内建站的速度。</p>

<h1 id="绊脚石">绊脚石</h1>

<h2 id="jekyll-安装">Jekyll 安装</h2>

<p>本人的环境是在 WSL2 下的 Ubuntu Linux 安装的，发现 Jekyll 官方提供的 Installing docs 在 Ubuntu 18.04 及以下由于版本兼容问题已经无法正常的安装了，在 Ubuntu 20.04 中较为顺利，依次执行以下命令不太会遇到太多的问题：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span>
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span>  ruby-full build-essential zlib1g-dev
<span class="nb">echo</span> <span class="s1">'# Install Ruby Gems to ~/gems'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export GEM_HOME="$HOME/gems"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/gems/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc

<span class="c"># 这里 proxychains 为本人配置的 代理，否则容易出现下载失败</span>
<span class="nb">sudo </span>proxychains gem <span class="nb">install </span>jekyll bundler
<span class="nb">sudo </span>proxychains bundle <span class="nb">install</span>
</code></pre></div></div>

<h2 id="h2o-ac-blog-页面异常">H2O-ac Blog 页面异常</h2>

<p>基于作者的最新版本 <code class="language-plaintext highlighter-rouge">master</code> 或者 <code class="language-plaintext highlighter-rouge">tag: v1.2.1</code>，在 <code class="language-plaintext highlighter-rouge">Blog</code> 首页会有如下分页显示的问题，该问题在 GitHub 中已经有人反馈给作者, <a href="https://github.com/zhonger/jekyll-theme-H2O-ac/issues/13">ISSUE</a>，等待作者修复（本人不懂前端，经过几天努力，排查修复失败），不过本人已经排查到该显示问题是从 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 升级到 <code class="language-plaintext highlighter-rouge">v1.1.7</code> 时开始引入的，在本地 build 查看时，没有异常，一旦部署到 GitHub 便异常，所以该站使用的是 <code class="language-plaintext highlighter-rouge">v1.1.6</code> 版本。</p>

<p><a href="/assets/img/jekyll_blog_bug.png"></a></p>

<h2 id="cloudflare-部署报错">Cloudflare 部署报错</h2>

<p>当 Blog 中存在文件 size ~&gt; 25MB 时，Cloudflare 会报错而终止部署，对此需要删除 repo 中所有 size 过大的文件（一般是图片），根据报错，通过以下命令查找并删除所有相关文件的历史记录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 其中 assets/img/shan.png 为要删除的文件</span>
git filter-branch <span class="nt">--force</span> <span class="nt">--index-filter</span> <span class="s1">'git rm --cached --ignore-unmatch assets/img/shan.png'</span> <span class="nt">--prune-empty</span> <span class="nt">--tag-name-filter</span> <span class="nb">cat</span> <span class="nt">--</span> <span class="nt">--all</span>
</code></pre></div></div>

<p>排查结束后，会显示涉及到该文件的分支列表，如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ref <span class="s1">'refs/heads/gh-pages'</span> was rewritten
Ref <span class="s1">'refs/heads/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/master'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/dev'</span> was rewritten
Ref <span class="s1">'refs/remotes/origin/gh-pages'</span> was rewritten
WARNING: Ref <span class="s1">'refs/remotes/origin/master'</span> is unchanged
</code></pre></div></div>

<p>将 <code class="language-plaintext highlighter-rouge">rewritten</code> 的本地分支 push 到 GitHub，然后在 Cloudflare 上重新部署。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout master
git push <span class="nt">-f</span> origin master

git checkout gh-pages
git push <span class="nt">-f</span> origin gh-pages
</code></pre></div></div>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[渊源]]></summary></entry><entry><title type="html">PlantUML-Language Pdf</title><link href="https://gbcpp.github.io/PlantUML-Language-book.html" rel="alternate" type="text/html" title="PlantUML-Language Pdf" /><published>2023-10-07T00:00:00+00:00</published><updated>2023-10-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/PlantUML-Language-book</id><content type="html" xml:base="https://gbcpp.github.io/PlantUML-Language-book.html"><![CDATA[<h1 id="plantuml-语法字典">PlantUML 语法字典</h1>

<p>查看 和 下载地址：<a href="/assets/books/PlantUML_Language_Reference_Guide_zh.pdf">PlantUML-Language</a></p>]]></content><author><name>Mr Chen</name></author><category term="GitPages" /><category term="blog" /><summary type="html"><![CDATA[PlantUML 语法字典]]></summary></entry></feed>