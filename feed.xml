<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://gbcpp.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://gbcpp.github.io/" rel="alternate" type="text/html" /><updated>2025-01-07T09:59:04+00:00</updated><id>https://gbcpp.github.io/feed.xml</id><title type="html">Mr Chen</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>Mr Chen</name></author><entry><title type="html">webtransport-go 在直播场景下的优化</title><link href="https://gbcpp.github.io/notes/webtransport-go-optimze-for-livestream.html" rel="alternate" type="text/html" title="webtransport-go 在直播场景下的优化" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-01-07T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/webtransport-go-optimze-for-livestream</id><content type="html" xml:base="https://gbcpp.github.io/notes/webtransport-go-optimze-for-livestream.html"><![CDATA[<h1 id="背景">背景</h1>
<p>公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。</p>

<blockquote>
  <p>本人经历 2024年 11月变动以后，刚来公司不久，周边同事基本都以 golang 语言开发为主，且基本没有协议的优化经验，只能选择开源项目进行优化， B本人进入公司的时机也不好，该项目已经选定该方案，并且开始上线进行灰度测试，无法推翻重来。
且对比 Tcp 来看，webtransport-go 带来的性能消耗是 tcp 的 5 倍以上。</p>
</blockquote>

<h2 id="为什么不直接使用-quic-go">为什么不直接使用 quic-go</h2>

<p>因为 quic 虽然也是可靠传输，但是 quic 暂不支持通过 Url 来携带业务测参数，如：vhost、token 等的。</p>

<h1 id="初始化">初始化</h1>
<h2 id="代码下载">代码下载</h2>

<p><code class="language-plaintext highlighter-rouge">git clone git@github.com:quic-go/webtransport-go.git</code></p>

<p>拉取相关依赖仓库代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 进入代码目录
cd webtransport-go

# 通过 build 触发代码拉取
go build webtransport_test.go
</code></pre></div></div>

<p>Golang 默认将代码存放在<code class="language-plaintext highlighter-rouge">$GOPATH</code>目录下，我的<code class="language-plaintext highlighter-rouge">GOPATH</code>环境变量配置为 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go</code>，那么拉取的依赖仓库 <code class="language-plaintext highlighter-rouge">quic-go</code> 的存放目录就是 <code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1</code>，为了方便在 VSCode 中查看代码，在 VSCode 的 WorkSpace 空白处通过右键选择：<code class="language-plaintext highlighter-rouge">Add Folder to WorkSpace</code>，选择上述目录，即可一起查看 <code class="language-plaintext highlighter-rouge">quic-go</code> 相关的代码，如下：
<img src="/assets/img/blog/vscode-go.jpg" alt="" /></p>

<h2 id="quic-go">Quic-go</h2>

<p>Quic-go 作为 webtransport-go 的依赖仓库，提供 quic 的基础传输能力，但是其提供的传输配置能力非常有限，特别是作为发送端时，一些基础的 CWnd、Burst、Ack 等参数均不支持配置，接口文件为：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/interface.go</code></p>

<p>quic-go 内部相关参数主要位于：
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/protocol.go</code>
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/protocol/params.go</code></p>

<h1 id="优化项">优化项</h1>

<ul>
  <li>初始化发送包数：</li>
</ul>

<p>文件：<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code> 中指定
<code class="language-plaintext highlighter-rouge">const maxBurstSizePackets = 10</code>，在直播场景，I 帧切片后（1200Bytes/pkt）基本都会超过 10 片，建议配置为 20~30，具体视业务场景中首帧的切换大小，但也不宜过高，控制在 30 以内。
该配置项生效后对秒开的影响较小，属于毫秒级别，原来可能受 pacer 控制在几个 timerGraulariry 中将一个关键帧发送完，该配置的理想效果是减少这几个 timerGraulariry 的延迟。</p>

<ul>
  <li>握手超时时间：
应用层建议也是用 2 秒的配置。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const DefaultHandshakeIdleTimeout = 5 * time.Second
// 建议修改为 2 或者 3 秒，业务测可以快速重连，减少等待时间
const DefaultHandshakeIdleTimeout = 2 * time.Second
</code></pre></div></div>

<ul>
  <li>定时器精度</li>
</ul>

<p>最好是从系统中获取自己的定时器精度（一般是4ms），不建议使用 1 ms 这种精度，过于高频，无效的 cpu 消耗。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Default
const TimerGranularity = time.Millisecond
// 建议值：动态获取系统定时器精度，或者 hardcode 为 4ms 或者 10ms
const TimerGranularity = 4 * time.Millisecond
</code></pre></div></div>

<ul>
  <li>转发模式</li>
</ul>

<p>目前业务集成方在回源时，虽然传输协议使用的是流式传输，但是边缘节点在接收到分片数据后并不会立即进行转发，而是在组装成一个完整的帧以后再一次性进行发送，这样做是为了内部各种封装格式的转换，但是也存在明显的弊端，即在没有收到完整的关键帧以前，不会向 Player 发送任何数据，被回源的关键帧阻塞，间接的增加了首开的延迟。</p>

<p>可优化选项：比如回源的协议与 Player 请求的协议相同，即均为 HTTP-FLV，那么便不再需要进行完整帧的转封装，而直接进行分片的透明转发，同时边缘节点也异步的 cache 分片数据进行组帧操作，转封装分发给其它请求的协议。</p>

<h1 id="faq">FAQ</h1>

<h2 id="webtransport-是否是整帧的收发">Webtransport 是否是整帧的收发？</h2>

<p>不是，websocket 在发送大的数据帧时，会通过 FIN 标记位是否为 1 标记为该 Frame 是否结束，而 WebTransport 中是基于流的传输，需要应用层自行组装完整的数据帧。
<a href="https://www.ietf.org/archive/id/draft-ietf-webtrans-overview-05.html#name-conventions-and-definitions-8">ref link</a></p>

<blockquote>
  <p>A stream is a sequence of bytes that is reliably delivered to the receiving application in the same order as it was transmitted by the sender. Streams can be of arbitrary length, and therefore cannot always be buffered entirely in memory. WebTransport protocols and APIs are expected to provide partial stream data to the application before the stream has been entirely received.</p>
</blockquote>

<h2 id="bbr-sender-配置-startup-的较大带宽但是-max-burst-send-packets-number-却较小能将关键帧的几个切片一次性发送出去吗">BBR sender 配置 startup 的较大带宽，但是 max burst send packets number 却较小，能将关键帧的几个切片一次性发送出去吗？</h2>

<p><code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/pacer.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        p := &amp;pacer{
                maxDatagramSize: initialMaxDatagramSize,
                adjustedBandwidth: func() uint64 {
                        // Bandwidth is in bits/s. We need the value in bytes/s.
                        bw := uint64(getBandwidth() / BytesPerSecond)
                        // Use a slightly higher value than the actual measured bandwidth.
                        // RTT variations then won't result in under-utilization of the congestion window.
                        // Ultimately, this will result in sending packets as acknowledgments are received rather than when timers fire,
                        // provided the congestion window is fully utilized and acknowledgments arrive at regular intervals.
                        return bw * 5 / 4
                },
        }
        p.budgetAtLastSent = p.maxBurstSize()
        return p
}
</code></pre></div></div>

<p>而在初始化时，由于没有 smoothedRTT 的有效值，所以初始化为 <code class="language-plaintext highlighter-rouge">infBandwidth</code> (UINT64_MAX)，
<code class="language-plaintext highlighter-rouge">/Users/eddie/develop/go/pkg/mod/github.com/quic-go@v0.42.0-mod.1/internal/congestion/bbr_sender.go</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (b *bbrSender) bandwidthEstimate() Bandwidth {
        srtt := b.rttStats.SmoothedRTT()
        if srtt == 0 {
                // If we haven't measured an rtt, the bandwidth estimate is unknown.
                return infBandwidth
        }
        bw := b.maxBandwidth.GetBest()
        if bw == 0 {
                return infBandwidth
        }
        return bw
}
</code></pre></div></div>

<p>虽然初始化的 bandwidth 比较大，但是 pacer 在发送数据时依然会受限于 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 的配置，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *pacer) maxBurstSize() protocol.ByteCount {
        return utils.Max(
                protocol.ByteCount(uint64((protocol.MinPacingDelay+protocol.TimerGranularity).Nanoseconds())*p.adjustedBandwidth())/1e9,
                maxBurstSizePackets*p.maxDatagramSize,
        )
}
</code></pre></div></div>

<p>所以建议将 <code class="language-plaintext highlighter-rouge">maxBurstSizePackets</code> 值配置为 20 ～ 30 之间，根据业务场景，尽量让首帧（I Frame）的所有切片能够一次性发送出去，但是也不宜过高，避免数据突发导致网络拥塞丢包。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Protocol" /><summary type="html"><![CDATA[背景 公司后台代码以 golang 为主，同事已经选择使用 webtransport-go 的开源方案灰度上线，虽然短期内就要接客户，使用自研的私有传输协议已经完全来不及，当下只能尽量优化 webtransport-go 这个方案，首先尽量在首开上进行优化，卡顿率相关的指标如果能与 tcp 持平甚至更好的话，就不在该方案中继续投入了，转为基于 c++ 的私有协议方案。]]></summary></entry><entry><title type="html">C++ 程序输出当前堆栈</title><link href="https://gbcpp.github.io/notes/print_stacktrace.html" rel="alternate" type="text/html" title="C++ 程序输出当前堆栈" /><published>2024-06-11T00:00:00+00:00</published><updated>2024-06-11T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/print_stacktrace</id><content type="html" xml:base="https://gbcpp.github.io/notes/print_stacktrace.html"><![CDATA[<p>将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。
互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。</p>

<h2 id="头文件">头文件</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h2 id="源码">源码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Utils</span><span class="o">::</span><span class="n">PrintStackTrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxFrames</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">kMaxPrettyFunctionNameLength</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">[</span><span class="n">kMaxFrames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 获取当前堆栈中的地址</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrlist</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"StackTraces: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// 解析地址为函数名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">symbollist</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">addrlist</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

  <span class="c1">// 解析函数名的更多信息</span>
  <span class="kt">size_t</span> <span class="n">funcNameSize</span> <span class="o">=</span> <span class="n">kMaxPrettyFunctionNameLength</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">funcName</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">funcNameSize</span><span class="p">));</span>

  <span class="c1">// 跳过第一个元素（即本身）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beginOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 解析符号名称及偏移量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginName</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">beginOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endOffset</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beginName</span> <span class="o">&amp;&amp;</span> <span class="n">beginOffset</span> <span class="o">&amp;&amp;</span> <span class="n">endOffset</span> <span class="o">&amp;&amp;</span> <span class="n">beginName</span> <span class="o">&lt;</span> <span class="n">beginOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">beginName</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">beginOffset</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="o">*</span><span class="n">endOffset</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

      <span class="c1">// 解码并打印函数名称</span>
      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span>
          <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">beginName</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funcNameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果无法解析，直接输出原始符号信息</span>
      <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">symbollist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">funcName</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">symbollist</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="编译">编译</h2>

<p><code class="language-plaintext highlighter-rouge">ldflags</code> 参数一定要指定 <code class="language-plaintext highlighter-rouge">-ldynamiclib</code> 告诉链接器将所有符号添加到动态符号表中。这使得运行时调试工具（如 GDB）和运行时函数（如 backtrace）可以访问这些符号。
主要用于调试和诊断目的，以便在运行时能够获取更详细的堆栈信息和符号解析。</p>

<p>对性能几乎没有影响，但是由于增加了符号表信息，会增加包体大小。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[将当前程序运行时的堆栈信息输出到控制台，或者 Log 中，用于问题调查。 互联网中找到的，使用均有内存问题，以下是修复后的版本，可正常运行在 Linux 下。]]></summary></entry><entry><title type="html">温故而知新之-C++</title><link href="https://gbcpp.github.io/notes/learning-cpp-notes.html" rel="alternate" type="text/html" title="温故而知新之-C++" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/learning-cpp-notes</id><content type="html" xml:base="https://gbcpp.github.io/notes/learning-cpp-notes.html"><![CDATA[<h2 id="指针的退化及如何避免">指针的退化及如何避免</h2>

<p>在C++中，”指针退化”是指当数组作为函数参数传递时，它会”退化”为指向第一个元素的指针。这是因为在C++中，数组并不知道它们自己的大小，所以当你把一个数组作为参数传递给一个函数时，函数并不知道这个数组的大小，只知道它的起始地址。</p>

<p>例如，假设你有一个函数<code class="language-plaintext highlighter-rouge">void foo(int arr[])</code>，当你传递一个数组给这个函数时，例如<code class="language-plaintext highlighter-rouge">int arr[10]; foo(arr);</code>，函数<code class="language-plaintext highlighter-rouge">foo</code>实际上看到的是一个指向<code class="language-plaintext highlighter-rouge">arr</code>的第一个元素的指针，而不是整个数组。</p>

<p>要防止指针退化，有几种方法：</p>

<ol>
  <li>
    <p>使用标准库容器，如<code class="language-plaintext highlighter-rouge">std::vector</code>或<code class="language-plaintext highlighter-rouge">std::array</code>。这些容器知道它们自己的大小，因此不会发生指针退化。例如： <code class="language-plaintext highlighter-rouge">void foo(std::vector&lt;int&gt;&amp; arr)</code>。</p>
  </li>
  <li>
    <p>使用模板函数，使函数可以接受数组的引用，并且能够保留数组的大小信息。例如： <code class="language-plaintext highlighter-rouge">template&lt;size_t N&gt; void foo(int (&amp;arr)[N])</code>。</p>
  </li>
  <li>
    <p>传递数组的大小作为另一个参数。例如： <code class="language-plaintext highlighter-rouge">void foo(int* arr, size_t size)</code>。这样，即使数组退化为指针，函数仍然可以知道数组的大小。</p>
  </li>
</ol>

<h2 id="引用与指针的区别">引用与指针的区别</h2>

<p>在C++中，指针和引用都可以用于间接引用其他对象。然而，它们在语法和行为上有一些关键的不同：</p>

<ol>
  <li>
    <p>初始化：引用在创建时需要初始化，并且一旦初始化后就不能改变引用的目标，也就是说它始终引用最初赋给它的对象。而指针可以在任何时间指向任何对象或者NULL。</p>
  </li>
  <li>
    <p>空值：指针可以为NULL，表示它不指向任何对象。而引用必须始终引用一个有效的对象，不能有NULL引用。</p>
  </li>
  <li>
    <p>间接访问：使用指针时，需要使用解引用运算符(*)来访问它指向的对象，而引用则可以像普通变量那样直接使用。</p>
  </li>
  <li>
    <p>支持的操作：指针支持更多的操作，例如指针算术（即增加或减少指针的值，以指向内存中的不同位置）。引用则不能进行这种操作。</p>
  </li>
  <li>
    <p>内存占用：引用实际上并不占用任何内存，它只是一个别名。而指针是一个实际的变量，它占用内存空间并存储一个地址值。</p>
    <blockquote>
      <p>但引用在程序中并不是不占用任何字节，引用本质上就是一个常量指针（constant pointer）。它在内存中占据的空间和指针一样，通常是 4 字节（在 32 位系统）或 8 字节（在 64 位系统）。然而，引用本身并不存储任何值，它只是一个别名，代表它引用的对象。在某些优化的情况下，如果引用没有被用作一个对象的别名（也就是说，它被直接用于访问该对象），编译器可能会优化掉引用，使其不占用任何内存空间。但是，这种优化并不是在所有情况下都会发生。所以，说引用不占用内存空间并不完全准确，实际情况取决于编译器的优化和引用的使用方式。</p>
    </blockquote>
  </li>
</ol>

<p>总的来说，引用在某些情况下可以提供更简洁的语法，而指针则提供了更大的灵活性和控制能力。选择使用哪一个取决于具体的编程需求。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="C++" /><summary type="html"><![CDATA[指针的退化及如何避免]]></summary></entry><entry><title type="html">面向学习的三种人</title><link href="https://gbcpp.github.io/notes/learning-oriented.html" rel="alternate" type="text/html" title="面向学习的三种人" /><published>2024-04-02T00:00:00+00:00</published><updated>2024-04-02T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/learning-oriented</id><content type="html" xml:base="https://gbcpp.github.io/notes/learning-oriented.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者</p>
</blockquote>

<h2 id="1-犯人">1. 犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="2-过客">2. 过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="3-探索者">3. 探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者]]></summary></entry><entry><title type="html">基于 HTTP/3 的 WebTransport</title><link href="https://gbcpp.github.io/protocol/WebTransport.html" rel="alternate" type="text/html" title="基于 HTTP/3 的 WebTransport" /><published>2024-02-01T00:00:00+00:00</published><updated>2024-02-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/protocol/WebTransport</id><content type="html" xml:base="https://gbcpp.github.io/protocol/WebTransport.html"><![CDATA[<blockquote>
  <p>本文主要翻译自https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3 ，如有错误请指正。</p>
</blockquote>

<h1 id="摘要">摘要</h1>

<p>WebTransport 是一个协议框架，它强迫客户端受 web 安全模型去与远程服务器进行安全的多路传输；
WebTransport 是一个受 Web 安全模型约束的多路复用安全传输协议，本文将描述一个 WebTransport 协议基于 HTTP3 并提供单向流、双向流和数据报，并全部复用同一个相同的 HTTP3 链接；</p>

<!--more-->

<h1 id="现状">现状</h1>

<p>这是一份 Internet 标准跟踪文档。
本文是  Internet Engineering Task Force（IETF）的产品，它代表了 IETF 社区已达成的共识，它已经经历了公开的审阅并已被 Internet Engineering Steering Group (IESG) 批准出版；更多信息可以参考 <a href="!https://datatracker.ietf.org/doc/html/rfc7841#section-2">Section 2 of RFC 7841</a>。</p>

<h1 id="介绍">介绍</h1>

<p>HTTP3 是在 QUIC [QUIC-TRANSPORT] 之上可以通过 QUIC 链接多路复用 HTTP 请求的协议。本文档定义了一种通过 HTTP3 实现 WebTransport 协议的要求，以实现多路复用 non-HTTP 数据的机制。多个 WebTransport 实例可以同时复用在同一个 HTTP3 链接上进行常规的 HTTP 数据传输。</p>

<h1 id="协议概述">协议概述</h1>

<p>WebTransport Server 通常由一对权限值和录制值来标识  (defined in [RFC3986] Sections 3.2 and 3.3   correspondingly)。
当一个 HTTP3 连接后，Client 和 Server 端都必须发送一个 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 配置以表明它们都支持基于 HTTP3 的 WebTransport。WebTransport 会话由 Client 在给定的 HTTP3 连接内发起，即由 Client 发送一个扩展的 CONNECT 请求，如果 Server 接受该请求，则一个 WebTransport session 便建立了；生成的 stream 将被进一步称为  <em>CONNECT stream</em>，其 stream ID 用于唯一标识当前给定链接内的 WebTransport session。在给定的 WebTransport session 上建立的 CONNECT stream 的 ID 将被进一步称为 <em>Session ID</em>。</p>

<p>会话建立后，双方便可以使用以下机制交换数据：</p>

<ul>
  <li>Client 可以创建一个由特殊的不限制长度的 HTTP3 frame 组成的双向流（bidirectional stream），然后转移该流的所有权给 WebTransport；</li>
  <li>Server 也可以创建一个 bidirectional stream，因为 HTTP3 没有为 Server 端创建 bidirectional stream 定义任何语义（言外之意：不禁止便是允许）；</li>
  <li>Client 和 Server 都可以创建单向流类型（unidirectional stream）；</li>
  <li>可以通过 QUIC DATAGRAM 帧发送数据包 datagram；<a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-DATAGRAM">QUIC-DATAGRAM</a></li>
</ul>

<p>当创建的 CONNECT stream 关闭时，WebTransport 会话也即终止。</p>

<h1 id="会话建立">会话建立</h1>

<h2 id="建立支持传输的-http3-链接">建立支持传输的 HTTP3 链接</h2>

<p>Client 和 Server 必须均在它们的设置框架中发送一个为 <code class="language-plaintext highlighter-rouge">1</code> 的值。终端不能使用任何 WebTransport 的任何功能，除非它们已经协商各种参数。
如果协商了 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 参数，则在协商 HTTP3 中 QUIC DATAGRAMS 时，必须按照 <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3-DATAGRAM">HTTP3-DATAGRAM</a> 进行协商；否则在协商 WebTransport 时如果没有 QUIC DATAGRAM 扩展，将导致 H3_SETTINGS_ERROR。
HTTP3 要求 Client 的 <code class="language-plaintext highlighter-rouge">initial_max_bidi_streams</code> 传输参数设置为 <code class="language-plaintext highlighter-rouge">0</code>。当前的实现是在协商时强制执行这个规定；因此，在 client 发起 bidirectional streams 时，需发送一个非零的 <code class="language-plaintext highlighter-rouge">MAX_STREAMS</code> 。</p>

<h2 id="http3-扩展方法-connect">HTTP3 扩展方法 CONNECT</h2>

<p>RFC8441 在第 4 节中定义了一个扩展方法 <code class="language-plaintext highlighter-rouge">CONNECT</code>，可以通过 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_CONNECT_PROTOCOL</code> 参数激活，该参数是为 HTTP2 定义的，但是该协议不会在 HTTP3 中为 <code class="language-plaintext highlighter-rouge">CONNECT</code> 创建更多的扩展含义；因为 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 配置已经代表了终端支持扩展的 <code class="language-plaintext highlighter-rouge">CONNECT</code>。</p>

<h2 id="创建会话">创建会话</h2>

<p>由于 WebTransport 会话是通过 HTTP3 建立的，所以它们使用 <code class="language-plaintext highlighter-rouge">https</code> URI 规则 <a href="!https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a> 。
为了创建一个 WebTransport 会话，client 可以发送一个 HTTP CONNNECT 请求，其 <code class="language-plaintext highlighter-rouge">:protocol</code> 伪-头域 <a href="!https://datatracker.ietf.org/doc/html/rfc8441">RFC8441</a> 字段必须设置为 <code class="language-plaintext highlighter-rouge">webtransport</code>，<code class="language-plaintext highlighter-rouge">:scheme</code> 字段必须设置为 <code class="language-plaintext highlighter-rouge">https</code>, 同时 <code class="language-plaintext highlighter-rouge">:authorith</code>和 <code class="language-plaintext highlighter-rouge">:path</code> 必须配置，这些字段标识这是一个 WebTransport 服务；一个 <code class="language-plaintext highlighter-rouge">Origin</code> header 必须包含在这个请求中。</p>

<p>在收到一个 <code class="language-plaintext highlighter-rouge">:protocol</code> 字段设置为 <code class="language-plaintext highlighter-rouge">webtransport</code> 的 CONNECT 扩展请求时，HTTP3 服务器可以检查自己是否包含该请求中指定的 <code class="language-plaintext highlighter-rouge">:authorith</code> 和 <code class="language-plaintext highlighter-rouge">:path</code> 配置的 WebTransport 服务，如果没有，它应该返回状态码 404；如果有，它可以通过回复状态码 200 标识接受会话请求。WebTransport server 必须验证 <code class="language-plaintext highlighter-rouge">Origin</code> header 以确保指定 origin 是可以被访问的。</p>

<p>从客户端的角度看，一个 WebTransport 会话建立的标识是 client 收到了 server 的 200 响应；
从服务端的角度来看，一旦发送了 200 响应，就算是建了会话，两端都不能在会话建立之前打开任何 streams 或者发送任何的 datagrams。</p>

<p><strong>基于 HTTP3 的 WebTransport 不支持 0-RTT。</strong></p>

<h2 id="限制同时会话的数量">限制同时会话的数量</h2>

<p>从流控的角度来看，WebTransport 会话数量针对stream 的流控就像常规的 HTTP 请求一样（通过 HTTP CONNECT 请求建立连接）。本协议没有引入新的，单独的流控机制，也不将 HTTP 请求与  WebTransport 会话分离，如果服务器需要限制接收请求的速率，它可以使用其它的机制：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">HTTP_REQUEST_REJECTED</code> error code 定义在 <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3">HTTP3</a> 标识未处理的请求的 HTTP3 堆栈；</p>
  </li>
  <li>
    <p>HTTP 状态码 429 表示达到了服务器的速率控制，请求被拒绝 <a href="!https://datatracker.ietf.org/doc/html/rfc6585">RFC6585</a>；与上一个方法不一样，它直接将这个信号通知给发起的请求的应用程序；</p>
  </li>
</ul>

<h1 id="webtransport-功能列表">WebTransport 功能列表</h1>

<p>WebTransport over HTTP3 提供了以下功能特性：</p>

<ul>
  <li>单向流 unidirectional streams</li>
  <li>双向流 bidirectional streams</li>
  <li>数据包 datagrams</li>
</ul>

<p>以上功能均可由任意一端发起。
Session ID 可用于解复用 Streams 和 Datagrams 以判断属于不同的 WebTransport session，在网络中，session IDs 使用的是 QUIC 可变长度整数方案编码的  <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-TRANSPORT">QUIC-TRANSPORT</a>。</p>

<h2 id="unidirectional-streams">Unidirectional streams</h2>

<p>WebTransport 连接一旦建立，两端均可以打开 Unidirectional streams。HTTP3 unidirectional stream type 应为 0x54，整个包体结构依次是 stream type [0x54]、Session ID、已编码的可变整数类型的长度信息、用户指定的流数据，如下：</p>

<p><strong>Unidirectional WebTransport stream format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           0x54 (i)                          ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="客户端发起的-birectional-streams">客户端发起的 Birectional Streams</h2>

<p>WebTransport 客户端可以通过打开一个 HTTP3 双向流并发送一个帧类型为 <code class="language-plaintext highlighter-rouge">WEBTRANSPORT_STREAM</code> (type=0x41) 的 HTTP3 frame 以初始化一个 WebTransport 的双向流。帧的格式为：frame type、Session ID、已编码可变数据长度、用户数据；
数据帧应该持续到流结束。</p>

<p><strong>WEBTRANSPORT_STREAM frame format:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           0x41 (i)                          ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="服务端发起的-bidirectional-streams">服务端发起的 Bidirectional Streams</h2>

<p>WebTransport 服务端可以通过打开一个 HTTP3 双向流初始化 Bidirectional Stream。请注意：由于 HTTP3 没有为服务器启动定义任何的 Bidirectional Strream 的相关语义，本协议中此类流适用于所有的 HTTP3 连接，前提是 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 选项已经协商过了。这些流的格式如下：</p>

<p><strong>*Server-initiated bidirectional stream format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Stream Body                         ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="数据包-datagrams">数据包 Datagrams</h2>

<p>Datagrams 可以发送   <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-QUIC-DATAGRAM">QUIC-DATAGRAM</a> and <a href="!https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3#ref-HTTP3-DATAGRAM">HTTP3-DATAGRAM</a> 定义的 DATAGRAM frame，前提是 <code class="language-plaintext highlighter-rouge">SETTINGS_ENABLE_WEBTRANSPORT</code> 已协商，流标识符（Flow Identifier）被设置为 session ID，格式如下：</p>

<p><strong>Datagram format：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Session ID (i)                       ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Datagram Body                        ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<p>在 QUIC 中，一个 Datagram 帧最多可以跨越一个数据包中，因为于此，应用程序必须知道可以发送的最大1数据报大小；然而当代理数据报时，逐跳的 MTU 可能并不相同。</p>

<h1 id="会话终止">会话终止</h1>

<p>任何一方都可以通过关闭起初通过发送 CONNECT 请求建立起来的流来关闭当前  WebTransport 会话；在得知会话正在终止时，断点必须停止发送新的 datagrams 并且重置所有与此 session 相关联的 sterams。</p>

<h1 id="安全注意事项">安全注意事项</h1>

<p>WebTransport over HTTP3 满足所有对 WebTransport 协议施加的所有安全要求，由于 Client 有可能不被信任，所以提供了一个client-server 通信的安全框架。
WebTransport over HTTP3 需要基于 QUIC 传输参数，这样可以通过 HTTP3 server 的支持来避免潜在的协议混淆带来的攻击；它还需要使用 Origin header，为服务器提供拒绝访问非源自于 Web 客户端的不被信任的 origin。</p>

<p>就像通过 HTTP3 传输的 HTTP 流量一样，WebTransport 流量汇集不同的来源到同一个链接中，不同的源代表不同的信任域，意味着需要在同一个链接上应对不同的潜在的攻击，一种潜在的攻击是耗尽所有资源，因为所有的传输共享拥塞控制和流量控制，单个客户端大量使用这些资源可能会导致其它传输被终止。所以用户代理应该实施一个公平的方案，以确保链接内的每个传输可以获得可控的合理资源份额，这适用于数据发送和创建新流操作。</p>]]></content><author><name>Mr Chen</name></author><category term="Protocol" /><category term="Protocol" /><summary type="html"><![CDATA[本文主要翻译自https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-http3 ，如有错误请指正。]]></summary></entry><entry><title type="html">Blog title</title><link href="https://gbcpp.github.io/notes/blog-templete.html" rel="alternate" type="text/html" title="Blog title" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/blog-templete</id><content type="html" xml:base="https://gbcpp.github.io/notes/blog-templete.html"><![CDATA[<blockquote>
  <p>人们对学习的态度分为三种类型：犯人、过客和探索者。</p>
</blockquote>

<h2 id="犯人">犯人</h2>

<p>  他们可能视学习为一种负担或义务，而不是一种机会或乐趣。他们可能觉得被迫学习，而不是出于内心的愿望或对知识的渴望。这种态度可能会限制他们的学习潜力，因为他们可能无法全身心投入。</p>

<h2 id="过客">过客</h2>

<p>  他们可能对学习有一种漠不关心的态度，只是偶尔参与，没有持续的投入或深度的参与。他们可能在学习中得到一些知识，但可能无法充分利用学习的潜力，因为他们没有深入研究或投入足够的时间。</p>

<h2 id="探索者">探索者</h2>

<p>  他们热衷于学习，对新知识充满好奇心，愿意花时间和精力去探索和理解。他们可能会从学习中得到最大的收益，因为他们的态度使他们能够深入学习，发现新的想法和观点。</p>

<h2 id="总结">总结</h2>
<p>  这三种类型并不是固定不变的，人们可以改变自己对待学习的态度。但实际上，一个人在不同的时间或面对不同的主题时，可能会表现出这三种不同的态度。</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Life" /><summary type="html"><![CDATA[人们对学习的态度分为三种类型：犯人、过客和探索者。]]></summary></entry><entry><title type="html">NeoVim 安装配置记录</title><link href="https://gbcpp.github.io/notes/neovim.html" rel="alternate" type="text/html" title="NeoVim 安装配置记录" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/neovim</id><content type="html" xml:base="https://gbcpp.github.io/notes/neovim.html"><![CDATA[<blockquote>
  <p>安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。</p>
</blockquote>

<h2 id="windows-wsl-ubuntu">Windows WSL Ubuntu</h2>

<p>  WSL 下 Ubuntu 子系统的安装与原生的 Ubuntu 系统安装有所不同，主要是字体的配置方式上有所区别。</p>

<h3 id="install-neovim">Install NeoVim</h3>

<p>  我选择手动下载 NeoVim，这样可以安装官方最新版本，这里选择目前官方的最新版本 0.10.0，依次执行以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/tools
<span class="nb">cd</span> ~/tools
wget https://github.com/neovim/neovim/releases/download/v0.10.0/nvim-linux64.tar.gz
<span class="nb">tar </span>xzf nvim-linux64.tar.gz
</code></pre></div></div>

<p>上面下载的 <code class="language-plaintext highlighter-rouge">nvim-linux64.tar.gz</code> 为 NeoVim 的二进制包，可直接运行，可以将上述解压的 NeoVim 中的 bin 目录添加到系统环境变量 <code class="language-plaintext highlighter-rouge">PATH</code>中，或者为 NeoVim 在 <code class="language-plaintext highlighter-rouge">/usr/bin</code>目录下添加一个软连接：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> ~/tools/nvim-linux64/bin/nvim /usr/bin/nvim

<span class="c"># 可通过执行以下命令进行校验</span>
nvim <span class="nt">--version</span>
</code></pre></div></div>

<h3 id="neovim-configuration">NeoVim Configuration</h3>

<p>  使用 NeoVim 一个很大的门槛就是前期各种 <code class="language-plaintext highlighter-rouge">Plugins</code>的配置，目前有 <code class="language-plaintext highlighter-rouge">lazyVim</code>将很多易用的 <code class="language-plaintext highlighter-rouge">Plugins</code>打包在了一起，做到了开箱即用。</p>

<p>将 <code class="language-plaintext highlighter-rouge">LazyVim</code> 下载并解压到 <code class="language-plaintext highlighter-rouge">NeoVim</code>的配置目录下，启动 <code class="language-plaintext highlighter-rouge">NeoVim</code>便会自动安装了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 直接 clone 代码到 neovim 的配置文件目录下</span>
git clone https://github.com/LazyVim/starter ~/.config/nvim

<span class="c"># 启动 nvim，自动开始安装</span>
nvim
</code></pre></div></div>

<p>安装完成后，使用 nvim 随便打开一个目录可以看到 NeoTree 中的图标全是小方块，即乱码：</p>

<p><img src="/assets/img/blog/nerofont_0.png" alt="NeroFont0" /></p>

<p>继续以下操作，安装所有符号等宽展示的字体。</p>

<h3 id="install-nerd-font">Install Nerd Font</h3>

<p><a href="https://www.nerdfonts.com/">Nerd Font</a></p>

<p>选择下载 <code class="language-plaintext highlighter-rouge">JetBrainsMono Font</code> 字体，在 Windows 中解压缩后，可以看到内部全是后缀为 <code class="language-plaintext highlighter-rouge">.ttf</code> 的文件，选中后，右键 <code class="language-plaintext highlighter-rouge">安装</code> 即安装成功。</p>

<h3 id="windows-terminal-配置-mono-字体">Windows Terminal 配置 Mono 字体</h3>

<p>我的 <code class="language-plaintext highlighter-rouge">windows terminal</code> 版本如下 ：</p>

<p><img src="/assets/img/blog/win_terminal.png" alt="" /></p>

<p>该版本没有 UI 的配置界面，通过 <code class="language-plaintext highlighter-rouge">settings.json</code> 进行配置，在 <code class="language-plaintext highlighter-rouge">profiles</code> 的 <code class="language-plaintext highlighter-rouge">defaults</code> 配置中添加 <code class="language-plaintext highlighter-rouge">fontFace</code> 字段指定字体，如下：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"defaults"</span><span class="p">:</span><span class="w">
</span><span class="p">{</span><span class="w">
   </span><span class="err">//</span><span class="w"> </span><span class="err">Put</span><span class="w"> </span><span class="err">settings</span><span class="w"> </span><span class="err">here</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="err">you</span><span class="w"> </span><span class="err">want</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">apply</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">all</span><span class="w"> </span><span class="err">profiles.</span><span class="w">
   </span><span class="nl">"fontFace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JetBrainsMono Nerd Font Mono"</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">

</span><span class="err">....</span><span class="w">
</span></code></pre></div></div>

<p>配置成功后，重启 <code class="language-plaintext highlighter-rouge">windows terminal</code>，通过 NeoVim 打开上一次的目录，查看图标显示已正常：</p>

<p><img src="/assets/img/blog/nerofont_1.png" alt="" /></p>

<h2 id="mac">Mac</h2>

<h2 id="ubuntu">Ubuntu</h2>

<h2 id="常用功能介绍">常用功能介绍</h2>

<h3 id="窗口管理">窗口管理</h3>

<ul>
  <li>打开内置控制台，执行命令，这是比较常用的场景，不需要切换窗口，快捷键 <code class="language-plaintext highlighter-rouge">Ctrl + L</code>，目录定位在当前路径，不是当前被打开的目录：</li>
</ul>

<p><img src="/assets/img/blog/nvim_console.png" alt="" /></p>

<blockquote>
  <p>关闭亦是使用该快捷键。</p>
</blockquote>

<ul>
  <li>切换光标在 <code class="language-plaintext highlighter-rouge">NeoTree</code> 和代码窗口中，使用 <code class="language-plaintext highlighter-rouge">Ctrl + h|l|j|k</code>，即是 nvim 中移动光标位置的快捷键加上 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键便是上下左右切换窗口的快捷键。</li>
</ul>

<h3 id="快捷键引导">快捷键引导</h3>

<p><code class="language-plaintext highlighter-rouge">Normal</code>模式下输入空格键弹出功能菜单，均可按照快捷键说明进行操作，功能菜单有多层，退格键可返回，Esc 键退出。</p>

<p><img src="/assets/img/blog/nvim_menu.png" alt="" /></p>]]></content><author><name>Mr Chen</name></author><category term="notes" /><category term="develop" /><summary type="html"><![CDATA[安装配置 NeoVim，体验一下，对比 VSCode 谁更强大。]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/tech/float-performance-comparation.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/tech/float-performance-comparation</id><content type="html" xml:base="https://gbcpp.github.io/tech/float-performance-comparation.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<p>由于 float 在内存中的存储结构与 int 不同，需要存储指数和尾数，并且 cpu 是不支持直接对 float 进行运算的，需要将 float 各部分进行转换后计算，对结果再次进行反向操作进行存储，所以大部分情况下均不支持直接使用 float 进行运行，建议用 int 进行转换运行结果。</p>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>由于不同的 CPU 和体系架构对 FPU 支持情况的不同，以及不同的运算方法对结果也有很大的影响， 比如 加、减、乘、除，以及系数的不同：大于 1 或者小于 1 等均有不同的结果，上述结论为选择了较为复杂的计算场景，仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="Tech" /><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">float 和 int 在 Linux 下的计算性能对比</title><link href="https://gbcpp.github.io/notes/float-performance.html" rel="alternate" type="text/html" title="float 和 int 在 Linux 下的计算性能对比" /><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/float-performance</id><content type="html" xml:base="https://gbcpp.github.io/notes/float-performance.html"><![CDATA[<h1 id="linux下-float-与-int-类型计算性能对比">Linux下 Float 与 Int 类型计算性能对比</h1>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int64_t</span> <span class="n">kCalculateNum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000L</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testFloat</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">999999.</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">testInt</span><span class="p">()</span>  <span class="c1">// return void* in POSIX</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">;</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ts</span><span class="p">);</span>
  <span class="k">volatile</span> <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">999999</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">kCalculateNum</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ts</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">diff_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">end_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">float_duration_us</span> <span class="o">=</span> <span class="n">testFloat</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">int_duration_us</span> <span class="o">=</span> <span class="n">testInt</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">float_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Int calculate times: "</span> <span class="o">&lt;&lt;</span> <span class="n">kCalculateNum</span>
            <span class="o">&lt;&lt;</span> <span class="s">" took time: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_duration_us</span> <span class="o">&lt;&lt;</span> <span class="s">"us.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Float / Int radio: "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">float_duration_us</span> <span class="o">/</span> <span class="n">int_duration_us</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行结果">执行结果</h2>

<ul>
  <li>编译</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<p>多次执行，结果相当，计算 float 类型耗时大约是 int 整形的 62倍，即性能是 int 的 1/62 左右。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>g++ test_float.cpp <span class="nt">-g3</span> <span class="nt">-o</span> test_float.exe
gobert@DESKTOP-EJV14VH:~/develop/debug<span class="nv">$ </span>./test_float.exe
Float calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 2537060us.
Int calculate <span class="nb">times</span>: 100000000 took <span class="nb">time</span>: 40442us.
Float / Int radio: 62
</code></pre></div></div>

<p>以上仅供参考！！</p>]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Linux" /><category term="float" /><summary type="html"><![CDATA[Linux下 Float 与 Int 类型计算性能对比]]></summary></entry><entry><title type="html">获取不同 Clock Id 在不同 Linux Kernel 下的精度</title><link href="https://gbcpp.github.io/notes/measure-clock-resolution.html" rel="alternate" type="text/html" title="获取不同 Clock Id 在不同 Linux Kernel 下的精度" /><published>2023-10-25T00:00:00+00:00</published><updated>2023-10-25T00:00:00+00:00</updated><id>https://gbcpp.github.io/notes/measure-clock-resolution</id><content type="html" xml:base="https://gbcpp.github.io/notes/measure-clock-resolution.html"><![CDATA[]]></content><author><name>Mr Chen</name></author><category term="Notes" /><category term="Linux" /><category term="C++" /><summary type="html"><![CDATA[]]></summary></entry></feed>